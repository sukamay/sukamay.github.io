<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Usability Evaluation_Efficiency]]></title>
    <url>%2F2019%2F05%2F13%2FSoftwareTesting%2FEfficiency%2F</url>
    <content type="text"><![CDATA[2. Efficiency2.1 Performance Measurement2.2 Remote Testing2.2.1 OverviewRemote usability testing is used when tester(s) are separated in space and/or time from the participants. This means that the tester(s) cannot observe the testing process directly and that the participants are usually not in a formal usability laboratory. There are different types of remote testing. One is same-time but different-place, where the tester can observe the test user’s screen through computer network, and may be able to hear what the test user says during the test through speaker telephone. Another is different-time different-place testing such as journaled sessions, where the user’s test session is guided and logged through a special piece of software as well as additional code added to the system being tested. 2.2.2 ProcedureTools Computer network through which participants can send the test results to the tester Application like Look@me that allow the tester to observe the participant’s screen during the test Application like Lotus Videocam that can record, and replay the recorded screen series Speaker telephone if the participant is supposed to speak aloud or commnunicate with the tester Voice recording to record the verbal activities during the test Journal software to guide and log the usability test session 2.3 Retrospective Testing **Overview** If a videotape has been made of a usability test session, the tester(s) can collect more information by reviewing the videotape together with the user participants and asking them questions regarding their behavior during the test. So this technique should be used along with other techniques, especially those where the interaction between the testers and the participants is restricted. But using this technique means that each test takes at least twice as long. Another obvious requirement for using this technique is that the user’s interaction with the computer needs to be recorded and replayed. 1**Procedure** Review the recording of the usability test session with the test user. Ask the test user questions and let the test user describe what he/she is doing and why.]]></content>
      <categories>
        <category>SoftwareTesing</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TestPro_1]]></title>
    <url>%2F2019%2F05%2F12%2FSoftwareTesting%2FTestPro_1%2F</url>
    <content type="text"><![CDATA[TestPro_1usability evaluation1. LearnabilityBeginners are not familiar with the product, that is, the user’s learning process, the difficulty of the process, the speed is learning; poor learning for the user who just used the product, may be abandoned due to this obstacle. 1.1 Coaching Method1.1.1 Overview​ This technique can be used for usability test, where the participants are allowed to ask any system-related questions of an expert coach who will answer to the best of his or her ability. Usually the tester serves as the coach. One variant of the method involves a separate expert user serving as the coach, while the tester observes both the interaction between the participant and the computer, and the interaction between the participant and the coach. ​ The purpose of this technique is to discover the information needs of users in order to provide better training and documentation, as well as possibly redesign the interface to avoid the need for the questions. When an expert user is used as the coach, the expert user’s mental model of the system can also be analyzed by the tester. ​ The tester can also control the answers to certain predetermined information. 1.1.2 data neededThe answer and the degree how it help user to achieve the task. 1.1.3 report​ In an extensive series of experiments, one could vary the coach’s answers in order to learn what types of answers helped users the most. But this requires skilled and careful coaches since they need to compose answers on the fly to unpredictable user questions. 1.2 Question-asking Protocol1.2.1 Overview​ During a usability test, besides letting the test users to verbalize their thoughts as in the thinking aloud protocol, the testers prompt them by asking direct questions about the product, in order to understand their mental model of the system and the tasks, and where they have trouble in understanding and using the system. This is a more natural way than the thinking-aloud method in letting the test user to verbalize their thoughts. ​ Providing the test users with the product to be tested (or a prototype of its interface) and a set of tasks to perform. Ask the participants to perform the tasks using the product, and explain what they’re thinking about while working with the product’s interface. Also ask them pointed, direct questions about the product; for example, “How would you send the booking order?” Their response, either in terms of the product being tested or in other products from their past experience, will provide insights into their mental model of the product. 1.2.2 data needed​ Collecting users’ response. 1.2.3 report​ Analysis the response of users, extract key points and think about the shortcut of our product. 1.3 Task-Driven Method1.3.1 Overview​ Providing the test users with the product to be tested (or a prototype of its interface) and a set of tasks to perform. It should be divided into several stages and each stage has a time interval. For example, in the case of task time, the same subject performs the same task. The first test completion time is 50 seconds, the next test is 40 seconds, and the other month is 35; the test subject’s performance time tends to be stable. That is the maximum degree of performance of the task. By improving the product and then detecting changes in the indicator, wer may see if there is improvement in learning. 1.3.2 data needed The stage and time users take to complete a specific task. The stage and number of task of various kinds that can be completed within a give time limit. 1.3.3 report ​ Finally we should get a stable data, we could use mean or median to show the learnability of our product. 1.4 Performance Measurement1.4.1 Overview​ This technique is to used to obtain quantitative data about test participants’ performance when they perform the tasks during usability test. This will generally prohibit an interaction between the participant and the tester during the test that will affect the quantitative performance data. It should be conducted in a formal usability laboratory so that the data can be collected accurately and possible unexpected interference is minimized. Quantitative data is most useful in doing comparative testing, or testing against predefined benmarks. To obtain dependable results, at least 5 user participants are needed, while 8 or more participants would be more desirable. The technique can be used in combination with retrospective testing, post-test interview or questionnaires so that both quantitative and qualitative data are obtained.It can be also used in combination with task-driven method so that we get concrete tasks. The technique can be used in the following development stages: code, test, and deployment. 1.4.2 ProcedureDefine the Goals Define the goals for the usability testing in terms of usability attribute (e.g. easy to learn, efficietn to use, easy to remember, few errors, subjectively pleasing). Balance the various components of the goals and decide on their relative importance. Quantify these usability issues by measurements such as those given below: The time users take to complete a specific task. The number of task of various kinds that can be completed within a give time limit. The Ratio between successful interactions and errors. The time spent recovering from errors. The number of user errors. The number of commands or other features that were never used by the user. The number of syste features the user can remember during a debriefing after the test. The frequency of use of the manuals and/or the help system, and the time spent using them. The proportion of users who say that they would prefer using the system over some specified competitor. The proportion of users using efficient efficient working strategies in case there are multiple ways of performing the tasks.Conduct the Test Even though this technique is aimed to collect quantitative data, it should be noticed that it’s very important to collect qualitative data to uncover the user’s mental process and other information behind the quantitative data and take them into account while drawing the conclusions. 1.4.3 data needed The time users take to complete a specific task. The number of task of various kinds that can be completed within a give time limit. The Ratio between successful interactions and errors. The time spent recovering from errors. The number of user errors. The number of commands or other features that were never used by the user. The number of syste features the user can remember during a debriefing after the test. The frequency of use of the manuals and/or the help system, and the time spent using them. The proportion of users who say that they would prefer using the system over some specified competitor. The proportion of users using efficient efficient working strategies in case there are multiple ways of performing the tasks. 1.4.4 Analyze the Data to Draw the Conclusions​ To compare with a benchmark value (for ordinal, interval, or ratio data), mean or median can be calculated, together with standard deviation, standard error of the mean, and the confidence intervals. ​ To compare the data from different user interfaces, some kind of inferential statistics test can be performed. ###]]></content>
  </entry>
  <entry>
    <title><![CDATA[ORB_SLAM 源码解析 1]]></title>
    <url>%2F2019%2F05%2F12%2FSLAM%2FORB_SLAM_%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_1%2F</url>
    <content type="text"><![CDATA[ORB_SLAM 源码解析 跟踪线程 深度 双目初始化位姿 运动模型 关键帧模式 重定位 局部地图跟踪 关键帧 mpMap就是我们整个位姿与地图（可以想象成ORB-SLAM运行时的那个界面世界）， MapPoint和KeyFrame都被包含在这个mpMap中。 因此创建这三者对象（地图，地图点，关键帧）时， 三者之间的关系在构造函数中不能缺少。 另外，由于一个关键帧提取出的特征点对应一个地图点集， 因此需要记下每个地图点的在该帧中的编号； 同理，一个地图点会被多帧关键帧观测到， 也需要记下每个关键帧在该点中的编号。 地图点，还需要完成两个运算，第一个是在观测到该地图点的多个特征点中（对应多个关键帧）， 挑选出区分度最高的描述子，作为这个地图点的描述子； pNewMP-&gt;ComputeDistinctiveDescriptors(); 第二个是更新该地图点平均观测方向与观测距离的范围，这些都是为了后面做描述子融合做准备。 pNewMP-&gt;UpdateNormalAndDepth(); 跟踪 每一帧图像 Frame —&gt; 提取ORB关键点特征 —–&gt; 根据上一帧进行位置估计计算R t (或者通过全局重定位初始化位置) ——&gt; 跟踪局部地图，优化位姿 ——-&gt; 是否加入 关键帧 1. Tracking线程 帧 Frame 1】初始化​ 单目初始化 MonocularInitialization() ​ 双目初始化 StereoInitialization 2】相机位姿跟踪P​ 同时跟踪和定位 同时跟踪与定位，不插入关键帧，局部建图 不工作 ​ 跟踪和定位分离 mbOnlyTracking(false) ​ 位姿跟踪 TrackWithMotionModel() TrackReferenceKeyFrame() 重定位 Relocalization() a 运动模型（Tracking with motion model）跟踪 速率较快 假设物体处于匀速运动 ​ 用 上一帧的位姿和速度来估计当前帧的位姿使用的函数为TrackWithMotionModel()。 ​ 这里匹配是通过投影来与上一帧看到的地图点匹配，使用的是 ​ matcher.SearchByProjection(Frame &amp;CurrentFrame, const Frame &amp;LastFrame, …)。 ​ b 关键帧模式 TrackReferenceKeyFrame()​ 当使用运动模式匹配到的特征点数较少时，就会选用关键帧模式。即尝试和最近一个关键帧去做匹配。 ​ 为了快速匹配，本文利用了bag of words（BoW）来加速。 ​ 首先，计算当前帧的BoW，并设定初始位姿为上一帧的位姿； ​ 其次，根据位姿和BoW词典来寻找特征匹配，使用函数matcher.SearchByBoW(KeyFrame pKF, Frame &amp;F, …)； ​ 匹配到的是参考关键帧中的地图点。 ​ 最后，利用匹配的特征优化位姿。 ​ c 通过全局重定位来初始化位姿估计 Relocalization()​ 假如使用上面的方法，当前帧与最近邻关键帧的匹配也失败了， ​ 那么意味着需要重新定位才能继续跟踪。 ​ 重定位的入口如下： bOK = Relocalization(); ​ 此时，只有去和所有关键帧匹配，看能否找到合适的位置。 ​ 首先，计算当前帧的BOW向量，在关键帧词典数据库中选取若干关键帧作为候选。 ​ 使用函数如下：vector vpCandidateKFs = mpKeyFrameDB-&gt;DetectRelocalizationCandidates(&amp;mCurrentFrame); ​ 其次，寻找有足够多的特征点匹配的关键帧；最后，利用RANSAC迭代，然后使用PnP算法求解位姿。这一部分也在Tracking::Relocalization() 里 ​ 3】局部地图跟踪​ 更新局部地图 UpdateLocalMap() 更新关键帧和 更新地图点 UpdateLocalKeyFrames() UpdateLocalPoints ​ 搜索地图点 获得局部地图与当前帧的匹配 ​ 优化位姿 最小化重投影误差 3D点-2D点对 si pi = K T Pi = K exp(f) Pi 4】是否生成关键帧​ 加入的条件： ​ 很长时间没有插入关键帧 ​ 局部地图空闲 ​ 跟踪快要跟丢 ​ 跟踪地图 的 MapPoints 地图点 比例比较少 5】生成关键帧​ KeyFrame(mCurrentFrame, mpMap, mpKeyFrameDB) ​ 对于双目 或 RGBD摄像头构造一些 MapPoints，为MapPoints添加属性 进入LocalMapping线程 设置闭环检测帧 mpLoopCloser-&gt;InsertKeyFrame(mpCurrentKeyFrame); // ===]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ORB_SLAM 源码解析 0]]></title>
    <url>%2F2019%2F05%2F12%2FSLAM%2FORB-SLAM_%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ORB-SLAM_源码解析前言整体输入： 图像+时间码(传感器融合) 相机内参(标定好的)-相机zoom不可改变， focus尽量不变-给定标定图像的大小，计算内参跟图像大小有关(如果对采集图像进行缩放处理，则内参相应缩放) 相关配置文件，如指定特征检测描述子，给出对应特征描述子的词汇表，具体内部设置的一些经验值等 关键类：1. Tracking 跟踪要处理每帧图像数据 面向对象思想-&gt;封装-将获取的图像数据封装成帧，后续处理都是针对于帧处理 具体Frame的结构 Image-&gt;存储图像数据(输入) Camera-&gt;存储相机内参信息(输入) Feature-&gt;存储帧对应的特征数据(计算) ( 一对多的关系) Mat-&gt;存储帧对应相机姿态(计算) 1.1 track1.1.1 Track reference key frame​ 初始化的时候根据参考关键帧估计当前帧位姿 1.1.2 Track with motion model​ 根据运动模型，估计当前帧位姿 1.1.3 Track Local Map​ 局部地图中的Map point找到了，跟上面一样，将这些Map Point进行投影到当前帧中，寻找匹配，确定3D-2D的关系 首先确定Map Point能否投影到当前帧上 Map Point的世界坐标转到相机坐标系下，看点的深度是否为正 Map Point投影到图像上，是否超出图像边界 Map Point在深度范围内(每个Map Point产生的最大最小深度) 当前视图方向与MapPoint的平均视图方向的夹角大于60度 ​ 总的来说，这三种跟踪(包括前面的两种)最终目标就是找到Map Point与当前帧的特征形成对应关系，通过PnP对当前帧的位姿进行求解。 1.2 重定位问题​ 我们会遇到跟踪丢失的情况，那接下来我们需要移动镜头进行重定位 具体主要通过关键帧数据库进行查找，找出与当前帧有关系的关键帧，确定候选关键帧 对每一一个候选关键帧，通过Bow进行匹配，如果有足够的匹配(匹配特征数超过15个) ，则构建PnP进行求解，计算出当前帧的相机外参。 EPnP算法 5次RANSAC迭代，计算相机外参 优化帧，如果匹配特征数没有50个，则将候选关键帧对应的map point投影到当前帧继续寻找匹配，匹配完成之后再次优化帧，如果匹配数还是没有大于50 ，则更改投影匹配阈值，再次匹配，只有匹配的个数大于50 ，才说明重定位成功，最后对大于50个匹配对的帧再次对帧进行优化。 1.3 跟踪确定关键帧​ 跟踪除了计算每帧的位姿，还有一个很重要的目的是确定关键帧​ 何时添加关键帧，或者说什么是关键帧： 关键帧不要太稠密(相邻两个关键帧之间有一定的间隔，原作实现时大约是30帧的间隔) 当前的帧至少匹配到了50个Map Point 当前帧匹配到的Map Point的个数不能超过参考关键帧(与当前帧拥有最多map point的关键帧)对应Map Point的90%，说明这个时候参考关键帧可以替代当前帧，还没有必要创建关键帧 局部地图优化空闲的时候 2. Local Mapping2.1 处理新关键帧​ 每添加一个keyframe. ，维护Covisibility Graph ， Spanning Tree ， Mapl以及计算该帧的词袋表示确定匹配，为三角化做准备 2.2 生成新的Map Point 得到当前关键帧(cur_ keyframe)在Covisibility Graph中邻接的一些关键帧(共同的map point数单目设置20 ) 对邻接的关键帧进行遍历 (每一个设为ref keyframe) ，在极线上进行搜索并三角化 基线( cur keyframe5ref keyframe )与ef keyframe对应的map point的深度均值比值不能太小，这样形成的3d点不够精确 对未匹配的特征点，首先通过orb的词汇树进行加速匹配 根据匹配点对，通过三角化计算3d点 检测三角化之后的点在相机前 在参考帧的重投影误差进行检测 对尺度进行检查 确定Map Point的相关属性(平均观察方向，观测距离，最佳描述子等) 产生了新的Map Point之后r该Map Point可能会被其他关键帧找到，为之前帧添加对应关 系，或者该Map Point与其他关键帧之间创建的Map Point有交集，具体做法为： 根据covisibility grapb找到邻接关键帧(共同map point数20 ) 遍历邻接关键帧，对每一个邻接关键帧再次计算有关系的关键帧(共同map point数5 )得到二级邻接关键帧 遍历当前帧的一级邻接和二级邻接的关键帧( each_ keyframe ) ，将当前帧对应的map point投影到each_ keyframe上，确定对应的特征是否已经有对应的map point ，如果有，我们选择map point对应观测量多的那个，没有则添加到each_ keyframe对应的特征上 2.3 Map Point剔除 是否为坏点（坏点为观察到它的关键帧的个数小于3），若为坏点直接剔除 能找到该点的帧不应该少于理论上观测到该点的帧的1/4 理论观察该点表示，该点能投影到的局部关键帧的个数 实际观测该点表示，优化后，能投影的关键帧的个数 从创建该Map Point开始到现在已经过了至少2个关键帧，但是观察到该点的关键帧不超过2个 2.4 关键帧剔除 根据Covisibility Graph确定局部关键帧，对所有局部关键帧都进行遍（each_keyframe） 对each_keyframe对应的每一个Map Point进行分析，与该Map Point对应的特征的个数大于3 如果each_frame上对应的Map Point能被其他至少3个关键帧观测到90%以上的话，就剔除它 2.5 local BA​ 添加完了关键帧及对应mappoint，有了这些新的约束，进行一次局部bundle adjustment，具体做法: 根据Covisibility Graph确定局部关键帧，设为图节点 根据局部关键帧，确定局部的map point ，设为图节点 再找到那些可以看到局部map point的关键帧，但是不是局部关键帧的，到时在优化的时候，设置为fixed ，不进行优化 把局部map point中每一个map point与观察到该map point的所有关键帧构建边， 边的观测值为map point对应的特征坐标，边的信息矩阵，考虑误差是一个像素*尺度 去除一些不好的边，再次进行优化，即对keyframe对应的相机外参和mappoint的世界坐标系中的位置进行了修正 3. Loop Closing​ 通过Local Mapping我们对KeyFrame的位姿和Map Point的位置进行了优化，但是实际计算出的位姿还是有误差的， 误差积累之后，则尺度不再统一，这就会产生尺度漂移问题，轨迹的误差也会越来越大，因此需要进行回环检测来解决它。 3.1 检测回环Loop Candidates Detection ​ Local Mapping线程处理之后，在Loop closing插入关键帧cur_ keyframe ，则Loop Closing线程处理，首先闭环检测，具体处理: 根据Covisility Graph确定局部关键帧( each_ keyframe ) 计算cur_ keyframe的词袋向量与所有each_ keyframe的词袋向量的相似度，得到最小相似度 在关键帧数据库中找到相似度不小于最小相似度的关键帧作为闭环的候选关键帧 一对每一 个候选关键帧检测其与之前回环的一致性。主要也就是通过连续三次的关键帧对应相同的候选闭环帧，则认为该帧为闭环帧。 3.2 计算相似变换Compute the Similarity Transformation 找到了当前关键帧可能的候选闭环帧，计算当前关键帧与可能的候选闭环帧的匹配，根据特征的匹配，确定两帧之间map point的匹配(匹配数大于20 ) 通过RANSAC计算Sim3 ，然后根据这个Sim3进行处理，优化所有的对应。 两帧进行相互投影各自根据自己对应的map point寻找对应帧的匹配，最后看两个匹配一致的数目。 优化重投影误差optimizeSim3 将闭环帧及其相邻帧对应的mappoint投影到当前帧上，这边用sim3 ，寻找更多的匹配 如果匹配数大于40 ，则认为计算成功 3.3 闭环融合Loop Fusion 通过上一步计算，我们确定了闭环帧以及对应的Sim3，我们要做的是： 将当前关键帧对应的map point换成闭环帧对应的map point (这边都包括相邻的帧对应) 重新构建covisibility graph（考虑到环，需要更新相邻关键帧） 3.4 优化Essential Graph在Essential graph上进行姿态图优化 将地图中的所有关键帧设为顶点，估计量为每个关键帧对应的Sim3 ，闭环帧不做优化 添加闭环边，当前帧的集合与闭环帧的集合构成图中的边，权重小于100的不考虑，边的观测值是两帧之间的相对变化量，信息矩阵是单位阵 添加正常边，遍历所有的关键帧，找到关键帧对应的父节点也就是Spanning tree的边，边的观测值是两帧之间的相对变化量，信息矩阵是单位阵，继续遍历当前帧所对应的闭环帧，如果闭环帧在当前帧之间，则添加边，继续对covisibilitygraph权重大于100构成边，最后优化 4. Viewer]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django]]></title>
    <url>%2F2019%2F05%2F12%2FGuideBook%2FDjango%2FDjango_1%2F</url>
    <content type="text"><![CDATA[Django: 2.1.4 Python: 3.6.8]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo_in_Mac]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2Fhexo_in_Mac%2F</url>
    <content type="text"><![CDATA[Hexo in Mac hexo显示latex公式 hexo搭建 hexo和Typora的图片路径问题 这里说一下，可以修改Typora的偏好设置里复制图片到指定路径，另外hexo只认source旗下的图片 hexo连接样式设置 hexo隐藏指定文章 hexo打赏-参考官网 hexo搭建比较完整的教程 To do： hexo设置阅读量统计 hexo设置评论 hexo显示字数统计 hexo关于页面 hexo搜索页面 hexo头像样式 hexo设置平常的样式 hexo打赏功能]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周工作汇报]]></title>
    <url>%2F2019%2F05%2F11%2FWebAR%2F%E5%91%A8%E5%B7%A5%E4%BD%9C%E6%B1%87%E6%8A%A5%2F</url>
    <content type="text"><![CDATA[周工作汇报 一. 本周学习情况 日期 学习内容 2.15-2.22 论文阅读：The Argon AR Web Browser and standards-based AR application environment ; Web前端中的增强现实开发技术研究_庄夏 二. 下周学习计划 了解ARCore的开发流程，进一步完善开发准备 继续阅读WebAR方向paper，了解最前沿动态 了解WebAR相关产品及使用的库]]></content>
      <categories>
        <category>WebAR</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Web_0]]></title>
    <url>%2F2019%2F05%2F11%2FWeb%2FWeb_0%2F</url>
    <content type="text"><![CDATA[Web_0May 2019.2.26 Introduction 服务器、数据库 Web项目：个人项目 内容：更注重前端 主要技术： Socket编程 HTTP协议 SSL协议 Web文档类型： 静态网页：html和css 活动网页： code run in browser js、flash 动态网页： code run in web server Java EE，NET ASP， PHP， Python 基本技术 [ ] Q：H5特性？ [ ] Q：并发性测试工具？ [ ] Q：Web的发展 可了解： 网页前端Bootstrap 编程前端JQuery Framework 编程后端PHP语言 WeChat TypeScript Web Security Web可视化echart]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[FishMem]]></title>
    <url>%2F2019%2F05%2F11%2FFishMem%2F</url>
    <content type="text"><![CDATA[FishMem阿里云服务器IP地址：120.76.62.132 电脑IP地址：pc.washingpatrick.cn 1ssh mei/root@pc.washingpatrick.cn -p 5000 12https://img1.360buyimg.com/n6/jfs/t1/26161/40/7321/159453/5c6a5fc6Ecc0df3bf/a03e44d30d60352f.jpghttps://img1.360buyimg.com/n6/jfs/t22405/273/1704311852/168416/6cc2bf5d/5b34b4fdNe12e22fe.jpg 73，80,105,121 ,134，137，145，165，173，178，179，184，185，188，191，192，193，221，223，226，227，228，229-231，249，251-252，256，260-264 12cd /home/mei/Desktop/cv/darknetnohup ./darknet detector train cfg/noodles.data cfg/yolov2-noodles.cfg backup/yolov2-noodles_200.weights &gt;&gt; running.log 2&gt;&amp;1 &amp;]]></content>
  </entry>
  <entry>
    <title><![CDATA[课程建议]]></title>
    <url>%2F2019%2F05%2F11%2F%E8%AF%BE%E7%A8%8B%E5%BB%BA%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[课程建议 计算机图形学 计算机网络 软件工程 希望可以提建议而不是要求 三维与后期技术 [x] 强烈建议老师课前先给ppt！ 数字图像处理： [ ] 论文推荐？ 软件架构： 建议pdf在第四周之前就发给同学们，突然间课就多了好多 [ ] ！进度比老师快，也没关系的，想学就往下学，不要被课程进度束缚 test test 【it works！】]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2019%2F05%2F11%2Fmarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[罗马数字：Ⅰ、Ⅱ、Ⅲ、Ⅳ、Ⅴ、Ⅵ、Ⅶ、Ⅷ、Ⅸ、Ⅹ、Ⅺ、Ⅻ 例子 markdown $\frac{7x+5}{1+y^2}$ \frac{7x+5}{1+y^2} $z = z_l$ z=z_l $\cdots$ \cdots $\frac{d}{dx}e^{ax}=ae^{ax}\quad \sum_{i=1}^{n}{(X_i - \overline{X})^2}$ \frac{d}{dx}e^{ax}=ae^{ax}\quad \sum_{i=1}^{n}{(X_i - \overline{X})^2} $\sqrt{2};\sqrt[n]{3}$ \sqrt{2};\sqrt[n]{3} $\vec{a} \cdot \vec{b}=0$ \vec{a} \cdot \vec{b}=0 $\int ^2_3 x^2 {\rm d}x$ \int ^2_3 x^2 {\rm d}x $\lim_{n\rightarrow+\infty} n$ \lim_{n\rightarrow+\infty} n $\sum \frac{1}{i^2}$ \sum \frac{1}{i^2} $\prod \frac{1}{i^2}$ \prod \frac{1}{i^2} 特殊字符对照表 数学公式语法 \vec{}\begin{bmatrix}1 & 2 & 3 \\4 & 5 & 6\end{bmatrix} \alpha \beta \gamma \delta \epsilon \zeta \eta \theta \iota \kappa \lambda \mu \nu \xi \omicron \pi \rho \sigma \tau \upsilon \phi \chi \psi \omega \Alpha \Beta \Gamma \Delta \Epsilon \Zeta \Eta \Theta \Iota \Kappa \Lambda \Mu \Nu \Xi \Omicron \Pi \Rho \Sigma \Tau \Upsilon \Phi \chi \Psi \Omegatest for href to cppfiles 12graph LRA --&gt; B 1234567graph TB A B[Bname] C(Cname) D((Dname)) E&gt;Ename] F&#123;Fname&#125; 1234567graph TB a1--&gt;b1 a2---b2 a3--text---b3 a4--text--&gt;b4 a5-.-b5 a6-.-&gt;b6 123456789st=&gt;start: 注册印象笔记e=&gt;end: 您可以使用markdownop1=&gt;operation: 登录印象笔记op2=&gt;operation: 购买并登录马克飞象cond=&gt;condition: 是否已经购买并登录了马克飞象?st-&gt;op1-&gt;condcond(yes)-&gt;econd(no)-&gt;op2-&gt;e]]></content>
  </entry>
  <entry>
    <title><![CDATA[GameDesign_0]]></title>
    <url>%2F2019%2F05%2F11%2FGameDesign%2FGameDesign_0%2F</url>
    <content type="text"><![CDATA[GameDesign_0tomb rainder]]></content>
      <categories>
        <category>GameDesign</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Caffe in Ubuntu]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FCaffe%20in%20Ubuntu%2F</url>
    <content type="text"><![CDATA[Caffe in Ubuntu config: System: Ubuntu 16.04 Nvidia Driver Version: 418.56 GPU：GeForce GTX 960M 安装显卡驱动（已经安装好了） 安装cuda 1234567891011121314151617181920212223mei@mei-luo:~$ sudo nvidia-smi[sudo] password for mei: Tue May 7 10:08:47 2019 +-----------------------------------------------------------------------------+| NVIDIA-SMI 418.56 Driver Version: 418.56 CUDA Version: 10.1 ||-------------------------------+----------------------+----------------------+| GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC || Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. ||===============================+======================+======================|| 0 GeForce GTX 960M Off | 00000000:01:00.0 Off | N/A || N/A 49C P8 N/A / N/A | 428MiB / 2004MiB | 0% Default |+-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+| Processes: GPU Memory || GPU PID Type Process name Usage ||=============================================================================|| 0 970 G /usr/lib/xorg/Xorg 145MiB || 0 1455 G compiz 231MiB || 0 1802 G /opt/teamviewer/tv_bin/TeamViewer 24MiB || 0 1912 G fcitx-qimpanel 23MiB |+-----------------------------------------------------------------------------+mei@mei-luo:~$ Error: ubuntu. cuda ERROR: You appear to be running an X server; cuda安装 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273Last login: Thu May 9 10:43:24 2019 from 10.20.150.177mei@mei-luo:~$ cd /home/mei/NVIDIA_CUDA-10.1_Samples/bin/x86_64/linux/release/mei@mei-luo:~/NVIDIA_CUDA-10.1_Samples/bin/x86_64/linux/release$ ./deviceQuery./deviceQuery Starting... CUDA Device Query (Runtime API) version (CUDART static linking)Detected 1 CUDA Capable device(s)Device 0: "GeForce GTX 960M" CUDA Driver Version / Runtime Version 10.1 / 10.1 CUDA Capability Major/Minor version number: 5.0 Total amount of global memory: 2004 MBytes (2101870592 bytes) ( 5) Multiprocessors, (128) CUDA Cores/MP: 640 CUDA Cores GPU Max Clock rate: 1176 MHz (1.18 GHz) Memory Clock rate: 2505 Mhz Memory Bus Width: 128-bit L2 Cache Size: 2097152 bytes Maximum Texture Dimension Size (x,y,z) 1D=(65536), 2D=(65536, 65536), 3D=(4096, 4096, 4096) Maximum Layered 1D Texture Size, (num) layers 1D=(16384), 2048 layers Maximum Layered 2D Texture Size, (num) layers 2D=(16384, 16384), 2048 layers Total amount of constant memory: 65536 bytes Total amount of shared memory per block: 49152 bytes Total number of registers available per block: 65536 Warp size: 32 Maximum number of threads per multiprocessor: 2048 Maximum number of threads per block: 1024 Max dimension size of a thread block (x,y,z): (1024, 1024, 64) Max dimension size of a grid size (x,y,z): (2147483647, 65535, 65535) Maximum memory pitch: 2147483647 bytes Texture alignment: 512 bytes Concurrent copy and kernel execution: Yes with 1 copy engine(s) Run time limit on kernels: No Integrated GPU sharing Host Memory: No Support host page-locked memory mapping: Yes Alignment requirement for Surfaces: Yes Device has ECC support: Disabled Device supports Unified Addressing (UVA): Yes Device supports Compute Preemption: No Supports Cooperative Kernel Launch: No Supports MultiDevice Co-op Kernel Launch: No Device PCI Domain ID / Bus ID / location ID: 0 / 1 / 0 Compute Mode: &lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) &gt;deviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 10.1, CUDA Runtime Version = 10.1, NumDevs = 1Result = PASSmei@mei-luo:~/NVIDIA_CUDA-10.1_Samples/bin/x86_64/linux/release$ ./bandwidthTest [CUDA Bandwidth Test] - Starting...Running on... Device 0: GeForce GTX 960M Quick Mode Host to Device Bandwidth, 1 Device(s) PINNED Memory Transfers Transfer Size (Bytes) Bandwidth(GB/s) 32000000 11.7 Device to Host Bandwidth, 1 Device(s) PINNED Memory Transfers Transfer Size (Bytes) Bandwidth(GB/s) 32000000 11.6 Device to Device Bandwidth, 1 Device(s) PINNED Memory Transfers Transfer Size (Bytes) Bandwidth(GB/s) 32000000 68.3Result = PASSNOTE: The CUDA Samples are not meant for performance measurements. Results may vary when GPU Boost is enabled.mei@mei-luo:~/NVIDIA_CUDA-10.1_Samples/bin/x86_64/linux/release$]]></content>
      <categories>
        <category>Ubuntu</category>
        <category>Caffe</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Caffe安装]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FCaffe%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Caffe安装1. 安装依赖1234luomeideMacBook-Pro:caffe luomei$ brew install -vd snappy leveldb gflags glog szip lmdbluomeideMacBook-Pro:caffe luomei$ brew tap homebrew/scienceluomeideMacBook-Pro:caffe luomei$ brew install hdf5 opencvluomeideMacBook-Pro:caffe luomei$ brew install protobuf boost 2. 下载、编译Caffe12luomeideMacBook-Pro:~ luomei$ git clone https://github.com/BVLC/caffe.gitluomeideMacBook-Pro:~ luomei$ cd caffe 开始报错了。。 先是找不到Makefile.config，原来压根没给这个文件，照着 Makefile.config.example 写了个文件。把opecvversion和cpu_only部分的注释去掉了。 看了一下是protobuf的问题，尝试了很多办法。。。 最后卸了3.6的，使用源码安装2.6的 12345./autogen.sh./configuremakemake checkmake install ​ 之后记得 12make cleanmake all 好的又报错了。。。 ./include/caffe/util/mkl_alternate.hpp:14:10: fatal error: ‘cblas.h’ file not found #include Makefile.config 里面原来这两句是被注释掉的，我是用homebrew安装的openblas，把注释解开就好了。 123# Homebrew puts openblas in a directory that is not on the standard search pathBLAS_INCLUDE := $(shell brew --prefix openblas)/includeBLAS_LIB := $(shell brew --prefix openblas)/lib fine，新的错 /usr/local/include/leveldb/status.h:26:11: error: expected ‘;’ at end of declaration list 看了一下是noexcept关键词报的错，添加C++11标准编译。 解决方法: Makefile 中定位到 1234567##############################Configure build###############################Linux 添加：CXXFLAGS += -std=c++11 这句的作用就是将编译时用到的g++加上编译选项“ -std=c++11”，加上此编译选项后用的就是11标准，不加貌似默认的是98标准。 Fine，又来错了 ld: framework not found vecLib clang: error: linker command failed with exit code 1 (use -v to see invocation) 12BLAS_INCLUDE ?= /System/Library/Frameworks/vecLib.framework/Versions/Current/Headers/LDFLAGS += -framework vecLib 看了一下vecLib出现的地方，看了一下自己系统里的文件，发现确实是没有Headers这个文件夹，vecLib.framework这个东西倒是有。 Solve: 将 makefile 中 vecLib 引用的位置 全部替换成 openblas 的 INCLUDE 和 LIB 都替换 如下 123 BLAS_INCLUDE := /usr/local/Cellar/openblas/0.3.0/includeLDFLAGS +=/usr/local/Cellar/openblas/0.3.0/lib/libopenblas.a]]></content>
      <categories>
        <category>GuideBook</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac_设置环境变量]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FMac_%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Mac_设置环境变量]]></content>
      <categories>
        <category>GuideBook</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OpenCV安装]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FOpenCV%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[OpenCV安装1234luomeideMacBook-Pro:opencv-3.4.5 luomei$ mkdir build &amp;&amp; cd buildluomeideMacBook-Pro:opencv-3.4.5 luomei$ cmake -G "Unix Makefiles" ..luomeideMacBook-Pro:opencv-3.4.5 luomei$ make -j8luomeideMacBook-Pro:opencv-3.4.5 luomei$ sudo make install 哭了，用这个方法装opencv3.4.0失败了，但是装3.4.5就好了/🤦‍♀️]]></content>
      <categories>
        <category>GuideBook</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu_程序后台运行]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FUbuntu_%E7%A8%8B%E5%BA%8F%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[Ubuntu_程序后台运行参考了nohup, linux 2&gt;&amp;1。 1.nohup用途：不挂断地运行命令。no hang up 语法：nohup Command [ Arg … ] [ &amp; ] 无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。 如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。 如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。 退出状态：该命令返回下列出口值： 126 可以查找但不能调用 Command 参数指定的命令。 127 nohup 命令发生错误或不能查找由 Command 参数指定的命令。 否则，nohup 命令的退出状态是 Command 参数指定命令的退出状态。 2.&amp;用途：在后台运行 一般两个一起用 nohup command &amp; eg: 123cd /home/mei/Desktop/cv/darknetnohup ./darknet detector train cfg/noodles.data cfg/yolov2-noodles.cfg backup/yolov2-noodles_200.weights &gt;&gt; running.log 2&gt;&amp;1 &amp;[1] 15776 进程号15776 3. &gt;基本含义 /dev/null 表示空设备文件 0 表示stdin标准输入 1 表示stdout标准输出 2 表示stderr标准错误 &gt;&gt; file 表示将标准输出输出到file中，也就相当于 1&gt;file 2&gt; error 表示将错误输出到error文件中 2&gt;&amp;1 也就表示将错误重定向到标准输出上 2&gt;&amp;1 &gt;file ：错误输出到终端，标准输出重定向到文件file，等于 &gt; file 2&gt;&amp;1(标准输出重定向到文件，错误重定向到标准输出)。 4. 查看运行的后台进程（1）jobs -l12root@ubuntu: jobs -I[1]+ 15776 Running nohup ./darknet detector train cfg/noodles.data cfg/yolov2-noodles.cfg backup/yolov2-noodles_200.weights &gt;&gt; running.log 2&gt;&amp;1 jobs命令只看当前终端生效的，关闭终端后，在另一个终端jobs已经无法看到后台跑得程序了，此时利用ps（进程查看命令） （2）ps -ef1`ps -aux|grep chat.js` 注： 用ps -def | grep查找进程很方便，最后一行总是会grep自己 用grep -v参数可以将grep命令排除掉 1`ps -aux|grep chat.js| grep -v grep` 再用awk提取一下进程ID 1`ps -aux|grep chat.js| grep -v grep | awk ``'&#123;print $2&#125;'` 3.如果某个进程起不来，可能是某个端口被占用 查看使用某端口的进程 1lsof -i:8090 1netstat -ap|grep 8090 查看到进程id之后，使用netstat命令查看其占用的端口 1netstat -nap|grep 7779 使用kill杀掉进城后再启动 4.终止后台运行的进程 1`kill -9 进程号`]]></content>
      <categories>
        <category>GuideBook</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Yolo训练自己的数据集]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FYolo_%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Yolo训练自己的数据集1234567891011config: +-----------------------------------------------------------------------------+| NVIDIA-SMI 430.09 Driver Version: 430.09 CUDA Version: 10.1 ||-------------------------------+----------------------+----------------------+| GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC || Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. ||===============================+======================+======================|| 0 GeForce GTX 960M Off | 00000000:01:00.0 Off | N/A || N/A 52C P0 N/A / N/A | 0MiB / 2004MiB | 0% Default |+-------------------------------+----------------------+----------------------+ 错误递归逐渐忘记要干嘛。。。 yolo训练时间 12345678910111213141516171819202122232425262728293031323334353637// cpu yolov3xxxdeMacBook-Pro:darknet xxx$ ./darknet detect cfg/yolov3.cfg yolov3.weights data/dog.jpg layer filters size input output 0 conv 32 3 x 3 / 1 608 x 608 x 3 -&gt; 608 x 608 x 32 0.639 BFLOPs ... 106 yoloLoading weights from yolov3.weights...Done!data/dog.jpg: Predicted in 18.616094 seconds.bicycle: 99%truck: 92%dog: 100%// cpu yolov2xxxdeMacBook-Pro:darknet xxx$ ./darknet detect cfg/yolov2.cfg yolov2.weights data/dog.jpg layer filters size input output 0 conv 32 3 x 3 / 1 608 x 608 x 3 -&gt; 608 x 608 x 32 0.639 BFLOPs ... 31 detectionmask_scale: Using default '1.000000'Loading weights from yolov2.weights...Done!data/dog.jpg: Predicted in 8.660725 seconds.dog: 82%truck: 64%bicycle: 85%// gpu yolov2, in another computer, but I didn't try cpu version// at least 100x faster than cpu versionmei@mei-luo:~/Desktop/cv/darknet$ ./darknet detect cfg/yolov2.cfg yolov2.weights layer filters size input output 0 conv 32 3 x 3 / 1 608 x 608 x 3 -&gt; 608 x 608 x 32 0.639 BFLOPs ... 31 detectionmask_scale: Using default '1.000000'Loading weights from yolov2.weights...Done!Enter Image Path: data/person.jpgdata/person.jpg: Predicted in 0.122470 seconds.horse: 82%dog: 86%person: 86% 一、数据集预准备VOC数据集目录结构如下： 1234567├──VOC2019 ├── Annotations ├── ImageSets ├── Layout ├── Main └── Segmentation └── JPEGImages 1.1 Annotations存放VOC格式的xml文件，每一个xml对应一张图像，并且每个xml中存放的是标记的各个目标的位置和类别信息，命名通常与对应的原始图像一样 1.2 ImageSetsImageSets我们只需要用到Main文件夹，这里面存放的是一些文本文件，通常为train.txt、test.txt等，该文本文件里面的内容是需要用来训练或测试的图像的名字（无后缀无路径） 1.3 JPEGImagesJPEGImages文件夹中放我们已按统一规则命名好的原始图像。 以此次我收集的关于泡面的数据集为例 数据来源：百度、京东、个人拍摄 12345678910├── JPEGImages ├── class_LR ├── LR00001.jpg ├── ... ├── class_XL ├── XL00001.jpg ├── ... ├── rename_voc.py ├── resize_pic.py └── voc_spider.py 图片命名格式为&lt;label_name&gt;&lt;num(len=5)&gt;.jpg，例如：LR00001.jpg 1.3.1 voc_spider.py可以直接编译，爬取的图片存储在当前目录下。图片命名格式为&lt;label_name&gt;&lt;num(len=5)&gt;.jpg，例如：LR00001.jpg。 1.3.2 resize_pic.py放缩图片大小，因为网络需要图片归一化，默认是处理成正方形的大小所以只需要输入一个数字，处理所在目录下的所有图片（递归式）。需要的图片尺寸大小应与yolo.cfg 中的大小一致。 123456789# yolov2.cfg[net]# Testingbatch=1subdivisions=1...width=608 !!!height=608 !!!... 1.3.3 rename_voc.py寻找文件夹下命名为class_&lt;label_name&gt;的文件并根据序号重命名。这个主要是针对自己拍摄的照片进行处理时需要统一命名。 1.4 ConclusionVOC数据集构建推荐步骤： 建立文件夹，目录结构如上述，建议命名为VOC+year，这样之后可以直接使用提供的voc_label.py。 JPEGImages下建立每个类的文件夹，我主要是为了方便区分，也不可以不分。 使用上述的py文件获取图片 最终所有图片都在JPEGImages文件夹下，不再另外区分。建议先做好这步！不然后期的xml文件夹还需要改动路径，不麻烦但是还是多了几步工作。 二、标记图像目标区域跑opencv，报错了。。 123456789101112131415xxxdeMacBook-Pro:main xxx$ pythonPython 2.7.10 (default, Feb 22 2019, 21:17:52) [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)] on darwinType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import cv2Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "/usr/local/lib/python2.7/site-packages/cv2/__init__.py", line 89, in &lt;module&gt; bootstrap() File "/usr/local/lib/python2.7/site-packages/cv2/__init__.py", line 79, in bootstrap import cv2ImportError: dlopen(/usr/local/lib/python2.7/site-packages/cv2/python-2.7/cv2.so, 2): Library not loaded: /usr/local/opt/ffmpeg/lib/libavcodec.58.dylib Referenced from: /usr/local/lib/libopencv_videoio.3.4.dylib Reason: image not found&gt;&gt;&gt; 看了一下自己并没有安装 ffmpeg 1xxxdeMacBook-Pro:main xxx$ brew install ffmpeg 我吹爆brew！原来尝试源码安装疯狂报错。。。 opencv能import了，然后numpy又报错了😭😭😭 123456789101112131415161718192021222324252627282930313233343536373839xxxdeMacBook-Pro:main xxx$ pythonPython 2.7.10 (default, Feb 22 2019, 21:17:52) [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)] on darwinType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import numpyTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "/usr/local/lib/python2.7/site-packages/numpy/__init__.py", line 142, in &lt;module&gt; from . import core File "/usr/local/lib/python2.7/site-packages/numpy/core/__init__.py", line 71, in &lt;module&gt; raise ImportError(msg)ImportError: IMPORTANT: PLEASE READ THIS FOR ADVICE ON HOW TO SOLVE THIS ISSUE!Importing the multiarray numpy extension module failed. Mostlikely you are trying to import a failed build of numpy.Here is how to proceed:- If you're working with a numpy git repository, try `git clean -xdf` (removes all files not under version control) and rebuild numpy.- If you are simply trying to use the numpy version that you have installed: your installation is broken - please reinstall numpy.- If you have already reinstalled and that did not fix the problem, then: 1. Check that you are using the Python you expect (you're using /usr/bin/python), and that you have no directories in your PATH or PYTHONPATH that can interfere with the Python and numpy versions you're trying to use. 2. If (1) looks fine, you can open a new issue at https://github.com/numpy/numpy/issues. Please include details on: - how you installed Python - how you installed numpy - your operating system - whether or not you have multiple versions of Python installed - if you built from source, your compiler versions and ideally a build log Note: this error has many possible causes, so please don't comment on an existing issue about this - open a new one instead.Original error was: No module named _multiarray_umathxxxdeMacBook-Pro:main xxx$ sudo find /usr/local/lib/python* | grep numpy 看了一下自己文件里的numpy，发现在python3.7下import是没有任何毛病的！干脆就把/usr/local/lib/python2.7/site-pacages/ 下的numpy删了，再测试了一下，ojbk👌 fine，我很ok的，我配环境配两天了，佛了，被环境工程劝退，又是头秃的一天啊！😃😃😃 推测一下出现这么多错可能是因为我同时存在了多个python的版本，有的包可能同时存在几个版本，容易冲突，这个标记的demo是在python2.7的环境下跑的，所以这些包我都尽量装在python2.7/site-pacages 目录下，使用pip指定目录安装 12# pip install --target=&lt;target_path&gt; &lt;pacakages&gt;xxxdeMacBook-Pro:main xxx$ pip install --target=/usr/local/lib/python2.7/site-pacages/ lxml 新的错，来自lxml，无法import etree，然鹅！python3.6下跑没有任何毛病= = 123456789101112131415161718xxxdeMacBook-Pro:main xxx$ pythonPython 2.7.10 (default, Feb 22 2019, 21:17:52) [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)] on darwinType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import lxml&gt;&gt;&gt; from lxml import etreeTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ImportError: cannot import name etree&gt;&gt;&gt; xxxdeMacBook-Pro:main xxx$ python3Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwinType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; from lxml import etree&gt;&gt;&gt; etree.__version__'4.3.3'&gt;&gt;&gt; exit() 注意：出错还有另外的可能是你的Python项目中有名称为lxml的文件（夹），就有可能导致这种错误。这种情况的话，把项目中对应的文件名称修改即可 曲线救国了 找到了另一个labelImg，好了！完美！ git：labelImg的git地址 123456# install lableImg in Mac OS X 10.14pip3 install pyqt5 lxml # Install qt and lxml by pipmake qt5py3python3 labelImg.pypython3 labelImg.py [IMAGE_PATH] [PRE-DEFINED CLASS FILE] 以下是xml的标准格式：1234567891011121314151617181920212223242526&lt;annotation&gt; &lt;folder&gt;JPEGImages&lt;/folder&gt; &lt;filename&gt;LR00001.jpg&lt;/filename&gt; &lt;path&gt;/home/mei/Desktop/cv/darknet/scripts/VOCdevkit/NOODLE2019/JPEGImages/LR00001.jpg&lt;/path&gt; &lt;source&gt; &lt;database&gt;Unknown&lt;/database&gt; &lt;/source&gt; &lt;size&gt; &lt;width&gt;608&lt;/width&gt; &lt;height&gt;608&lt;/height&gt; &lt;depth&gt;3&lt;/depth&gt; &lt;/size&gt; &lt;segmented&gt;0&lt;/segmented&gt; &lt;object&gt; &lt;name&gt;luxiang&lt;/name&gt; &lt;pose&gt;Unspecified&lt;/pose&gt; &lt;truncated&gt;0&lt;/truncated&gt; &lt;difficult&gt;0&lt;/difficult&gt; &lt;bndbox&gt; &lt;xmin&gt;393&lt;/xmin&gt; &lt;ymin&gt;304&lt;/ymin&gt; &lt;xmax&gt;583&lt;/xmax&gt; &lt;ymax&gt;465&lt;/ymax&gt; &lt;/bndbox&gt; &lt;/object&gt;&lt;/annotation&gt; 可能需要更改的地方： folder folder为最终跑模型的时候图片的放置位置。该命令运行在ubuntu 下 1find -name '*.xml' |xargs perl -pi -e 's|&lt;folder&gt;class_LR|&lt;folder&gt;JPEGImages|g' filename 可能导出的filename是没有文件后缀的，统一加上 1find -name '*.xml' |xargs perl -pi -e 's|&lt;/filename&gt;|.jpg&lt;/filename&gt;|g' path path为图片在跑的模型上的绝对路径（因为我需要移植到另外一台电脑上跑） 1find -name '*.xml' |xargs perl -pi -e 's|&lt;path&gt;$(your_original_pic_path)|&lt;path&gt;$(your_final_pic_path)|g' width, height 有时候在Windows下用该工具label图像，可能会出现size那里的width和height都为0，如果在label之前已经归一化了图像大小那么就可以用下面两行命令来修改这个0值 12find -name '*.xml' |xargs perl -pi -e 's|0&lt;/width&gt;|608&lt;/width&gt;|g'find -name '*.xml' |xargs perl -pi -e 's|0&lt;/height&gt;|608&lt;/height&gt;|g' 三、用yolov2训练3.1 生成相关文件​ 按darknet的说明编译好后，接下来在darknet-master/scripts文件夹中新建文件夹VOCdevkit，然后将整个VOC2007文件夹都拷到VOCdevkit文件夹下。 ​ 然后，需要利用scripts文件夹中的voc_label.py文件生成一系列训练文件和label，具体操作如下： ​ 首先需要修改voc_label.py中的代码，这里主要修改数据集名，以及类别信息，我的是VOC2019，并且所有样本用来训练，有两类目标，因此按如下设置 123456789101112131415161718192021222324252627... #sets=[('2012', 'train'), ('2012', 'val'), ('2007', 'train'), ('2007', 'val'), ('2007', 'test')] #classes = ["aeroplane", "bicycle", "bird", "boat", "bottle", "bus", "car", "cat", "chair", "cow", "diningtable", "dog", "horse", "motorbike", "person", "pottedplant", "sheep", "sofa", "train", "tvmonitor"] sets=[('2019', 'train')]classes = [ "luxiang", "xiangla"] ... def convert_annotation(year, image_id): in_file = open('VOCdevkit/VOC%s/Annotations/%s.xml'%(year, image_id)) #（如果使用的不是VOC而是自设置数据集名字，则这里需要修改） out_file = open('VOCdevkit/VOC%s/labels/%s.txt'%(year, image_id), 'w') #（同上） ... for year, image_set in sets: if not os.path.exists('VOCdevkit/VOC%s/labels/'%(year)): os.makedirs('VOCdevkit/VOC%s/labels/'%(year)) image_ids = open('VOCdevkit/VOC%s/ImageSets/Main/%s.txt'%(year, image_set)).read().strip().split() list_file = open('%s_%s.txt'%(year, image_set), 'w') for image_id in image_ids: list_file.write('%s/VOCdevkit/VOC%s/JPEGImages/%s.jpg\n'%(wd, year, image_id)) convert_annotation(year, image_id) list_file.close() 修改好后在该目录下运行命令：python voc_label.py，之后则在文件夹script/VOCdevki/VOC2019下生成了文件夹labels： 12345├──VOC2019 ├── labels ├── LR00000.txt ├── LR00091.txt ├── ... 同时在scripts/下应该也生成了2019_train.txt这个文件，里面包含了所有训练样本的绝对路径。 ❗️❗️❗️注意一下此时darknet/文件夹下是否也生成了train.txt 文件，如果有，检查一下是否为空，若为空就把 2019_train.txt 的内容移到 train.txt。 3.2 配置文件修改​ 做好了上述准备，就可以根据不同的网络设置（cfg文件）来训练了。在文件夹cfg中有很多cfg文件，应该跟caffe中的prototxt文件是一个意思。这里以yolov2.cfg‘为例，主要修改参数如下： 12345678910111213141516171819202122232425262728..[convolutional]size=1stride=1pad=1filters=35//修改最后一层卷积层核参数个数，计算公式是依旧自己数据的类别数filter=num×（classes + coords + 1）=5×（1+4+1）=30activation=linear[region]anchors = 1.08,1.19, 3.42,4.41, 6.63,11.38, 9.42,5.11, 16.62,10.52bias_match=1classes=2 //类别数，本例为1类coords=4num=5softmax=1jitter=.2rescore=1object_scale=5noobject_scale=1class_scale=1coord_scale=1absolute=1thresh = .6random=1 ​ 另外也可根据需要修改learning_rate、max_batches等参数。 ​ 修改好了cfg文件之后，就需要修改两个文件，首先是data文件下的voc.names。打开voc.names文件可以看到有20类的名称，本例中只有一类，检测人，因此将原来所有内容清空，写上自己数据集对应的类名并保存。名字仍然用这个名字，如果喜欢用其他名字则请按一开始制作自己数据集的时候的名字来修改。 ​ 接着需要修改cfg文件夹中的voc.data文件。也是按自己需求修改，我的修改之后是这样的画风： 12345classes= 1 //类别数 train = /home/mei/Desktop/cv/darknet/scripts/2019_train.txt //训练样本的绝对路径文件，也就是上文2.1中最后生成的 //valid = /home/pjreddie/data/voc/2007_test.txt //本例未用到 names = data/voc.names //上一步修改的voc.names文件 backup = backup/ //指示训练后生成的权重放在哪 修改后按原名保存最好，接下来就可以训练了。 3.3 运行训练​ 上面完成了就可以命令训练了，可以在官网上找到一些预训练的模型作为参数初始值，也可以直接训练，训练命令为 1$./darknet detector train ./cfg/voc.data cfg/tiny-yolo-voc.cfg 如果用官网的预训练模型darknet.conv.weights做初始化，则训练命令为 1$./darknet detector train ./cfg/voc.data .cfg/tiny-yolo-voc.cfg darknet.conv.weights 不过我没试成功，加上这个模型直接就除了final，不知道啥情况。当然也可以用自己训练的模型做参数初始化，万一训练的时候被人终端了，可以再用训练好的模型接上去接着训练。 ​ 训练过程中会根据迭代次数保存训练的权重模型，然后就可以拿来测试了，测试的命令同理： 1./darknet detector test cfg/voc.data cfg/tiny-yolo-voc.cfg results/tiny-yolo-voc_6000.weights data/images.jpg ​ 这样就完成了整个流程。]]></content>
      <categories>
        <category>GuideBook</category>
      </categories>
      <tags>
        <tag>yolo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yolo_踩的坑]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FYolo_%E8%B8%A9%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Yolo_踩的坑 Config: 数据集处理： OS：Mac OS X 10.14 跑模型： OS：Ubuntu 16.04 GPU：GetForce GTX 960M NVIDIA Driver：430.09 Cuda：10.1 Cudnn：7.5.1 安装并没有太多问题，准备跑自己的模型的时候还是遇到了蛮多问题 推一下官方教程：https://pjreddie.com/darknet/yolo/ 1. cuda error: out of memory darknet: ./src/cuda.c:36: check_error: Assertion `0’ failed.改一下cfg，减小batch，增大subdivisions]]></content>
      <categories>
        <category>GuideBook</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[修复dyld： Library not loaded]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FPycharm_dyld%2F</url>
    <content type="text"><![CDATA[修复dyld： Library not loaded1234567891011121314151617# 查看python所在的位置&gt; which python输出：/usr/local/bin/python# 查看 /usr/local/bin/python 的依赖&gt; otool -L /usr/local/bin/python输出：/usr/local/bin/python: /usr/local/Cellar/python3/3.6.3/Frameworks/Python.framework/Versions/3.6/Python (compatibility version 3.6.0, current version 3.6.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.0.0)可以看出依赖3.6.3已经写死了# 将 /usr/local/bin/python 的依赖更改为当前版本python的路径# 更改为当前python3.6.5的路径&gt; install_name_tool -change /usr/local/Cellar/python3/3.6.3/Frameworks/Python.framework/Versions/3.6/Python /usr/local/Cellar/python/3.6.5/Frameworks/Python.framework/Versions/3.6/Python /usr/local/bin/python]]></content>
      <categories>
        <category>GuideBook</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Yolo training my dataset]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2Fyolo_traingMyDataset%2F</url>
    <content type="text"><![CDATA[Yolo training my dataset12345678910111213config:# run my model in windows +-----------------------------------------------------------------------------+| NVIDIA-SMI 430.09 Driver Version: 430.09 CUDA Version: 10.1 ||-------------------------------+----------------------+----------------------+| GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC || Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. ||===============================+======================+======================|| 0 GeForce GTX 960M Off | 00000000:01:00.0 Off | N/A || N/A 52C P0 N/A / N/A | 0MiB / 2004MiB | 0% Default |+-------------------------------+----------------------+----------------------+ Pre: Yolo running time test: 12345678910111213141516171819202122232425262728293031323334353637// cpu yolov3xxxdeMacBook-Pro:darknet xxx$ ./darknet detect cfg/yolov3.cfg yolov3.weights data/dog.jpg layer filters size input output 0 conv 32 3 x 3 / 1 608 x 608 x 3 -&gt; 608 x 608 x 32 0.639 BFLOPs ... 106 yoloLoading weights from yolov3.weights...Done!data/dog.jpg: Predicted in 18.616094 seconds.bicycle: 99%truck: 92%dog: 100%// cpu yolov2xxxdeMacBook-Pro:darknet xxx$ ./darknet detect cfg/yolov2.cfg yolov2.weights data/dog.jpg layer filters size input output 0 conv 32 3 x 3 / 1 608 x 608 x 3 -&gt; 608 x 608 x 32 0.639 BFLOPs ... 31 detectionmask_scale: Using default '1.000000'Loading weights from yolov2.weights...Done!data/dog.jpg: Predicted in 8.660725 seconds.dog: 82%truck: 64%bicycle: 85%// gpu yolov2, in another computer, but I didn't try cpu version// at least 100x faster than cpu versionmei@mei-luo:~/Desktop/cv/darknet$ ./darknet detect cfg/yolov2.cfg yolov2.weights layer filters size input output 0 conv 32 3 x 3 / 1 608 x 608 x 3 -&gt; 608 x 608 x 32 0.639 BFLOPs ... 31 detectionmask_scale: Using default '1.000000'Loading weights from yolov2.weights...Done!Enter Image Path: data/person.jpgdata/person.jpg: Predicted in 0.122470 seconds.horse: 82%dog: 86%person: 86% 1、DatasetThe VOC dataset directory structure is as follows： 1234567├──VOC2019 ├── Annotations ├── ImageSets ├── Layout ├── Main └── Segmentation └── JPEGImages 1.1 AnnotationsStore the xml file in VOC format, each xml corresponds to an image, and each xml stores the location and category information of each target of the tag, and the naming is usually the same as the corresponding original image. 1.2 ImageSetsImageSets we only need to use the Main folder, which is stored in some text files, usually train.txt, test.txt, etc. The content of the text file is the name of the image that needs to be trained or tested (no suffix) No path) 1.3 JPEGImagesIn the JPEGImages folder, put the original image we have named according to the uniform rules. Take the data set about the instant noodles that I collected this time as an example. Source: Baidu, Jingdong, personal shooting 12345678910├── JPEGImages ├── class_LR ├── LR00001.jpg ├── ... ├── class_XL ├── XL00001.jpg ├── ... ├── rename_voc.py ├── resize_pic.py └── voc_spider.py The image naming format is &lt;label_name&gt;&lt;num(len=5)&gt;.jpg，eg：LR00001.jpg 1.3.1 voc_spider.pyIt can be compiled directly, the captured image is stored in the current directory. The picture naming format is &lt;label_name&gt;&lt;num(len=5)&gt;.jpg, for example: LR00001.jpg. 1.3.2 resize_pic.pyUse to reduce the size of the image, because the network needs to normalize the image, the default is to process the size of the square so you only need to enter a number to process all the images in the directory (recursive). The required image size should match the size in yolo.cfg. 123456789# yolov2.cfg[net]# Testingbatch=1subdivisions=1...width=608 !!!height=608 !!!... 1.3.3 rename_voc.pyLook for the file named class_&lt;label_name&gt; under the folder and rename it according to the serial number. This is mainly for the uniform processing of the photos taken by myself. 1.4 ConclusionRecommended steps for VOC dataset construction: Create a folder with the directory structure as above. It is recommended to name it VOC+year, so you can use the provided voc_label.py directly. Create a folder for each class under JPEGImages. I mainly want to distinguish it, and it doesn’t matter. Use the py file above to get the image Finally all the pictures are in the JPEGImages folder and no longer distinguish them. It is recommended to do this step first! The xml folder that is not in the future needs to change the path, no trouble, but still a few more steps. 2、Marking the image target areaUse the tool labelImg from https://github.com/tzutalin/labelImg. 123456# install lableImg in Mac OS X 10.14pip3 install pyqt5 lxml # Install qt and lxml by pipmake qt5py3python3 labelImg.pypython3 labelImg.py [IMAGE_PATH] [PRE-DEFINED CLASS FILE] Standard format of *.xml file in VOC2019/Annotations/: 1234567891011121314151617181920212223242526&lt;annotation&gt; &lt;folder&gt;JPEGImages&lt;/folder&gt; &lt;filename&gt;LR00001.jpg&lt;/filename&gt; &lt;path&gt;/home/mei/Desktop/cv/darknet/scripts/VOCdevkit/NOODLE2019/JPEGImages/LR00001.jpg&lt;/path&gt; &lt;source&gt; &lt;database&gt;Unknown&lt;/database&gt; &lt;/source&gt; &lt;size&gt; &lt;width&gt;608&lt;/width&gt; &lt;height&gt;608&lt;/height&gt; &lt;depth&gt;3&lt;/depth&gt; &lt;/size&gt; &lt;segmented&gt;0&lt;/segmented&gt; &lt;object&gt; &lt;name&gt;luxiang&lt;/name&gt; &lt;pose&gt;Unspecified&lt;/pose&gt; &lt;truncated&gt;0&lt;/truncated&gt; &lt;difficult&gt;0&lt;/difficult&gt; &lt;bndbox&gt; &lt;xmin&gt;393&lt;/xmin&gt; &lt;ymin&gt;304&lt;/ymin&gt; &lt;xmax&gt;583&lt;/xmax&gt; &lt;ymax&gt;465&lt;/ymax&gt; &lt;/bndbox&gt; &lt;/object&gt;&lt;/annotation&gt; Some parts you may need to modify: folder The folder is the placement position of the image when the model is finally run. The command runs under ubuntu. 1find -name '*.xml' |xargs perl -pi -e 's|&lt;folder&gt;class_LR|&lt;folder&gt;JPEGImages|g' filename The filename that may be exported is without a file suffix. 1find -name '*.xml' |xargs perl -pi -e 's|&lt;/filename&gt;|.jpg&lt;/filename&gt;|g' Path Path is the absolute path of the image on the running model (because I need to port to another computer) 1find -name '*.xml' |xargs perl -pi -e 's|&lt;path&gt;$(your_original_pic_path)|&lt;path&gt;$(your_final_pic_path)|g' width, height Sometimes using the tool labelImg under Windows, there may be a size where the width and height are 0. If the image size has been normalized before the label, then the following two lines can be used to modify the value of 0. 12find -name '*.xml' |xargs perl -pi -e 's|0&lt;/width&gt;|608&lt;/width&gt;|g'find -name '*.xml' |xargs perl -pi -e 's|0&lt;/height&gt;|608&lt;/height&gt;|g' 3、Training YOLO on VOC3.1 Generate Labels for VOC You should install and make sure it can run successfully in you computer. Make a directory named VOCdevkit after darknet/scripts, copy your VOC2019 file in it. Now we need to generate the label files that Darknet uses. Darknet wants a .txt file for each image with a line for each ground truth object in the image that looks like: 1&lt;object-class&gt; &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt; Where x, y, width, and height are relative to the image’s width and height. To generate these file we will run the voc_label.py script in Darknet’s scripts/ directory. First we should modify the voc_label.py cause we don’t use the original VOC dataset. Here mainly modify the data set name, and category information, mine is VOC2019, and all samples are used for training, there are two types of targets, so set as follows: 123456789101112131415161718192021222324252627... #sets=[('2012', 'train'), ('2012', 'val'), ('2007', 'train'), ('2007', 'val'), ('2007', 'test')] #classes = ["aeroplane", "bicycle", "bird", "boat", "bottle", "bus", "car", "cat", "chair", "cow", "diningtable", "dog", "horse", "motorbike", "person", "pottedplant", "sheep", "sofa", "train", "tvmonitor"] sets=[('2019', 'train')]classes = [ "luxiang", "xiangla"] ... def convert_annotation(year, image_id): in_file = open('VOCdevkit/VOC%s/Annotations/%s.xml'%(year, image_id)) #（if you don't use the name 'VOC', modify this） out_file = open('VOCdevkit/VOC%s/labels/%s.txt'%(year, image_id), 'w') #（as above） ... for year, image_set in sets: if not os.path.exists('VOCdevkit/VOC%s/labels/'%(year)): os.makedirs('VOCdevkit/VOC%s/labels/'%(year)) image_ids = open('VOCdevkit/VOC%s/ImageSets/Main/%s.txt'%(year, image_set)).read().strip().split() list_file = open('%s_%s.txt'%(year, image_set), 'w') for image_id in image_ids: list_file.write('%s/VOCdevkit/VOC%s/JPEGImages/%s.jpg\n'%(wd, year, image_id)) convert_annotation(year, image_id) list_file.close() After modifying it, run the command in this directory: python voc_label.py, then generate the folder labels in the folder script/VOCdevki/VOC2019: 12345├──VOC2019 ├── labels ├── LR00000.txt ├── LR00091.txt ├── ... At the same time, the 2019_train.txt file should be generated under scripts/, which contains the absolute path of all training samples. ❗️❗️❗️ Note that the train.txt file is also generated under the darknet/ folder at this time. If there is, check if it is empty. If it is empty, move the contents of 2019_train.txt. Go to train.txt. 3.2 Modify Cfg for Pascal DataNow go to your Darknet directory. We have to change the cfg/voc.data config file to point to your data: 12345classes= 2train = &lt;path-to-voc&gt;/train.txt// valid = &lt;path-to-voc&gt;2007_test.txtnames = data/voc.namesbackup = backup You should replace &lt;path-to-voc&gt; with the directory where you put the VOC data. 3.3 Download Pretrained Convolutional WeightsFor training we use convolutional weights that are pre-trained on Imagenet. We use weights from the darknet53 model. You can just download the weights for the convolutional layers here (76 MB). 1wget https://pjreddie.com/media/files/darknet53.conv.74 3.4 Train The ModelNow we can train! Run the command: 1./darknet detector train cfg/voc.data cfg/yolov3-voc.cfg darknet53.conv.74 If you want to use multiple gpus run: 1./darknet detector train cfg/coco.data cfg/yolov3.cfg darknet53.conv.74 -gpus 0,1,2,3 If you want to stop and restart training from a checkpoint: 1./darknet detector train cfg/coco.data cfg/yolov3.cfg backup/yolov3.backup -gpus 0,1,2,3 Reference: yolo tutorial from csdn]]></content>
  </entry>
  <entry>
    <title><![CDATA[后台运行文件]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2F%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[后台运行文件使用tmux [python]UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xe5 in position 0: ordinal not in range(128) Solve: 1234# myfile.pyimport sysreload(sys)sys.setdefaultencoding('utf8')]]></content>
      <categories>
        <category>GuideBook</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Html_0 Introduction]]></title>
    <url>%2F2019%2F05%2F11%2FJavaScript%2FHtml_0%20_Introduction%2F</url>
    <content type="text"><![CDATA[Html_0 Introduction创建电子邮件链接？ 时间线绘制？ 重定向用户？（在head里设置 https的实现机制？SSL、数字证书 ——3.17—— CSS外边距]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js_1 web programming]]></title>
    <url>%2F2019%2F05%2F11%2FJavaScript%2Fjs_1%2F</url>
    <content type="text"><![CDATA[js_1 web programmingHyptertext Markup Language(HTML) web 表示代码段？ web 表示特殊字符？ ——&amp;amp; amp; 12&amp;amp;&amp;lt; W3c Nu html checker w3c html validator]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SoftwareTesting_1]]></title>
    <url>%2F2019%2F05%2F11%2FSoftwareTesting%2FSoftwareTesting_1%2F</url>
    <content type="text"><![CDATA[SoftwareTesting_1SAP system for test?]]></content>
      <categories>
        <category>SoftwareTesting</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SoftwareTesting_0]]></title>
    <url>%2F2019%2F05%2F11%2FSoftwareTesting%2FSoftwareTesting_0%2F</url>
    <content type="text"><![CDATA[SoftwareTesting_0Introduction Testing Terms• Test object • Test data • Test planning • Test design • Test implementation : • Test analysis : strategy • Test run/test suite : may be unordered test case • Test case – Test conditions (preconditions, inputs, expected outputs/behavior) • Test scenario : ordered step test case Software quality:more than just eliminating failures – Functionality: adequacy, accuracy, interoperability, – Reliability: maturity, fault tolerance, recoverability – Usability: understandability, ease of learning, operability, attractiveness, compliance to xyz – Efficiency: required time, consumption of resources – Maintainability: analyzability, changeability, stability, testability – Portability: adaptability, ease of installation, conformity, interchangeability • Quality characteristics must be prioritized Exerciseillegal input: [0,-1,2]; [1,2,3]; [3,3,4]; [3,4,5]; [4,4,4] [2^31,2^31,2^31]; [MAX, 9, 9 ], [MAX, MAX, 44], [MAX,MAX,MAX]]]></content>
      <categories>
        <category>SoftwareTesting</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分工]]></title>
    <url>%2F2019%2F05%2F11%2FSoftwareTesting%2FTestPro_0%2F</url>
    <content type="text"><![CDATA[分工 永潮： 谈瑞： PMD checkstyle 原理 introduction The explorative study should cover the background, objectives, functionalities and features, usage,and experimentations with the tool. checkstylebackgroundCheckstyle[1] is a static code analysis tool used in software development for checking if Java)source code complies with coding rules. Originally developed by Oliver Burn back in 2001, the project is maintained by a team of developers from around the world. The current stable release is version 8.17[2] which is targeted at the Java 8 language. Checkstyle is highly configurable and can be made to support almost any coding standard. An example configuration files are supplied supporting the Sun Code Conventions, Google Java Style. A good example of a report that can be produced using Checkstyle and Maven can be seen here . Current site contains documentation only for latest, released version. We only support this latest version. We highly recommend read latest documentation first.However, you might need documentation for previous releases because you are still using an older version and latest version describe some features that does not work for you.You can find documentation for most old versions using a URL format like http://checkstyle.sourceforge.net/version/X.X where “X.X” is the version number.Example: http://checkstyle.sourceforge.net/version/6.18 for version 6.18. objectivesCheckstyle is a development tool to help programmers write Java code that adheres to a coding standard. It automates the process of checking Java code to spare humans of this boring (but important) task. This makes it ideal for projects that want to enforce a coding standard. functionalitiesChecks: annotations Check location of annotation on language elements. By default, Check enforce to locate annotations immediately after documentation block and before target element, annotation should be located on separate line from target element. block checks Finds nested blocks, i.e. blocks that are used freely in the code. class design The check finds classes that are designed for extension (subclass creation). Nothing wrong could be with founded classes. This check makes sense only for library projects (not application projects) which care of ideal OOP-design to make sure that class works in all cases even misusage. Even in library projects this check most likely will find classes that are designed for extension by somebody. User needs to use suppressions extensively to got a benefit from this check, and keep in suppressions all confirmed/known classes that are deigned for inheritance intentionally to let the check catch only new classes, and bring this to team/user attention. coding Checks that array initialization contains a trailing comma. The check demands a comma at the end if neither left nor right curly braces are on the same line as the last element of the array. headers imports javadoc comments metrics miscellaneous modifiers naming conventions regexp Size violations whitespace CheckStyle默认提供一下主要检查内容： •Javadoc注释 •命名约定 •标题 •Import语句 •体积大小 •空白 •修饰符 •块 •代码问题 •类设计 •混合检查（包活一些有用的比如非必须的 System.out和printstackTrace） The Standard Checkstyle Checks are applicable to general Java coding style and require no external libraries. The standard checks are included in the base distribution. The site navigation menu lets you browse the individual checks by functionality. Checkstyle provides many checks that you can apply to your source code. Below is an alphabetical reference, the site navigation menu provides a reference organized by functionality. The whole list of what check style can check about is in the website “http://checkstyle.sourceforge.net/checks.html“. fearturesCheckstyle can check many aspects of your source code. It can find class design problems, method design problems. It also has the ability to check code layout and formatting issues. For a detailed list of available checks please refer to the Checks page. The programming style adopted by a software development project can help to ensure that the code complies with good programming practices which improves the quality, readability, re-usability of the code and may reduce the cost of development. The checks performed by Checkstyle are mainly limited to the presentation of the code. These checks do not confirm the correctness or completeness of the code. usageThis section documents the out-of-box supported methods for running Checkstyle. An Ant task. A Command Line tool. Note that there are loads of plug-ins for all the IDEs out there. here shows the steps of running checkstyle using the command line tool 1234567java -D&lt;property&gt;=&lt;value&gt; \ com.puppycrawl.tools.checkstyle.Main \ -c &lt;configurationFile&gt; \ [-f &lt;format&gt;] [-p &lt;propertiesFile&gt;] [-o &lt;file&gt;] \ [-s &lt;line:column&gt;] [-g | --generate-xpath-suppression] [--tabWidth &lt;length&gt;] \ [-t | --tree] [-T | --treeWithComments] [-J | treeWithJavadoc] [-j | --javadocTree] \ [-V | --version] [-h | --help] file... Checkstyle will process the specified files and by default report errors to standard out in plain format. Checkstyle requires a configuration XML filethat configures the checks to apply. Command line options are: -c configurationFile - specifies the location of the file that defines the configuration modules. The location can either be a filesystem location, or a name passed to the ClassLoader.getResource() method. -f format - specify the output format. Options are &quot;plain&quot; for the DefaultLogger and &quot;xml&quot; for the XMLLogger. Defaults to &quot;plain&quot;. -p propertiesFile - specify a properties file to use. -o file - specify the file to output to. -s line:column - print xpath suppressions at the file’s line and column position. Line and column numbers are integer values separated by a :, specify location in the file the suppression should be generated for. The option cannot be used with other options and requires exactly one file to run on to be specified. ATTENTION: generated result will have few queries, joined by pipe(|). Together they will match all AST nodes on specified line and column. You need to choose only one and recheck that it works. Usage of all of them is also ok, but might result in undesirable matching and suppress other issues. -g,--generate-xpath-suppression - generate to output a suppression.xml to use to suppress all violations from user’s config. Instead of printing every violation, all errors will be catched and single suppressions.xml file will be printed out. Used only with -coption. --tabWidth length - set the length of the tab character. Used only with -s and -gxs options. Default value is 8. -t, --tree - print Abstract Syntax Tree(AST) of the checked file. The option cannot be used other options and requires exactly one file to run on to be specified. -T, --treeWithComments - print Abstract Syntax Tree(AST) with comment nodes of the checked file. The option cannot be used with other options and requires exactly one file to run on to be specified. -J, --treeWithJavadoc - print Abstract Syntax Tree(AST) with Javadoc nodes and comment nodes of the checked file. Attention that line number and columns will not be the same as it is a file due to the fact that each javadoc comment is parsed separately from java file. The option cannot be used with other options and requires exactly one file to run on to be specified. -j, —javadocTree - print Parse Tree of the Javadoc comment. The file have to contain only Javadoc comment content without including ‘/*’ and ‘/‘ at the beginning and at the end respectively. For example: MyTestFile.javadoc 12* Test method.* @return true The option cannot be used other options and requires exactly one file to run on to be specified. -d, --debug - Print all debug logging of CheckStyle utility. -e, --exclude excludedPath - Directory/file to exclude from CheckStyle. The path can be the full, absolute path, or relative to the current path. Multiple excludes are allowed. -x, --exclude-regexp excludedPathPattern - Directory/file pattern to exclude from CheckStyle. Multiple excludes are allowed. -V, --version - print product version and exit. Any other option is ignored. -h, --help - print usage help message and exit. Any other option is ignored. --executeIgnoredModules - Allows ignored modules to be run. Note that the -n packageNamesFile option has been dropped for Checkstyle 5.0, because of significant changes regarding package name file handling. See for details. Set the properties for expanded property values by either by assigning system properties using the -D&lt;property&gt;=&lt;value&gt; arguments to java or specifying a property file using the -p option. If a property file is specified, the system properties are ignored. CLI is implemented by means of picocli library. Our CLI supports definition of arguments in file by means of AtFiles feature and also command line completion in Bash or ZSH Unix shells, see how to make ithere. checkstyle in IDEA install go to Settings -&gt;plugins-&gt;browse repositories, search checkstyle plugin and click install button use Add own configuration file experimentation]]></content>
      <categories>
        <category>SoftwareTesting</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[WebARonARCore开发记录]]></title>
    <url>%2F2019%2F05%2F11%2FWebAR%2F%E5%91%A8%E5%B7%A5%E4%BD%9C%E6%B1%87%E6%8A%A54.26%2F</url>
    <content type="text"><![CDATA[WebARonARCore开发记录之前是直接跑现成的demo，现在尝试自己一步步复现 由于WebXR Device API可能会经常变更，因此只有一小部分的开发版本的Chrome支持，可支持的版本为Chrome Canary/Dev versions 70-72. 先前已经设置好了浏览器的Flag 1. Install Web Server for Chrome，配置，具体如下：a) 设置Web Server URL，类似默认的文件路径 b) 设置Automatically show index.html （浏览器就会直接展示所在文件夹的index.html的网页） c) 通过STOP和RESTATRT按钮来控制服务器 d) Verify that at least one Web Server URL appears， 确保默认路径设置成功，默认本地URL为http://127.0.0.1:8887 2. 所在设备也要进行相应的设置a) Go to chrome：//inspect， 选择Port forwarding，添加8887端口 \3. 进入文件所在路径，加载index.html State of AR on the web 最先实现Web XR Device API的是Chrome 67 （需要设置flag 为#webxr），初始化的支持AR的相关特性在Chrome 70+（需要设置flag为#webxr-hit-test）实现，不久后，所有支持WebVR的浏览器都将支持WebXR Device API。 现在WebXR Device API支持的AR特性很少，light estimation，surfaces，meshes等特性未来可能会支持。 回顾一下之前的方块demo： 我们将在此基础上进一步改进 3. Add a cube to a surface现在我们已经确认我们有实时视频输入，我们的设备姿势设置我们的相机的位置和方向，以及3D立方体渲染在顶部，是时候开始使用命中测试与现实世界交互。我们希望能够在现实世界中找到一个表面（例如在地面上），并在那里放置一个立方体。 Hit Test？命中测试通常是从某个方向上的空间点投出直线并确定它是否与我们感兴趣的任何物体相交的方法。在我们的例子中，我们将点击我们AR的屏幕设备，所以想象一条光线从你的手指穿过你的设备，并直接进入你设备的相机所看到的物理世界。 WebXR Device API将告诉我们这条光线是否与现实世界中的任何物体相交，这些物体由基础AR功能和对世界的理解决定。如果我们通过我们的设备观察世界，稍微朝向地面倾斜，我们点击我们的手机，以便射线将撞击地面，我们应该期望发生碰撞的位置的响应。 设置场景在index.htmlwith ID中添加一个div，stabilization向表示稳定状态的用户显示动画，提示他们随身携带设备。这将在我们处于AR时显示，并在光罩找到表面后隐藏，通过&lt;body&gt;类控制。 12345 &lt;div id="stabilization"&gt;&lt;/div&gt; &lt;script src="../third_party/three.js/three.js"&gt;&lt;/script&gt; ...&lt;/body&gt;&lt;/html&gt; 现在，app.js要做的第一件事是摆脱浮动立方体场景。在onSessionStarted功能中，用DemoUtils.createCubeScene()替换new THREE.Scene()。 12// this.scene = DemoUtils.createCubeScene();this.scene = new THREE.Scene(); 在创建场景之后，我们需要创建一个在碰撞过程中放置的对象。three.js中的可渲染对象表示为THREE.Mesh对象，其中包含几何和材质。这是创建几何体和材质的代码，以及调整立方体的变换以使其原点位于其底面。现在，只创建网格，将其转换一次，然后将其存储为this.model。 1234const geometry = new THREE.BoxBufferGeometry(0.5, 0.5, 0.5);const material = new THREE.MeshNormalMaterial();geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.25, 0));this.model = new THREE.Mesh(geometry, material); onSessionStarted获取引用框架之后，我们在函数中添加构造函数。在onXRFrame函数中，调用reticle的update方法，并在&#39;stabilized&#39;Reticle找到一个表面后向body 添加一个类。这会隐藏稳定助手动画，提示用户移动他们的设备。 1234567891011121314151617181920212223class App &#123; ... onSessionStarted(session) &#123; ... this.reticle = new Reticle(this.session, this.camera); this.scene.add(this.reticle); this.frameOfRef = await this.session.requestFrameOfReference('eye-level'); this.session.requestAnimationFrame(this.onXRFrame); ... &#125; onXRFrame(time, frame) &#123; let session = frame.session; let pose = frame.getDevicePose(this.frameOfRef); this.reticle.update(this.frameOfRef); if (this.reticle.visible &amp;&amp; !this.stabilized) &#123; this.stabilized = true; document.body.classList.add('stabilized'); &#125; ... &#125;&#125; 我们现在只想在点击屏幕时执行命中测试，因此我们需要一个事件处理程序。 在构造函数中，将单击处理程序绑定到实例。 此外，在事件结束时绑定事件onSessionStarted，因为我们希望在添加事件之前确保浏览器支持所有内容。 最后，为我们的新onClick处理程序添加一个空类方法。 123456789101112131415161718class App &#123; constructor() &#123; ... this.onClick = this.onClick.bind(this); &#125; onSessionStarted(session) &#123; ... this.reticle = new Reticle(this.session, this.camera); this.scene.add(this.reticle); window.addEventListener('click', this.onClick); &#125; onClick(e) &#123; console.log('click!'); &#125;&#125; 4. 触发命中测试现在我们已经将模型和触发绑定到事件。XRSession的API需要一个原点，一个方向，以及我们之前创建的XRFrameOfReference。我们的原点是我们的设备在WebXR坐标系中的位置，方向是我们设备背面的矢量点。three.js有一些方便的函数用于从一个点投射出一个向量，所以让我们使用它们。我们可以利用来自three.js的raycaster为我们处理数学，这给了我们一个原点和向量作为THREE.Vector3s。x和y位置setFromCamera 是屏幕空间中的位置，此函数采用-1和1之间的标准化设备坐标中的值。我们只想尝试将对象放在屏幕中间，因此我们的x和y值仅为0。 requestHitTest返回一个解析为数组的promise，该数组XRHitResults存储命中发生位置的矩阵。如果我们设备的直线撞到墙壁或地板，则撞击的位置将是该直线与墙壁或地板相交的位置。如果我们找到一个命中，请进行第一次击中（最接近的击中）并将其变为a THREE.Matrix4。然后我们可以把我们之前创建的立方体放在碰撞位置。我们还确保将立方体添加到场景中，以便我们可以渲染它。由于我们现在需要使用await onClick，因此我们必须创建onClick一个异步函数。 1234567891011121314151617181920212223242526class App &#123; ... async onClick(e) &#123; const x = 0; const y = 0; this.raycaster = this.raycaster || new THREE.Raycaster(); this.raycaster.setFromCamera(&#123; x, y &#125;, this.camera); const ray = this.raycaster.ray; const origin = new Float32Array(ray.origin.toArray()); const direction = new Float32Array(ray.direction.toArray()); const hits = await this.session.requestHitTest(origin, direction, this.frameOfRef); if (hits.length) &#123; const hit = hits[0]; const hitMatrix = new THREE.Matrix4().fromArray(hit.hitMatrix); this.model.position.setFromMatrixPosition(hitMatrix); this.scene.add(this.model); &#125; &#125;&#125; 5. 预计成果 在运行应用程序时，应该能够看到跟踪地板表面的光罩。如果没有，请尝试使用手机慢慢环顾四周。 一旦看到光罩，在敲击时，应在立体光栅上放置一个立方体。 可能需要移动一点，以便底层AR平台可以更好地检测现实世界中的表面。低照明和没有特征的表面会降低场景理解的质量，并增加不会发现命中的机会。]]></content>
      <categories>
        <category>WebAR</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[本周学习情况]]></title>
    <url>%2F2019%2F05%2F11%2FWebAR%2F%E5%91%A8%E5%B7%A5%E4%BD%9C%E6%B1%87%E6%8A%A54.5%2F</url>
    <content type="text"><![CDATA[一. 本周学习情况 周工作汇报 日期 学习内容 4.1-4.5 视觉 SLAM 学习，高翔十四讲学习至第十三课，对 VSLAM 有了基本了解 二. 下周学习计划 购买设备 WebAR􏰃􏰄ARKit 开发继续 继续学习视觉 SLAM 附件： SLAM学习进度汇报]]></content>
      <categories>
        <category>WebAR</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ANR]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FANR%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ANR 1、ANR排错一般有三种类型 KeyDispatchTimeout(5 seconds) —主要是类型按键或触摸事件在特定时间内无响应 BroadcastTimeout(10 seconds) —BroadcastReceiver在特定时间内无法处理完成 ServiceTimeout(20 secends) —小概率事件 Service在特定的时间内无法处理完成 2、哪些操作会导致ANR在主线程执行以下操作： 高耗时的操作，如图像变换 磁盘读写，数据库读写操作 大量的创建新对象 3、如何避免 UI线程尽量只做跟UI相关的工作 耗时的操作(比如数据库操作，I/O，连接网络或者别的有可能阻塞UI线程的操作)把它放在单独的线程处理 尽量用Handler来处理UIThread和别的Thread之间的交互 4、解决的逻辑 使用AsyncTask 在doInBackground()方法中执行耗时操作 在onPostExecuted()更新UI 使用Handler实现异步任务 在子线程中处理耗时操作 处理完成之后，通过handler.sendMessage()传递处理结果 在handler的handleMessage()方法中更新UI 或者使用handler.post()方法将消息放到Looper中 5、如何排查 首先分析log 从trace.txt文件查看调用stack，adb pull data/anr/traces.txt ./mytraces.txt 看代码 仔细查看ANR的成因(iowait?block?memoryleak?) 6、监测ANR的Watchdog 最近出来一个叫LeakCanary FC(Force Close)什么时候会出现 Error OOM，内存溢出 StackOverFlowError Runtime,比如说空指针异常 解决的办法 注意内存的使用和管理 使用Thread.UncaughtExceptionHandler接口]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[APP启动过程]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FAPP%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[APP启动过程 上图就可以很好的说明App启动的过程 ActivityManagerService组织回退栈时以ActivityRecord为基本单位，所有的ActivityRecord放在同一个ArrayList里，可以将mHistory看作一个栈对象，索引0所指的对象位于栈底，索引mHistory.size()-1所指的对象位于栈顶 Zygote进程孵化出新的应用进程后，会执行ActivityThread类的main方法.在该方法里会先准备好Looper和消息队列，然后调用attach方法将应用进程绑定到ActivityManagerService，然后进入loop循环，不断地读取消息队列里的消息，并分发消息。 ActivityThread的main方法执行后,应用进程接下来通知ActivityManagerService应用进程已启动，ActivityManagerService保存应用进程的一个代理对象，这样ActivityManagerService可以通过这个代理对象控制应用进程，然后ActivityManagerService通知应用进程创建入口Activity的实例，并执行它的生命周期方法]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AIDL]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FAIDL%2F</url>
    <content type="text"><![CDATA[AIDL 创建一个接口，再里面定义方法 123456package com.example.taidl; interface ICalcAIDL &#123; int add(int x , int y); int min(int x , int y ); &#125; build一下gen目录下会生成ICalcAIDL.java文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/* * This file is auto-generated. DO NOT MODIFY. * Original file: /Users/dream/Downloads/android/androidProject/TAIDL/src/com/example/taidl/ICalcAIDL.aidl */package com.example.taidl;public interface ICalcAIDL extends android.os.IInterface&#123;/** Local-side IPC implementation stub class. */public static abstract class Stub extends android.os.Binder implements com.example.taidl.ICalcAIDL&#123;private static final java.lang.String DESCRIPTOR = "com.example.taidl.ICalcAIDL";/** Construct the stub at attach it to the interface. */public Stub()&#123;this.attachInterface(this, DESCRIPTOR);&#125;/** * Cast an IBinder object into an com.example.taidl.ICalcAIDL interface, * generating a proxy if needed. */public static com.example.taidl.ICalcAIDL asInterface(android.os.IBinder obj)&#123;if ((obj==null)) &#123;return null;&#125;android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);if (((iin!=null)&amp;&amp;(iin instanceof com.example.taidl.ICalcAIDL))) &#123;return ((com.example.taidl.ICalcAIDL)iin);&#125;return new com.example.taidl.ICalcAIDL.Stub.Proxy(obj);&#125;@Override public android.os.IBinder asBinder()&#123;return this;&#125;@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException&#123;switch (code)&#123;case INTERFACE_TRANSACTION:&#123;reply.writeString(DESCRIPTOR);return true;&#125;case TRANSACTION_add:&#123;data.enforceInterface(DESCRIPTOR);int _arg0;_arg0 = data.readInt();int _arg1;_arg1 = data.readInt();int _result = this.add(_arg0, _arg1);reply.writeNoException();reply.writeInt(_result);return true;&#125;case TRANSACTION_min:&#123;data.enforceInterface(DESCRIPTOR);int _arg0;_arg0 = data.readInt();int _arg1;_arg1 = data.readInt();int _result = this.min(_arg0, _arg1);reply.writeNoException();reply.writeInt(_result);return true;&#125;&#125;return super.onTransact(code, data, reply, flags);&#125;private static class Proxy implements com.example.taidl.ICalcAIDL&#123;private android.os.IBinder mRemote;Proxy(android.os.IBinder remote)&#123;mRemote = remote;&#125;@Override public android.os.IBinder asBinder()&#123;return mRemote;&#125;public java.lang.String getInterfaceDescriptor()&#123;return DESCRIPTOR;&#125;@Override public int add(int x, int y) throws android.os.RemoteException&#123;android.os.Parcel _data = android.os.Parcel.obtain();android.os.Parcel _reply = android.os.Parcel.obtain();int _result;try &#123;_data.writeInterfaceToken(DESCRIPTOR);_data.writeInt(x);_data.writeInt(y);mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0);_reply.readException();_result = _reply.readInt();&#125;finally &#123;_reply.recycle();_data.recycle();&#125;return _result;&#125;@Override public int min(int x, int y) throws android.os.RemoteException&#123;android.os.Parcel _data = android.os.Parcel.obtain();android.os.Parcel _reply = android.os.Parcel.obtain();int _result;try &#123;_data.writeInterfaceToken(DESCRIPTOR);_data.writeInt(x);_data.writeInt(y);mRemote.transact(Stub.TRANSACTION_min, _data, _reply, 0);_reply.readException();_result = _reply.readInt();&#125;finally &#123;_reply.recycle();_data.recycle();&#125;return _result;&#125;&#125;static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);static final int TRANSACTION_min = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);&#125;public int add(int x, int y) throws android.os.RemoteException;public int min(int x, int y) throws android.os.RemoteException;&#125; 新建一个Service 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.example.taidl;import android.app.Service;import android.content.Intent;import android.os.IBinder;import android.os.RemoteException;import android.util.Log;public class CalcService extends Service&#123; private static final String TAG = "server"; public void onCreate() &#123; Log.e(TAG, "onCreate"); &#125; public IBinder onBind(Intent t) &#123; Log.e(TAG, "onBind"); return mBinder; &#125; public void onDestroy() &#123; Log.e(TAG, "onDestroy"); super.onDestroy(); &#125; public boolean onUnbind(Intent intent) &#123; Log.e(TAG, "onUnbind"); return super.onUnbind(intent); &#125; public void onRebind(Intent intent) &#123; Log.e(TAG, "onRebind"); super.onRebind(intent); &#125; private final ICalcAIDL.Stub mBinder = new ICalcAIDL.Stub() &#123; @Override public int min(int x, int y) throws RemoteException &#123; return x + y; &#125; @Override public int add(int x, int y) throws RemoteException &#123; // TODO Auto-generated method stub return x - y; &#125; &#125;; &#125; 创建了一个mBinder对象，并在Service的onBind方法中返回 注册： 1234567&lt;service android:name="com.example.taidl.CalcService"&gt; &lt;intent-filter&gt; &lt;action android:name="com.example.taidl.calc" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt; &lt;/service&gt; 我们一会会在别的应用程序中通过Intent来查找此Service；这个不需要Activity，所以我也就没写Activity，安装完成也看不到安装图标，悄悄在后台运行着。服务端编写完毕。下面开始编写客户端: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.example.tclient;import com.example.taidl.ICalcAIDL;import android.app.Activity;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.Bundle;import android.os.IBinder;import android.util.Log;import android.view.View;import android.widget.Toast;public class MainActivity extends Activity &#123; private ICalcAIDL mCalcAidl; private ServiceConnection mServiceConn = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.e("client", "onServiceDisconnected"); mCalcAidl = null; &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.e("client", "onServiceConnected"); mCalcAidl = ICalcAIDL.Stub.asInterface(service); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; /** * 点击BindService按钮时调用 * @param view */ public void bindService(View view) &#123; Intent intent = new Intent(); intent.setAction("com.example.taidl.calc"); bindService(intent, mServiceConn, Context.BIND_AUTO_CREATE); &#125; /** * 点击unBindService按钮时调用 * @param view */ public void unbindService(View view) &#123; unbindService(mServiceConn); &#125; /** * 点击12+12按钮时调用 * @param view */ public void addInvoked(View view) throws Exception &#123; if (mCalcAidl != null) &#123; int addRes = mCalcAidl.add(12, 12); Toast.makeText(this, addRes + "", Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(this, "服务器被异常杀死，请重新绑定服务端", Toast.LENGTH_SHORT) .show(); &#125; &#125; /** * 点击50-12按钮时调用 * @param view */ public void minInvoked(View view) throws Exception &#123; if (mCalcAidl != null) &#123; int addRes = mCalcAidl.min(50, 12); Toast.makeText(this, addRes + "", Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(this, "服务器未绑定或被异常杀死，请重新绑定服务端", Toast.LENGTH_SHORT) .show(); &#125; &#125;&#125; 将服务端的aidl文件完整的复制过来，包名一定要一致。 分析AIDL生成的代码 服务端 12345678910111213141516private final ICalcAIDL.Stub mBinder = new ICalcAIDL.Stub() &#123; @Override public int add(int x, int y) throws RemoteException &#123; return x + y; &#125; @Override public int min(int x, int y) throws RemoteException &#123; return x - y; &#125; &#125;; ICalcAILD.Stub来执行的，让我们来看看Stub这个类的声明： 1public static abstract class Stub extends android.os.Binder implements com.zhy.calc.aidl.ICalcAIDL 清楚的看到这个类是Binder的子类，是不是符合我们文章开通所说的服务端其实是一个Binder类的实例接下来看它的onTransact()方法： 123456789101112131415161718192021222324252627282930313233343536@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_add: &#123; data.enforceInterface(DESCRIPTOR); int _arg0; _arg0 = data.readInt(); int _arg1; _arg1 = data.readInt(); int _result = this.add(_arg0, _arg1); reply.writeNoException(); reply.writeInt(_result); return true; &#125; case TRANSACTION_min: &#123; data.enforceInterface(DESCRIPTOR); int _arg0; _arg0 = data.readInt(); int _arg1; _arg1 = data.readInt(); int _result = this.min(_arg0, _arg1); reply.writeNoException(); reply.writeInt(_result); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; 文章开头也说到服务端的Binder实例会根据客户端依靠Binder驱动发来的消息，执行onTransact方法，然后由其参数决定执行服务端的代码。可以看到onTransact有四个参数code ， data ，replay ， flags code 是一个整形的唯一标识，用于区分执行哪个方法，客户端会传递此参数，告诉服务端执行哪个方法 data客户端传递过来的参数 replay服务器返回回去的值 flags标明是否有返回值，0为有（双向），1为没有（单向） 我们仔细看case TRANSACTION_min中的代码 data.enforceInterface(DESCRIPTOR); 与客户端的writeInterfaceToken对用，标识远程服务的名称 1234int _arg0;_arg0 = data.readInt();int _arg1;_arg1 = data.readInt(); 接下来分别读取了客户端传入的两个参数 123int _result = this.min(_arg0, _arg1);reply.writeNoException();reply.writeInt(_result); 然后执行this.min，即我们实现的min方法；返回result由reply写回。 add同理，可以看到服务端通过AIDL生成Stub的类，封装了服务端本来需要写的代码。 客户端客户端主要通过ServiceConnected与服务端连接 12345678910111213141516private ServiceConnection mServiceConn = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.e("client", "onServiceDisconnected"); mCalcAidl = null; &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.e("client", "onServiceConnected"); mCalcAidl = ICalcAIDL.Stub.asInterface(service); &#125; &#125;; 如果你比较敏锐，应该会猜到这个onServiceConnected中的IBinder实例，其实就是我们文章开通所说的Binder驱动，也是一个Binder实例在ICalcAIDL.Stub.asInterface中最终调用了： 1return new com.zhy.calc.aidl.ICalcAIDL.Stub.Proxy(obj); 这个Proxy实例传入了我们的Binder驱动，并且封装了我们调用服务端的代码，文章开头说，客户端会通过Binder驱动的transact()方法调用服务端代码 直接看Proxy中的add方法 12345678910111213141516171819@Override public int add(int x, int y) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); int _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeInt(x); _data.writeInt(y); mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; 首先声明两个Parcel对象，一个用于传递数据，一个用户接收返回的数据 1234_data.writeInterfaceToken(DESCRIPTOR);与服务器端的enforceInterfac对应_data.writeInt(x);_data.writeInt(y);写入需要传递的参数mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0); 终于看到了我们的transact方法，第一个对应服务端的code,_data,_repay分别对应服务端的data，reply，0表示是双向的 12_reply.readException();_result = _reply.readInt(); 最后读出我们服务端返回的数据，然后return。可以看到和服务端的onTransact基本是一行一行对应的。 我们已经通过AIDL生成的代码解释了Android Binder框架的工作原理。Service的作用其实就是为我们创建Binder驱动，即服务端与客户端连接的桥梁。]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Activity启动过程]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FActivity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%85%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Activity启动过程 一些基本的概念 ActivityManagerServices，简称AMS，服务端对象，负责系统中所有Activity的生命周期 ActivityThread，App的真正入口。当开启App之后，会调用main()开始运行，开启消息循环队列，这就是传说中的UI线程或者叫主线程。与ActivityManagerServices配合，一起完成Activity的管理工作 ApplicationThread，用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通讯。 ApplicationThreadProxy，是ApplicationThread在服务器端的代理，负责和客户端的ApplicationThread通讯。AMS就是通过该代理与ActivityThread进行通信的。 Instrumentation，每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作。 ActivityStack，Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。 ActivityRecord，ActivityStack的管理对象，每个Activity在AMS对应一个* ActivityRecord，来记录Activity的状态以及其他的管理信息。其实就是服务器端的Activity对象的映像。 TaskRecord，AMS抽象出来的一个“任务”的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。如果你清楚Activity的4种launchMode，那么对这个概念应该不陌生。 回答一些问题zygote是什么？有什么作用？ zygote意为“受精卵“。Android是基于Linux系统的，而在Linux中，所有的进程都是由init进程直接或者是间接fork出来的，zygote进程也不例外。 在Android系统里面，zygote是一个进程的名字。Android是基于Linux System的，当你的手机开机的时候，Linux的内核加载完成之后就会启动一个叫“init“的进程。在Linux System里面，所有的进程都是由init进程fork出来的，我们的zygote进程也不例外。 我们都知道，每一个App其实都是 一个单独的dalvik虚拟机 一个单独的进程 所以当系统里面的第一个zygote进程运行之后，在这之后再开启App，就相当于开启一个新的进程。而为了实现资源共用和更快的启动速度，Android系统开启新进程的方式，是通过fork第一个zygote进程实现的。所以说，除了第一个zygote进程，其他应用所在的进程都是zygote的子进程，这下你明白为什么这个进程叫“受精卵”了吧？因为就像是一个受精卵一样，它能快速的分裂，并且产生遗传物质一样的细胞！ SystemServer是什么？有什么作用？它与zygote的关系是什么？ 首先我要告诉你的是，SystemServer也是一个进程，而且是由zygote进程fork出来的。 知道了SystemServer的本质，我们对它就不算太陌生了，这个进程是Android Framework里面两大非常重要的进程之一——另外一个进程就是上面的zygote进程。 为什么说SystemServer非常重要呢？因为系统里面重要的服务都是在这个进程里面开启的，比如ActivityManagerService、PackageManagerService、WindowManagerService等等，看着是不是都挺眼熟的？ 那么这些系统服务是怎么开启起来的呢？ 在zygote开启的时候，会调用ZygoteInit.main()进行初始化 12345678910111213141516171819202122232425262728public static void main(String argv[]) &#123; ...ignore some code... //在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true boolean startSystemServer = false; for (int i = 1; i &lt; argv.length; i++) &#123; if ("start-system-server".equals(argv[i])) &#123; startSystemServer = true; &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123; abiList = argv[i].substring(ABI_LIST_ARG.length()); &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123; socketName = argv[i].substring(SOCKET_NAME_ARG.length()); &#125; else &#123; throw new RuntimeException("Unknown command line argument: " + argv[i]); &#125; &#125; ...ignore some code... //开始fork我们的SystemServer进程 if (startSystemServer) &#123; startSystemServer(abiList, socketName); &#125; ...ignore some code...&#125; 我们看下startSystemServer()做了些什么 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/**留着这个注释，就是为了说明SystemServer确实是被fork出来的 * Prepare the arguments and fork for the system server process. */private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException &#123; ...ignore some code... //留着这段注释，就是为了说明上面ZygoteInit.main(String argv[])里面的argv就是通过这种方式传递进来的 /* Hardcoded command line to start the system server */ String args[] = &#123; "--setuid=1000", "--setgid=1000", "--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007", "--capabilities=" + capabilities + "," + capabilities, "--runtime-init", "--nice-name=system_server", "com.android.server.SystemServer", &#125;; int pid; try &#123; parsedArgs = new ZygoteConnection.Arguments(args); ZygoteConnection.applyDebuggerSystemProperty(parsedArgs); ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs); //确实是fuck出来的吧，我没骗你吧~不对，是fork出来的 -_-||| /* Request to fork the system server process */ pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; /* For child process */ if (pid == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; handleSystemServerProcess(parsedArgs); &#125; return true;&#125; ActivityManagerService是什么？什么时候初始化的？有什么作用？ ActivityManagerService，简称AMS，服务端对象，负责系统中所有Activity的生命周期。 ActivityManagerService进行初始化的时机很明确，就是在SystemServer进程开启的时候，就会初始化ActivityManagerService。从下面的代码中可以看到 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public final class SystemServer &#123; //zygote的主入口 public static void main(String[] args) &#123; new SystemServer().run(); &#125; public SystemServer() &#123; // Check for factory test mode. mFactoryTestMode = FactoryTest.getMode(); &#125; private void run() &#123; ...ignore some code... //加载本地系统服务库，并进行初始化 System.loadLibrary("android_servers"); nativeInit(); // 创建系统上下文 createSystemContext(); //初始化SystemServiceManager对象，下面的系统服务开启都需要调用SystemServiceManager.startService(Class&lt;T&gt;)，这个方法通过反射来启动对应的服务 mSystemServiceManager = new SystemServiceManager(mSystemContext); //开启服务 try &#123; startBootstrapServices(); startCoreServices(); startOtherServices(); &#125; catch (Throwable ex) &#123; Slog.e("System", "******************************************"); Slog.e("System", "************ Failure starting system services", ex); throw ex; &#125; ...ignore some code... &#125; //初始化系统上下文对象mSystemContext，并设置默认的主题,mSystemContext实际上是一个ContextImpl对象。调用ActivityThread.systemMain()的时候，会调用ActivityThread.attach(true)，而在attach()里面，则创建了Application对象，并调用了Application.onCreate()。 private void createSystemContext() &#123; ActivityThread activityThread = ActivityThread.systemMain(); mSystemContext = activityThread.getSystemContext(); mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar); &#125; //在这里开启了几个核心的服务，因为这些服务之间相互依赖，所以都放在了这个方法里面。 private void startBootstrapServices() &#123; ...ignore some code... //初始化ActivityManagerService mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); //初始化PowerManagerService，因为其他服务需要依赖这个Service，因此需要尽快的初始化 mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); // 现在电源管理已经开启，ActivityManagerService负责电源管理功能 mActivityManagerService.initPowerManagement(); // 初始化DisplayManagerService mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class); //初始化PackageManagerService mPackageManagerService = PackageManagerService.main(mSystemContext, mInstaller, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); ...ignore some code... &#125;&#125; 经过上面这些步骤，我们的ActivityManagerService对象已经创建好了，并且完成了成员变量初始化。而且在这之前，调用createSystemContext()创建系统上下文的时候，也已经完成了mSystemContext和ActivityThread的创建。注意，这是系统进程开启时的流程，在这之后，会开启系统的Launcher程序，完成系统界面的加载与显示。 你是否会好奇，我为什么说AMS是服务端对象？下面我给你介绍下Android系统里面的服务器和客户端的概念。 其实服务器客户端的概念不仅仅存在于Web开发中，在Android的框架设计中，使用的也是这一种模式。服务器端指的就是所有App共用的系统服务，比如我们这里提到的ActivityManagerService，和前面提到的PackageManagerService、WindowManagerService等等，这些基础的系统服务是被所有的App公用的，当某个App想实现某个操作的时候，要告诉这些系统服务，比如你想打开一个App，那么我们知道了包名和MainActivity类名之后就可以打开 12345Intent intent = new Intent(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_LAUNCHER); ComponentName cn = new ComponentName(packageName, className); intent.setComponent(cn); startActivity(intent); 但是，我们的App通过调用startActivity()并不能直接打开另外一个App，这个方法会通过一系列的调用，最后还是告诉AMS说：“我要打开这个App，我知道他的住址和名字，你帮我打开吧！”所以是AMS来通知zygote进程来fork一个新进程，来开启我们的目标App的。这就像是浏览器想要打开一个超链接一样，浏览器把网页地址发送给服务器，然后还是服务器把需要的资源文件发送给客户端的。 知道了Android Framework的客户端服务器架构之后，我们还需要了解一件事情，那就是我们的App和AMS(SystemServer进程)还有zygote进程分属于三个独立的进程，他们之间如何通信呢？ 知道了Android Framework的客户端服务器架构之后，我们还需要了解一件事情，那就是我们的App和AMS(SystemServer进程)还有zygote进程分属于三个独立的进程，他们之间如何通信呢？ App与AMS通过Binder进行IPC通信，AMS(SystemServer进程)与zygote通过Socket进行IPC通信。 那么AMS有什么用呢？在前面我们知道了，如果想打开一个App的话，需要AMS去通知zygote进程，除此之外，其实所有的Activity的开启、暂停、关闭都需要AMS来控制，所以我们说，AMS负责系统中所有Activity的生命周期。 在Android系统中，任何一个Activity的启动都是由AMS和应用程序进程（主要是ActivityThread）相互配合来完成的。AMS服务统一调度系统中所有进程的Activity启动，而每个Activity的启动过程则由其所属的进程具体来完成。 这样说你可能还是觉得比较抽象，没关系，下面有一部分是专门来介绍AMS与ActivityThread如何一起合作控制Activity的生命周期的。 Launcher是什么？什么时候启动的？ 当我们点击手机桌面上的图标的时候，App就由Launcher开始启动了。但是，你有没有思考过Launcher到底是一个什么东西？ Launcher本质上也是一个应用程序，和我们的App一样，也是继承自Activity packages/apps/Launcher2/src/com/android/launcher2/Launcher.java 1234public final class Launcher extends Activity implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks, View.OnTouchListener &#123; &#125; Launcher实现了点击、长按等回调接口，来接收用户的输入。既然是普通的App，那么我们的开发经验在这里就仍然适用，比如，我们点击图标的时候，是怎么开启的应用呢？如果让你，你怎么做这个功能呢？捕捉图标点击事件，然后startActivity()发送对应的Intent请求呗！是的，Launcher也是这么做的，就是这么easy！ 那么到底是处理的哪个对象的点击事件呢？既然Launcher是App，并且有界面，那么肯定有布局文件呀，是的，我找到了布局文件launcher.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:launcher="http://schemas.android.com/apk/res/com.android.launcher" android:id="@+id/launcher"&gt; &lt;com.android.launcher2.DragLayer android:id="@+id/drag_layer" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true"&gt; &lt;!-- Keep these behind the workspace so that they are not visible when we go into AllApps --&gt; &lt;include android:id="@+id/dock_divider" layout="@layout/workspace_divider" android:layout_marginBottom="@dimen/button_bar_height" android:layout_gravity="bottom" /&gt; &lt;include android:id="@+id/paged_view_indicator" layout="@layout/scroll_indicator" android:layout_gravity="bottom" android:layout_marginBottom="@dimen/button_bar_height" /&gt; &lt;!-- The workspace contains 5 screens of cells --&gt; &lt;com.android.launcher2.Workspace android:id="@+id/workspace" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingStart="@dimen/workspace_left_padding" android:paddingEnd="@dimen/workspace_right_padding" android:paddingTop="@dimen/workspace_top_padding" android:paddingBottom="@dimen/workspace_bottom_padding" launcher:defaultScreen="2" launcher:cellCountX="@integer/cell_count_x" launcher:cellCountY="@integer/cell_count_y" launcher:pageSpacing="@dimen/workspace_page_spacing" launcher:scrollIndicatorPaddingLeft="@dimen/workspace_divider_padding_left" launcher:scrollIndicatorPaddingRight="@dimen/workspace_divider_padding_right"&gt; &lt;include android:id="@+id/cell1" layout="@layout/workspace_screen" /&gt; &lt;include android:id="@+id/cell2" layout="@layout/workspace_screen" /&gt; &lt;include android:id="@+id/cell3" layout="@layout/workspace_screen" /&gt; &lt;include android:id="@+id/cell4" layout="@layout/workspace_screen" /&gt; &lt;include android:id="@+id/cell5" layout="@layout/workspace_screen" /&gt; &lt;/com.android.launcher2.Workspace&gt; ...ignore some code... &lt;/com.android.launcher2.DragLayer&gt;&lt;/FrameLayout&gt; 为了方便查看，我删除了很多代码，从上面这些我们应该可以看出一些东西来：Launcher大量使用标签来实现界面的复用，而且定义了很多的自定义控件实现界面效果，dock_divider从布局的参数声明上可以猜出，是底部操作栏和上面图标布局的分割线，而paged_view_indicator则是页面指示器，和App首次进入的引导页下面的界面引导是一样的道理。当然，我们最关心的是Workspace这个布局，因为注释里面说在这里面包含了5个屏幕的单元格，想必你也猜到了，这个就是在首页存放我们图标的那五个界面(不同的ROM会做不同的DIY，数量不固定)。 接下来，我们应该打开workspace_screen布局，看看里面有什么东东。 workspace_screen.xml 123456789101112131415&lt;com.android.launcher2.CellLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:launcher="http://schemas.android.com/apk/res/com.android.launcher" android:layout_width="wrap_content" android:layout_height="wrap_content" android:paddingStart="@dimen/cell_layout_left_padding" android:paddingEnd="@dimen/cell_layout_right_padding" android:paddingTop="@dimen/cell_layout_top_padding" android:paddingBottom="@dimen/cell_layout_bottom_padding" android:hapticFeedbackEnabled="false" launcher:cellWidth="@dimen/workspace_cell_width" launcher:cellHeight="@dimen/workspace_cell_height" launcher:widthGap="@dimen/workspace_width_gap" launcher:heightGap="@dimen/workspace_height_gap" launcher:maxGap="@dimen/workspace_max_gap" /&gt; 里面就一个CellLayout，也是一个自定义布局，那么我们就可以猜到了，既然可以存放图标，那么这个自定义的布局很有可能是继承自ViewGroup或者是其子类，实际上，CellLayout确实是继承自ViewGroup。在CellLayout里面，只放了一个子View，那就是ShortcutAndWidgetContainer。从名字也可以看出来，ShortcutAndWidgetContainer这个类就是用来存放快捷图标和Widget小部件的，那么里面放的是什么对象呢？ 在桌面上的图标，使用的是BubbleTextView对象，这个对象在TextView的基础之上，添加了一些特效，比如你长按移动图标的时候，图标位置会出现一个背景(不同版本的效果不同)，所以我们找到BubbleTextView对象的点击事件，就可以找到Launcher如何开启一个App了。 除了在桌面上有图标之外，在程序列表中点击图标，也可以开启对应的程序。这里的图标使用的不是BubbleTextView对象，而是PagedViewIcon对象，我们如果找到它的点击事件，就也可以找到Launcher如何开启一个App。 其实说这么多，和今天的主题隔着十万八千里，上面这些东西，你有兴趣就看，没兴趣就直接跳过，不知道不影响这篇文章阅读。 BubbleTextView的点击事件在哪里呢？我来告诉你：在Launcher.onClick(View v)里面。 1234567891011121314151617181920212223242526272829303132/** * Launches the intent referred by the clicked shortcut */ public void onClick(View v) &#123; ...ignore some code... Object tag = v.getTag(); if (tag instanceof ShortcutInfo) &#123; // Open shortcut final Intent intent = ((ShortcutInfo) tag).intent; int[] pos = new int[2]; v.getLocationOnScreen(pos); intent.setSourceBounds(new Rect(pos[0], pos[1], pos[0] + v.getWidth(), pos[1] + v.getHeight())); //开始开启Activity咯~ boolean success = startActivitySafely(v, intent, tag); if (success &amp;&amp; v instanceof BubbleTextView) &#123; mWaitingForResume = (BubbleTextView) v; mWaitingForResume.setStayPressed(true); &#125; &#125; else if (tag instanceof FolderInfo) &#123; //如果点击的是图标文件夹，就打开文件夹 if (v instanceof FolderIcon) &#123; FolderIcon fi = (FolderIcon) v; handleFolderClick(fi); &#125; &#125; else if (v == mAllAppsButton) &#123; ...ignore some code... &#125; &#125; 从上面的代码我们可以看到，在桌面上点击快捷图标的时候，会调用 1startActivitySafely(v, intent, tag); 那么从程序列表界面，点击图标的时候会发生什么呢？实际上，程序列表界面使用的是AppsCustomizePagedView对象，所以我在这个类里面找到了onClick(View v)。 com.android.launcher2.AppsCustomizePagedView.java 123456789101112131415161718192021/** * The Apps/Customize page that displays all the applications, widgets, and shortcuts. */public class AppsCustomizePagedView extends PagedViewWithDraggableItems implements View.OnClickListener, View.OnKeyListener, DragSource, PagedViewIcon.PressedCallback, PagedViewWidget.ShortPressListener, LauncherTransitionable &#123; @Override public void onClick(View v) &#123; ...ignore some code... if (v instanceof PagedViewIcon) &#123; mLauncher.updateWallpaperVisibility(true); mLauncher.startActivitySafely(v, appInfo.intent, appInfo); &#125; else if (v instanceof PagedViewWidget) &#123; ...ignore some code.. &#125; &#125; &#125; 可以看到，调用的是 1mLauncher.startActivitySafely(v, appInfo.intent, appInfo); 殊途同归 不管从哪里点击图标，调用的都是Launcher.startActivitySafely()。 下面我们就可以一步步的来看一下Launcher.startActivitySafely()到底做了什么事情。 12345678910boolean startActivitySafely(View v, Intent intent, Object tag) &#123; boolean success = false; try &#123; success = startActivity(v, intent, tag); &#125; catch (ActivityNotFoundException e) &#123; Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show(); Log.e(TAG, "Unable to launch. tag=" + tag + " intent=" + intent, e); &#125; return success; &#125; 调用了startActivity(v, intent, tag) 1234567891011121314151617181920212223242526272829boolean startActivity(View v, Intent intent, Object tag) &#123; intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); try &#123; boolean useLaunchAnimation = (v != null) &amp;&amp; !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION); if (useLaunchAnimation) &#123; if (user == null || user.equals(android.os.Process.myUserHandle())) &#123; startActivity(intent, opts.toBundle()); &#125; else &#123; launcherApps.startMainActivity(intent.getComponent(), user, intent.getSourceBounds(), opts.toBundle()); &#125; &#125; else &#123; if (user == null || user.equals(android.os.Process.myUserHandle())) &#123; startActivity(intent); &#125; else &#123; launcherApps.startMainActivity(intent.getComponent(), user, intent.getSourceBounds(), null); &#125; &#125; return true; &#125; catch (SecurityException e) &#123; ... &#125; return false; &#125; 这里会调用Activity.startActivity(intent, opts.toBundle())，这个方法熟悉吗？这就是我们经常用到的Activity.startActivity(Intent)的重载函数。而且由于设置了 1intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 所以这个Activity会添加到一个新的Task栈中，而且，startActivity()调用的其实是startActivityForResult()这个方法。 12345678910@Override public void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125; &#125; 所以我们现在明确了，Launcher中开启一个App，其实和我们在Activity中直接startActivity()基本一样，都是调用了Activity.startActivityForResult()。 Instrumentation是什么？和ActivityThread是什么关系？ 还记得前面说过的Instrumentation对象吗？每个Activity都持有Instrumentation对象的一个引用，但是整个进程只会存在一个Instrumentation对象。当startActivityForResult()调用之后，实际上还是调用了mInstrumentation.execStartActivity() 12345678910111213141516171819202122public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; ...ignore some code... &#125; else &#123; if (options != null) &#123; //当现在的Activity有父Activity的时候会调用，但是在startActivityFromChild()内部实际还是调用的mInstrumentation.execStartActivity() mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125; ...ignore some code... &#125; 下面是mInstrumentation.execStartActivity()的实现 123456789101112131415161718public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; ...ignore some code... try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; &#125; return null; &#125; 所以当我们在程序中调用startActivity()的 时候，实际上调用的是Instrumentation的相关的方法。 Instrumentation意为“仪器”，我们先看一下这个类里面包含哪些方法吧 我们可以看到，这个类里面的方法大多数和Application和Activity有关，是的，这个类就是完成对Application和Activity初始化和生命周期的工具类。比如说，我单独挑一个callActivityOnCreate()让你看看 12345public void callActivityOnCreate(Activity activity, Bundle icicle) &#123; prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity); &#125; 对activity.performCreate(icicle);这一行代码熟悉吗？这一行里面就调用了传说中的Activity的入口函数onCreate()，不信？接着往下看 Activity.performCreate() 12345final void performCreate(Bundle icicle) &#123; onCreate(icicle); mActivityTransitionState.readState(icicle); performCreateCommon(); &#125; 没骗你吧，onCreate在这里调用了吧。但是有一件事情必须说清楚，那就是这个Instrumentation类这么重要，为啥我在开发的过程中，没有发现他的踪迹呢？ 是的，Instrumentation这个类很重要，对Activity生命周期方法的调用根本就离不开他，他可以说是一个大管家，但是，这个大管家比较害羞，是一个女的，管内不管外，是老板娘~ 那么你可能要问了，老板是谁呀？老板当然是大名鼎鼎的ActivityThread了！ ActivityThread你都没听说过？那你肯定听说过传说中的UI线程吧？是的，这就是UI线程。我们前面说过，App和AMS是通过Binder传递信息的，那么ActivityThread就是专门与AMS的外交工作的。 AMS说：“ActivityThread，你给我暂停一个Activity！”ActivityThread就说：“没问题！”然后转身和Instrumentation说：“老婆，AMS让暂停一个Activity，我这里忙着呢，你快去帮我把这事办了把~”于是，Instrumentation就去把事儿搞定了。 所以说，AMS是董事会，负责指挥和调度的，ActivityThread是老板，虽然说家里的事自己说了算，但是需要听从AMS的指挥，而Instrumentation则是老板娘，负责家里的大事小事，但是一般不抛头露面，听一家之主ActivityThread的安排。 如何理解AMS和ActivityThread之间的Binder通信？ 前面我们说到，在调用startActivity()的时候，实际上调用的是 1mInstrumentation.execStartActivity() 但是到这里还没完呢！里面又调用了下面的方法 12ActivityManagerNative.getDefault() .startActivity]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android关于OOM的解决方案]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FAndroid%E5%85%B3%E4%BA%8Eoom%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[Android关于OOM的解决方案OOM 内存溢出（Out Of Memory） 也就是说内存占有量超过了VM所分配的最大 出现OOM的原因 加载对象过大 相应资源过多，来不及释放 如何解决 在内存引用上做些处理，常用的有软引用、强化引用、弱引用 在内存中加载图片时直接在内存中作处理，如边界压缩 动态回收内存 优化Dalvik虚拟机的堆内存分配 自定义堆内存大小]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android图片中的三级缓存]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FAndroid%E5%9B%BE%E7%89%87%E4%B8%AD%E7%9A%84%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[Android图片中的三级缓存 为什么要使用三级缓存 如今的 Android App 经常会需要网络交互，通过网络获取图片是再正常不过的事了 假如每次启动的时候都从网络拉取图片的话，势必会消耗很多流量。在当前的状况下，对于非wifi用户来说，流量还是很贵的，一个很耗流量的应用，其用户数量级肯定要受到影响 特别是，当我们想要重复浏览一些图片时，如果每一次浏览都需要通过网络获取，流量的浪费可想而知 所以提出三级缓存策略，通过网络、本地、内存三级缓存图片，来减少不必要的网络交互，避免浪费流量 什么是三级缓存 网络加载，不优先加载，速度慢，浪费流量 本地缓存，次优先加载，速度快 内存缓存，优先加载，速度最快 三级缓存原理 首次加载 Android App 时，肯定要通过网络交互来获取图片，之后我们可以将图片保存至本地SD卡和内存中 之后运行 App 时，优先访问内存中的图片缓存，若内存中没有，则加载本地SD卡中的图片 总之，只在初次访问新内容时，才通过网络获取图片资源 参考链接 http://www.jianshu.com/p/2cd59a79ed4a]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android开机过程]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FAndroid%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Android开机过程 BootLoder引导,然后加载Linux内核. 0号进程init启动.加载init.rc配置文件,配置文件有个命令启动了zygote进程 zygote开始fork出SystemServer进程 SystemServer加载各种JNI库,然后init1,init2方法,init2方法中开启了新线程ServerThread. 在SystemServer中会创建一个socket客户端，后续AMS（ActivityManagerService）会通过此客户端和zygote通信 ServerThread的run方法中开启了AMS,还孵化新进程ServiceManager,加载注册了一溜的服务,最后一句话进入loop 死循环 run方法的SystemReady调用resumeTopActivityLocked打开锁屏界面]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android性能优化]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Android性能优化 合理管理内存 节制的使用Service如果应用程序需要使用Service来执行后台任务的话，只有当任务正在执行的时候才应该让Service运行起来。当启动一个Service时，系统会倾向于将这个Service所依赖的进程进行保留，系统可以在LRUcache当中缓存的进程数量也会减少，导致切换程序的时候耗费更多性能。我们可以使用IntentService，当后台任务执行结束后会自动停止，避免了Service的内存泄漏。 当界面不可见时释放内存当用户打开了另外一个程序，我们的程序界面已经不可见的时候，我们应当将所有和界面相关的资源进行释放。重写Activity的onTrimMemory()方法，然后在这个方法中监听TRIM_MEMORY_UI_HIDDEN这个级别，一旦触发说明用户离开了程序，此时就可以进行资源释放操作了。 当内存紧张时释放内存onTrimMemory()方法还有很多种其他类型的回调，可以在手机内存降低的时候及时通知我们，我们应该根据回调中传入的级别来去决定如何释放应用程序的资源。 避免在Bitmap上浪费内存读取一个Bitmap图片的时候，千万不要去加载不需要的分辨率。可以压缩图片等操作。 是有优化过的数据集合Android提供了一系列优化过后的数据集合工具类，如SparseArray、SparseBooleanArray、LongSparseArray，使用这些API可以让我们的程序更加高效。HashMap工具类会相对比较低效，因为它需要为每一个键值对都提供一个对象入口，而SparseArray就避免掉了基本数据类型转换成对象数据类型的时间。 知晓内存的开支情况 使用枚举通常会比使用静态常量消耗两倍以上的内存，尽可能不使用枚举 任何一个Java类，包括匿名类、内部类，都要占用大概500字节的内存空间 任何一个类的实例要消耗12-16字节的内存开支，因此频繁创建实例也是会在一定程序上影响内存的 使用HashMap时，即使你只设置了一个基本数据类型的键，比如说int，但是也会按照对象的大小来分配内存，大概是32字节，而不是4字节，因此最好使用优化后的数据集合 谨慎使用抽象编程在Android使用抽象编程会带来额外的内存开支，因为抽象的编程方法需要编写额外的代码，虽然这些代码根本执行不到，但是也要映射到内存中，不仅占用了更多的内存，在执行效率上也会有所降低。所以需要合理的使用抽象编程。 尽量避免使用依赖注入框架使用依赖注入框架貌似看上去把findViewById()这一类的繁琐操作去掉了，但是这些框架为了要搜寻代码中的注解，通常都需要经历较长的初始化过程，并且将一些你用不到的对象也一并加载到内存中。这些用不到的对象会一直站用着内存空间，可能很久之后才会得到释放，所以可能多敲几行代码是更好的选择。 使用多个进程谨慎使用，多数应用程序不该在多个进程中运行的，一旦使用不当，它甚至会增加额外的内存而不是帮我们节省内存。这个技巧比较适用于哪些需要在后台去完成一项独立的任务，和前台是完全可以区分开的场景。比如音乐播放，关闭软件，已经完全由Service来控制音乐播放了，系统仍然会将许多UI方面的内存进行保留。在这种场景下就非常适合使用两个进程，一个用于UI展示，另一个用于在后台持续的播放音乐。关于实现多进程，只需要在Manifast文件的应用程序组件声明一个android:process属性就可以了。进程名可以自定义，但是之前要加个冒号，表示该进程是一个当前应用程序的私有进程。 分析内存的使用情况 系统不可能将所有的内存都分配给我们的应用程序，每个程序都会有可使用的内存上限，被称为堆大小。不同的手机堆大小不同，如下代码可以获得堆大小： 12ActivityManager manager = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);int heapSize = manager.getMemoryClass(); 结果以MB为单位进行返回，我们开发时应用程序的内存不能超过这个限制，否则会出现OOM。 Android的GC操作Android系统会在适当的时机触发GC操作，一旦进行GC操作，就会将一些不再使用的对象进行回收。GC操作会从一个叫做Roots的对象开始检查，所有它可以访问到的对象就说明还在使用当中，应该进行保留，而其他的对系那个就表示已经不再被使用了。 Android中内存泄漏Android中的垃圾回收机制并不能防止内存泄漏的出现导致内存泄漏最主要的原因就是某些长存对象持有了一些其它应该被回收的对象的引用，导致垃圾回收器无法去回收掉这些对象，也就是出现内存泄漏了。比如说像Activity这样的系统组件，它又会包含很多的控件甚至是图片，如果它无法被垃圾回收器回收掉的话，那就算是比较严重的内存泄漏情况了。举个例子，在MainActivity中定义一个内部类，实例化内部类对象，在内部类新建一个线程执行死循环，会导致内部类资源无法释放，MainActivity的控件和资源无法释放，导致OOM,可借助一系列工具，比如LeakCanary。 高性能编码优化 都是一些微优化，在性能方面看不出有什么显著的提升的。使用合适的算法和数据结构是优化程序性能的最主要手段。 避免创建不必要的对象不必要的对象我们应该避免创建： 如果有需要拼接的字符串，那么可以优先考虑使用StringBuffer或者StringBuilder来进行拼接，而不是加号连接符，因为使用加号连接符会创建多余的对象，拼接的字符串越长，加号连接符的性能越低。 在没有特殊原因的情况下，尽量使用基本数据类型来代替封装数据类型，int比Integer要更加有效，其它数据类型也是一样。 当一个方法的返回值是String的时候，通常需要去判断一下这个String的作用是什么，如果明确知道调用方会将返回的String再进行拼接操作的话，可以考虑返回一个StringBuffer对象来代替，因为这样可以将一个对象的引用进行返回，而返回String的话就是创建了一个短生命周期的临时对象。 基本数据类型的数组也要优于对象数据类型的数组。另外两个平行的数组要比一个封装好的对象数组更加高效，举个例子，Foo[]和Bar[]这样的数组，使用起来要比Custom(Foo,Bar)[]这样的一个数组高效的多。 尽可能地少创建临时对象，越少的对象意味着越少的GC操作。 静态优于抽象如果你并不需要访问一个对系那个中的某些字段，只是想调用它的某些方法来去完成一项通用的功能，那么可以将这个方法设置成静态方法，调用速度提升15%-20%，同时也不用为了调用这个方法去专门创建对象了，也不用担心调用这个方法后是否会改变对象的状态(静态方法无法访问非静态字段)。 对常量使用static final修饰符12static int intVal = 42; static String strVal = "Hello, world!"; 编译器会为上面的代码生成一个初始方法，称为方法，该方法会在定义类第一次被使用的时候调用。这个方法会将42的值赋值到intVal当中，从字符串常量表中提取一个引用赋值到strVal上。当赋值完成后，我们就可以通过字段搜寻的方式去访问具体的值了。 final进行优化: 12static final int intVal = 42; static final String strVal = "Hello, world!"; 这样，定义类就不需要方法了，因为所有的常量都会在dex文件的初始化器当中进行初始化。当我们调用intVal时可以直接指向42的值，而调用strVal会用一种相对轻量级的字符串常量方式，而不是字段搜寻的方式。 这种优化方式只对基本数据类型以及String类型的常量有效，对于其他数据类型的常量是无效的。 使用增强型for循环语法12345678910111213141516171819202122232425262728static class Counter &#123; int mCount; &#125; Counter[] mArray = ... public void zero() &#123; int sum = 0; for (int i = 0; i &lt; mArray.length; ++i) &#123; sum += mArray[i].mCount; &#125; &#125; public void one() &#123; int sum = 0; Counter[] localArray = mArray; int len = localArray.length; for (int i = 0; i &lt; len; ++i) &#123; sum += localArray[i].mCount; &#125; &#125; public void two() &#123; int sum = 0; for (Counter a : mArray) &#123; sum += a.mCount; &#125; &#125; zero()最慢，每次都要计算mArray的长度，one()相对快得多，two()fangfa在没有JIT(Just In Time Compiler)的设备上是运行最快的，而在有JIT的设备上运行效率和one()方法不相上下，需要注意这种写法需要JDK1.5之后才支持。 Tips:ArrayList手写的循环比增强型for循环更快，其他的集合没有这种情况。因此默认情况下使用增强型for循环，而遍历ArrayList使用传统的循环方式。 多使用系统封装好的API系统提供不了的Api完成不了我们需要的功能才应该自己去写，因为使用系统的Api很多时候比我们自己写的代码要快得多，它们的很多功能都是通过底层的汇编模式执行的。举个例子，实现数组拷贝的功能，使用循环的方式来对数组中的每一个元素一一进行赋值当然可行，但是直接使用系统中提供的System.arraycopy()方法会让执行效率快9倍以上。 避免在内部调用Getters/Setters方法面向对象中封装的思想是不要把类内部的字段暴露给外部，而是提供特定的方法来允许外部操作相应类的内部字段。但在Android中，字段搜寻比方法调用效率高得多，我们直接访问某个字段可能要比通过getters方法来去访问这个字段快3到7倍。但是编写代码还是要按照面向对象思维的，我们应该在能优化的地方进行优化，比如避免在内部调用getters/setters方法。 布局优化技巧 重用布局文件 标签可以允许在一个布局当中引入另一个布局，那么比如说我们程序的所有界面都有一个公共的部分，这个时候最好的做法就是将这个公共的部分提取到一个独立的布局中，然后每个界面的布局文件当中来引用这个公共的布局。 Tips:如果我们要在标签中覆写layout属性，必须要将layout_width和layout_height这两个属性也进行覆写，否则覆写xiaoguo将不会生效。 标签是作为标签的一种辅助扩展来使用的，它的主要作用是为了防止在引用布局文件时引用文件时产生多余的布局嵌套。布局嵌套越多，解析起来就越耗时，性能就越差。因此编写布局文件时应该让嵌套的层数越少越好。 举例：比如在LinearLayout里边使用一个布局。里边又有一个LinearLayout，那么其实就存在了多余的布局嵌套，使用merge可以解决这个问题。 仅在需要时才加载布局某个布局当中的元素不是一起显示出来的，普通情况下只显示部分常用的元素，而那些不常用的元素只有在用户进行特定操作时才会显示出来。 举例：填信息时不是需要全部填的，有一个添加更多字段的选项，当用户需要添加其他信息的时候，才将另外的元素显示到界面上。用VISIBLE性能表现一般，可以用ViewStub。ViewStub也是View的一种，但是没有大小，没有绘制功能，也不参与布局，资源消耗非常低，可以认为完全不影响性能。 123456&lt;ViewStub android:id="@+id/view_stub" android:layout="@layout/profile_extra" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; 123456789public void onMoreClick() &#123; ViewStub viewStub = (ViewStub) findViewById(R.id.view_stub); if (viewStub != null) &#123; View inflatedView = viewStub.inflate(); editExtra1 = (EditText) inflatedView.findViewById(R.id.edit_extra1); editExtra2 = (EditText) inflatedView.findViewById(R.id.edit_extra2); editExtra3 = (EditText) inflatedView.findViewById(R.id.edit_extra3); &#125; &#125; tips：ViewStub所加载的布局是不可以使用标签的，因此这有可能导致加载出来出来的布局存在着多余的嵌套结构。]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android系统机制]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FAndroid%E7%B3%BB%E7%BB%9F%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Android系统机制 APP启动过程 Launcher线程捕获onclick的点击事件，调用Launcher.startActivitySafely，进一步调用Launcher.startActivity，最后调用父类Activity的startActivity。 Activity和ActivityManagerService交互，引入Instrumentation，将启动请求交给Instrumentation，调用Instrumentation.execStartActivity Android内核解读-应用的安装过程http://blog.csdn.net/singwhatiwanna/article/details/19578947apk的安装过程分为两步： 将apk文件复制到程序目录下(/data/app/) 为应用创建数据目录(/data/data/package name/)、提取dex文件到指定目录(/data/delvik-cache/)、修改系统包管理信息。 View的事件体系Handler消息机制AsyncTaskAyncTask是一个抽象类。 需要重写的方法有四个： onPreExecute() 这个方法会在后台任务开始之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等 doInBackGround(Params…) 在子线程中运行，不可更新UI，返回的是执行结果，第三个参数为Void不返回 onProgressUpdate(Progress…) 利用参数可以进行UI操作。 onPostExecute(Result) 返回的数据会作为参数传递到此方法中，可以利用返回的一些数据来进行一些UI操作。 1234567891011121314151617181920212223242526272829303132333435363738class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123; @Override protected void onPreExecute() &#123; progressDialog.show(); &#125; @Override protected Boolean doInBackground(Void... params) &#123; try &#123; while (true) &#123; int downloadPercent = doDownload(); publishProgress(downloadPercent); if (downloadPercent &gt;= 100) &#123; break; &#125; &#125; &#125; catch (Exception e) &#123; return false; &#125; return true; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; progressDialog.setMessage("当前下载进度：" + values[0] + "%"); &#125; @Override protected void onPostExecute(Boolean result) &#123; progressDialog.dismiss(); if (result) &#123; Toast.makeText(context, "下载成功", Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(context, "下载失败", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; 启动这个任务： 1new DownloadTask().execute(); 图片缓存机制]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AsyncTask]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FAsynctask%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[AsyncTask 首先从Android3.0开始，系统要求网络访问必须在子线程中进行，否则网络访问将会失败并抛出NetworkOnMainThreadException这个异常，这样做是为了避免主线程由于耗时操作所阻塞从而出现ANR现象。AsyncTask封装了线程池和Handler。AsyncTask有两个线程池：SerialExecutor和THREAD_POOL_EXECUTOR。前者是用于任务的排队，默认是串行的线程池：后者用于真正的执行任务。AsyncTask还有一个Handler，叫InternalHandler，用于将执行环境从线程池切换到主线程。AsyncTask内部就是通过InternalHandler来发送任务执行的进度以及执行结束等消息。 AsyncTask排队执行过程：系统先把参数Params封装为FutureTask对象，它相当于Runnable，接着FutureTask交给SerialExcutor的execute方法，它先把FutureTask插入到任务队列tasks中，如果这个时候没有正在活动的AsyncTask任务，那么就会执行下一个AsyncTask任务，同时当一个AsyncTask任务执行完毕之后，AsyncTask会继续执行其他任务直到所有任务都被执行为止。 关于线程池，AsyncTask对应的线程池ThreadPoolExecutor都是进程范围内共享的，都是static的，所以是AsyncTask控制着进程范围内所有的子类实例。由于这个限制的存在，当使用默认线程池时，如果线程数超过线程池的最大容量，线程池就会爆掉(3.0默认串行执行，不会出现这个问题)。针对这种情况。可以尝试自定义线程池，配合AsyncTask使用。]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ART和Dalvik区别]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FArt%E5%92%8CDalvik%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[ART和Dalvik区别 Art上应用启动快，运行快，但是耗费更多存储空间，安装时间长，总的来说ART的功效就是”空间换时间”。 ART: Ahead of Time Dalvik: Just in Time 什么是Dalvik：Dalvik是Google公司自己设计用于Android平台的Java虚拟机。Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一，它可以支持已转换为.dex(即Dalvik Executable)格式的Java应用程序的运行，.dex格式是专为Dalvik应用设计的一种压缩格式，适合内存和处理器速度有限的系统。Dalvik经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik应用作为独立的Linux进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。 什么是ART:Android操作系统已经成熟，Google的Android团队开始将注意力转向一些底层组件，其中之一是负责应用程序运行的Dalvik运行时。Google开发者已经花了两年时间开发更快执行效率更高更省电的替代ART运行时。ART代表Android Runtime,其处理应用程序执行的方式完全不同于Dalvik，Dalvik是依靠一个Just-In-Time(JIT)编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运行。ART则完全改变了这套做法，在应用安装的时候就预编译字节码到机器语言，这一机制叫Ahead-Of-Time(AOT)编译。在移除解释代码这一过程后，应用程序执行将更有效率，启动更快。 ART优点： 系统性能的显著提升 应用启动更快、运行更快、体验更流畅、触感反馈更及时 更长的电池续航能力 支持更低的硬件 ART缺点： 更大的存储空间占用，可能会增加10%-20% 更长的应用安装时间]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Binder机制]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FBinder%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Binder机制 首先Binder是Android系统进程间通信(IPC)方式之一。 Binder使用Client－Server通信方式。Binder框架定义了四个角色：Server,Client,ServiceManager以及Binder驱动。其中Server,Client,ServiceManager运行于用户空间，驱动运行于内核空间。Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和Service Manager通过open和ioctl文件操作函数与Binder驱动程序进行通信。 Server创建了Binder实体，为其取一个字符形式，可读易记的名字，将这个Binder连同名字以数据包的形式通过Binder驱动发送给ServiceManager，通知ServiceManager注册一个名字为XX的Binder，它位于Server中。驱动为这个穿过进程边界的Binder创建位于内核中的实体结点以及ServiceManager对实体的引用，将名字以及新建的引用打包给ServiceManager。ServiceManager收数据包后，从中取出名字和引用填入一张查找表中。但是一个Server若向ServiceManager注册自己Binder就必须通过0这个引用和ServiceManager的Binder通信。Server向ServiceManager注册了Binder实体及其名字后，Client就可以通过名字获得该Binder的引用了。Clent也利用保留的0号引用向ServiceManager请求访问某个Binder：我申请名字叫XX的Binder的引用。ServiceManager收到这个连接请求，从请求数据包里获得Binder的名字，在查找表里找到该名字对应的条目，从条目中取出Binder引用，将该引用作为回复发送给发起请求的Client。 当然，不是所有的Binder都需要注册给ServiceManager广而告之的。Server端可以通过已经建立的Binder连接将创建的Binder实体传给Client，当然这条已经建立的Binder连接必须是通过实名Binder实现。由于这个Binder没有向ServiceManager注册名字，所以是匿名Binder。Client将会收到这个匿名Binder的引用，通过这个引用向位于Server中的实体发送请求。匿名Binder为通信双方建立一条私密通道，只要Server没有把匿名Binder发给别的进程，别的进程就无法通过穷举或猜测等任何方式获得该Binder的引用，向该Binder发送请求。 为什么Binder只进行了一次数据拷贝？Linux内核实际上没有从一个用户空间到另一个用户空间直接拷贝的函数，需要先用copy_from_user()拷贝到内核空间，再用copy_to_user()拷贝到另一个用户空间。为了实现用户空间到用户空间的拷贝，mmap()分配的内存除了映射进了接收方进程里，还映射进了内核空间。所以调用copy_from_user()将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间，这就是Binder只需一次拷贝的‘秘密’。 最底层的是Android的ashmen(Anonymous shared memory)机制，它负责辅助实现内存的分配，以及跨进程所需要的内存共享。AIDL(android interface definition language)对Binder的使用进行了封装，可以让开发者方便的进行方法的远程调用，后面会详细介绍。Intent是最高一层的抽象，方便开发者进行常用的跨进程调用。 从英文字面上意思看，Binder具有粘结剂的意思那么它是把什么东西粘接在一起呢？在Android系统的Binder机制中，由一系统组件组成，分别是Client、Server、Service Manager和Binder驱动，其中Client、Server、Service Manager运行在用户空间，Binder驱动程序运行内核空间。Binder就是一种把这四个组件粘合在一起的粘连剂了，其中，核心组件便是Binder驱动程序了，ServiceManager提供了辅助管理的功能，Client和Server正是Binder驱动和ServiceManager提供的基础设施上，进行Client-Server之间的通信。 Client、Server和ServiceManager实现在用户空间中，Binder驱动实现在内核空间中 Binder驱动程序和ServiceManager在Android平台中已经实现，开发者只需要在用户空间实现自己的Client和Server Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和ServiceManager通过open和ioctl文件操作函数与Binder驱动程序进行通信 Client和Server之间的进程间通信通过Binder驱动程序间接实现 ServiceManager是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力 服务器端：一个Binder服务器就是一个Binder类的对象。当创建一个Binder对象后，内部就会开启一个线程，这个线程用户接收binder驱动发送的消息，收到消息后，会执行相关的服务代码。 Binder驱动：当服务端成功创建一个Binder对象后，Binder驱动也会相应创建一个mRemote对象，该对象的类型也是Binder类，客户就可以借助这个mRemote对象来访问远程服务。 客户端：客户端要想访问Binder的远程服务，就必须获取远程服务的Binder对象在binder驱动层对应的binder驱动层对应的mRemote引用。当获取到mRemote对象的引用后，就可以调用相应Binde对象的服务了。 在这里我们可以看到，客户是通过Binder驱动来调用服务端的相关服务。首先，在服务端创建一个Binder对象，接着客户端通过获取Binder驱动中Binder对象的引用来调用服务端的服务。在Binder机制中正是借着Binder驱动将不同进程间的组件bind(粘连)在一起，实现通信。 mmap将一个文件或者其他对象映射进内存。文件被映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会凋零。munmap执行相反的操作，删除特定地址区域的对象映射。 当使用mmap映射文件到进程后，就可以直接操作这段虚拟地址进行文件的读写等操作，不必再调用read,write等系统调用。但需注意，直接对该段内存写时不会写入超过当前文件大小的内容。 使用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次内存数据：一次从输入文件到共享内存区，另一次从共享内存到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域，而是保持共享区域，直到通信完成为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除内存映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。 aidl主要就帮助了我们完成了包装数据和解包的过程，并调用了transact过程，而用来传递的数据包我们就称为parcel AIDL:xxx.aidl -&gt; xxx.java ,注册service 用aidl定义需要被调用方法接口 实现这些方法 调用这些方法]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EventBus]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FEventBus%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[EventBus 概述EventBus是一款针对Android优化的发布/订阅（publish/subscribe）事件总线。主要功能是替代Intent,Handler,BroadCast在Fragment，Activity，Service，线程之间传递消息。简化了应用程序内各组件间、组件与后台线程间的通信。优点是开销小，代码更优雅。以及将发送者和接收者解耦。比如请求网络，等网络返回时通过Handler或Broadcast通知UI，两个Fragment之间需要通过Listener通信，这些需求都可以通过EventBus实现。 EventBus作为一个消息总线，有三个主要的元素： Event：事件。可以是任意类型的对象 Subscriber：事件订阅者，接收特定的事件。在EventBus中，使用约定来指定事件订阅者以简化使用。即所有事件订阅都都是以onEvent开头的函数，具体来说，函数的名字是onEvent,onEventMainThread，onEventBackgroundThread，onEventAsync这四个，这个和ThreadMode（下面讲）有关。 Publisher：事件发布者，用于通知 Subscriber 有事件发生。可以在任意线程任意位置发送事件，直接调用eventBus.post(Object) 方法，可以自己实例化 EventBus对象，但一般使用默认的单例就好了：EventBus.getDefault()， 根据post函数参数的类型，会自动调用订阅相应类型事件的函数。 关于ThreadMode前面说了，Subscriber的函数只能是那4个，因为每个事件订阅函数都是和一个ThreadMode相关联的，ThreadMode指定了会调用的函数。有以下四个ThreadMode： PostThread：事件的处理在和事件的发送在相同的进程，所以事件处理时间不应太长，不然影响事件的发送线程，而这个线程可能是UI线程。对应的函数名是onEvent。 MainThread: 事件的处理会在UI线程中执行。事件处理时间不能太长，这个不用说的，长了会ANR的，对应的函数名是onEventMainThread。 BackgroundThread：事件的处理会在一个后台线程中执行，对应的函数名是onEventBackgroundThread，虽然名字是BackgroundThread，事件处理是在后台线程，但事件处理时间还是不应该太长，因为如果发送事件的线程是后台线程，会直接执行事件，如果当前线程是UI线程，事件会被加到一个队列中，由一个线程依次处理这些事件，如果某个事件处理时间太长，会阻塞后面的事件的派发或处理。 Async：事件处理会在单独的线程中执行，主要用于在后台线程中执行耗时操作，每个事件会开启一个线程（有线程池），但最好限制线程的数目。 根据事件订阅都函数名称的不同，会使用不同的ThreadMode，比如果在后台线程加载了数据想在UI线程显示，订阅者只需把函数命名onEventMainThread。 对相应的函数名，进一步解释一下： onEvent:如果使用onEvent作为订阅函数，那么该事件在哪个线程发布出来的，onEvent就会在这个线程中运行，也就是说发布事件和接收事件线程在同一个线程。使用这个方法时，在onEvent方法中不能执行耗时操作，如果执行耗时操作容易导致事件分发延迟。 onEventMainThread:如果使用onEventMainThread作为订阅函数，那么不论事件是在哪个线程中发布出来的，onEventMainThread都会在UI线程中执行，接收事件就会在UI线程中运行，这个在Android中是非常有用的，因为在Android中只能在UI线程中跟新UI，所以在onEvnetMainThread方法中是不能执行耗时操作的。 onEventBackground:如果使用onEventBackgrond作为订阅函数，那么如果事件是在UI线程中发布出来的，那么onEventBackground就会在子线程中运行，如果事件本来就是子线程中发布出来的，那么onEventBackground函数直接在该子线程中执行。 onEventAsync：使用这个函数作为订阅函数，那么无论事件在哪个线程发布，都会创建新的子线程在执行onEventAsync。 基本用法引入EventBus:1compile 'org.greenrobot:eventbus:3.0.0' 定义事件: 1public class MessageEvent &#123; /* Additional fields if needed */ &#125; 注册事件接收者： 1eventBus.register(this); 发送事件: 1eventBus.post(event) 接收消息并处理: 123// 3.0后不再要求事件以 onEvent 开头，而是采用注解的方式@Subscribe(threadMode = ThreadMode.MAIN)public void receive(MessageEvent event)&#123;&#125; 注销事件接收： 1eventBus.unregister(this); 索引加速： 123.0 后引入了索引加速(默认不开启)的功能，即通过 apt 编译插件的方式，在代码编译的时候对注解进行索引，避免了以往通过反射造成的性能损耗。如何使用可以参考[官方文档](http://greenrobot.org/eventbus/documentation/subscriber-index/) 最后，proguard 需要做一些额外处理: 12345#EventBus -keepclassmembers class ** &#123; public void onEvent*(**); void onEvent*(**); &#125;]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android几种进程]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FAndroid%E5%87%A0%E7%A7%8D%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Android几种进程 前台进程：即与用户正在交互的Activity或者Activity用到的Service等，如果系统内存不足时前台进程是最后被杀死的 可见进程：可以是处于暂停状态(onPause)的Activity或者绑定在其上的Service，即被用户可见，但由于失去了焦点而不能与用户交互 服务进程：其中运行着使用startService方法启动的Service，虽然不被用户可见，但是却是用户关心的，例如用户正在非音乐界面听的音乐或者正在非下载页面自己下载的文件等；当系统要空间运行前两者进程时才会被终止 后台进程：其中运行着执行onStop方法而停止的程序，但是却不是用户当前关心的，例如后台挂着的QQ，这样的进程系统一旦没了有内存就首先被杀死 空进程：不包含任何应用程序的程序组件的进程，这样的进程系统是一般不会让他存在的 如何避免后台进程被杀死： 调用startForegound，让你的Service所在的线程成为前台进程 Service的onStartCommond返回START_STICKY或START_REDELIVER_INTENT Service的onDestroy里面重新启动自己]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git 操作]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FGit%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Git 操作git 命令 创建本地仓库 1git init 获取远程仓库 12git clone [url]例：git clone https://github.com/you/yourpro.git 创建远程仓库 12345678910111213141516// 添加一个新的 remote 远程仓库git remote add [remote-name] [url]例：git remote add origin https://github.com/you/yourpro.gitorigin：相当于该远程仓库的别名// 列出所有 remote 的别名git remote// 列出所有 remote 的 urlgit remote -v// 删除一个 renotegit remote rm [name]// 重命名 remotegit remote rename [old-name] [new-name] 从本地仓库中删除 123git rm file.txt // 从版本库中移除，删除文件git rm file.txt -cached // 从版本库中移除，不删除原始文件git rm -r xxx // 从版本库中删除指定文件夹 从本地仓库中添加新的文件 12git add . // 添加所有文件git add file.txt // 添加指定文件 提交，把缓存内容提交到 HEAD 里 1git commit -m "注释" 撤销 1234567891011// 撤销最近的一个提交.git revert HEAD// 取消 commit + addgit reset --mixed// 取消 commitgit reset --soft// 取消 commit + add + local workinggit reset --hard 把本地提交 push 到远程服务器 12git push [remote-name] [loca-branch]:[remote-branch]例：git push origin master:master 查看状态 1git status 从远程库中下载新的改动 1git fetch [remote-name]/[branch] 合并下载的改动到分支 1git merge [remote-name]/[branch] 从远程库中下载新的改动 1234pull = fetch + mergegit pull [remote-name] [branch]例：git pull origin master 分支 1234567891011// 列出分支git branch// 创建一个新的分支git branch (branch-name)// 删除一个分支git branch -d (branch-nam)// 删除 remote 的分支git push (remote-name) :(remote-branch) 切换分支 12345// 切换到一个分支git checkout [branch-name]// 创建并切换到该分支git checkout -b [branch-name] 与github建立ssh通信，让Git操作免去输入密码的繁琐。 首先呢，我们先建立ssh密匙。 ssh key must begin with ‘ssh-ed25519’, ‘ssh-rsa’, ‘ssh-dss’, ‘ecdsa-sha2-nistp256’, ‘ecdsa-sha2-nistp384’, or ‘ecdsa-sha2-nistp521’. — from github 根据以上文段我们可以知道github所支持的ssh密匙类型，这里我们创建ssh-rsa密匙。在command line 中输入以下指令:ssh-keygen -t rsa去创建一个ssh-rsa密匙。如果你并不需要为你的密匙创建密码和修改名字，那么就一路回车就OK，如果你需要，请您自行Google翻译，因为只是英文问题。 $ ssh-keygen -t rsaGenerating public/private rsa key pair.//您可以根据括号中的路径来判断你的.ssh文件放在了什么地方Enter file in which to save the key (/c/Users/Liang Guan Quan/.ssh/id_rsa): 到 https://github.com/settings/keys 这个地址中去添加一个新的SSH key，然后把你的xx.pub文件下的内容文本都复制到Key文本域中，然后就可以提交了。 添加完成之后 我们用ssh git@github.com 命令来连通一下github，如果你在response里面看到了你github账号名，那么就说明配置成功了。 let’s enjoy github ;) gitignore 在本地仓库根目录创建 .gitignore 文件。Win7 下不能直接创建，可以创建 “.gitignore.” 文件，后面的标点自动被忽略； 1234/.idea // 过滤指定文件夹/fd/* // 忽略根目录下的 /fd/ 目录的全部内容；*.iml // 过滤指定的所有文件!.gitignore // 不忽略该文件]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Fragment]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FFragment%2F</url>
    <content type="text"><![CDATA[Fragment为何产生 同时适配手机和平板、UI和逻辑的共享。 介绍 Fragment也会被加入回退栈中。 Fragment拥有自己的生命周期和接受、处理用户的事件 可以动态的添加、替换和移除某个Fragment 生命周期 必须依存于Activity Fragment依附于Activity的生命状态 生命周期中那么多方法，懵逼了的话我们就一起来看一下每一个生命周期方法的含义吧。 Fragment生命周期方法含义： public void onAttach(Context context) onAttach方法会在Fragment于窗口关联后立刻调用。从该方法开始，就可以通过Fragment.getActivity方法获取与Fragment关联的窗口对象，但因为Fragment的控件未初始化，所以不能够操作控件。 public void onCreate(Bundle savedInstanceState) 在调用完onAttach执行完之后立刻调用onCreate方法，可以在Bundle对象中获取一些在Activity中传过来的数据。通常会在该方法中读取保存的状态，获取或初始化一些数据。在该方法中不要进行耗时操作，不然窗口不会显示。 public View onCreateView(LayoutInflater inflater, ViewGroup container,Bundle savedInstanceState) 该方法是Fragment很重要的一个生命周期方法，因为会在该方法中创建在Fragment显示的View，其中inflater是用来装载布局文件的，container是&lt;fragment&gt;标签的父标签对应对象，savedInstanceState参数可以获取Fragment保存的状态，如果未保存那么就为null。 public void onViewCreated(View view,Bundle savedInstanceState) Android在创建完Fragment中的View对象之后，会立刻回调该方法。其种view参数就是onCreateView中返回的view，而bundle对象用于一般用途。 public void onActivityCreated(Bundle savedInstanceState) 在Activity的onCreate方法执行完之后，Android系统会立刻调用该方法，表示窗口已经初始化完成，从这一个时候开始，就可以在Fragment中使用getActivity().findViewById(Id);来操控Activity中的view了。 public void onStart() 这个没啥可讲的，但有一个细节需要知道，当系统调用该方法的时候，fragment已经显示在ui上，但还不能进行互动，因为onResume方法还没执行完。 public void onResume() 该方法为fragment从创建到显示Android系统调用的最后一个生命周期方法，调用完该方法时候，fragment就可以与用户互动了。 public void onPause() fragment由活跃状态变成非活跃状态执行的第一个回调方法，通常可以在这个方法中保存一些需要临时暂停的工作。如保存音乐播放进度，然后在onResume中恢复音乐播放进度。 public void onStop() 当onStop返回的时候，fragment将从屏幕上消失。 public void onDestoryView() 该方法的调用意味着在 onCreateView 中创建的视图都将被移除。 public void onDestroy() Android在Fragment不再使用时会调用该方法，要注意的是~这时Fragment还和Activity藕断丝连！并且可以获得Fragment对象，但无法对获得的Fragment进行任何操作（呵~呵呵~我已经不听你的了）。 public void onDetach() 为Fragment生命周期中的最后一个方法，当该方法执行完后，Fragment与Activity不再有关联(分手！我们分手！！(╯‵□′)╯︵┻━┻)。 Fragment比Activity多了几个额外的生命周期回调方法： onAttach(Activity):当Fragment和Activity发生关联时使用 onCreateView(LayoutInflater, ViewGroup, Bundle):创建该Fragment的视图 onActivityCreate(Bundle):当Activity的onCreate方法返回时调用 onDestoryView():与onCreateView相对应，当该Fragment的视图被移除时调用 onDetach():与onAttach相对应，当Fragment与Activity关联被取消时调用 注意：除了onCreateView，其他的所有方法如果你重写了，必须调用父类对于该方法的实现Fragment与Activity之间的交互 Fragment与Activity之间的交互可以通过Fragment.setArguments(Bundle args)以及Fragment.getArguments()来实现。 Fragment状态的持久化。由于Activity会经常性的发生配置变化，所以依附它的Fragment就有需要将其状态保存起来问题。下面有两个常用的方法去将Fragment的状态持久化。 方法一： 可以通过protected void onSaveInstanceState(Bundle outState),protected void onRestoreInstanceState(Bundle savedInstanceState) 状态保存和恢复的方法将状态持久化。 方法二(更方便,让Android自动帮我们保存Fragment状态)： 我们只需要将Fragment在Activity中作为一个变量整个保存，只要保存了Fragment，那么Fragment的状态就得到保存了，所以呢….. FragmentManager.putFragment(Bundle bundle, String key, Fragment fragment) 是在Activity中保存Fragment的方法。 FragmentManager.getFragment(Bundle bundle, String key) 是在Activity中获取所保存的Frament的方法。 很显然，key就传入Fragment的id，fragment就是你要保存状态的fragment，但，我们注意到上面的两个方法，第一个参数都是Bundle，这就意味着FragmentManager是通过Bundle去保存Fragment的。但是，这个方法仅仅能够保存Fragment中的控件状态，比如说EditText中用户已经输入的文字（注意！在这里，控件需要设置一个id，否则Android将不会为我们保存控件的状态），而Fragment中需要持久化的变量依然会丢失，但依然有解决办法，就是利用方法一！ 下面给出状态持久化的事例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041 /** Activity中的代码 **/ FragmentB fragmentB; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.fragment_activity); if( savedInstanceState != null )&#123; fragmentB = (FragmentB) getSupportFragmentManager().getFragment(savedInstanceState,"fragmentB"); &#125; init(); &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; if( fragmentB != null )&#123; getSupportFragmentManager().putFragment(outState,"fragmentB",fragmentB); &#125; super.onSaveInstanceState(outState); &#125; /** Fragment中保存变量的代码 **/ @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; AppLog.e("onCreateView"); if ( null != savedInstanceState )&#123; String savedString = savedInstanceState.getString("string"); //得到保存下来的string &#125; View root = inflater.inflate(R.layout.fragment_a,null); return root; &#125;@Override public void onSaveInstanceState(Bundle outState) &#123; outState.putString("string","anAngryAnt"); super.onSaveInstanceState(outState); &#125; 静态的使用Fragment 继承Fragment，重写onCreateView决定Fragment的布局 在Activity中声明此Fragment,就和普通的View一样 Fragment常用的API android.support.v4.app.Fragment 主要用于定义Fragment android.support.v4.app.FragmentManager 主要用于在Activity中操作Fragment，可以使用FragmentManager.findFragmenById，FragmentManager.findFragmentByTag等方法去找到一个Fragment android.support.v4.app.FragmentTransaction 保证一些列Fragment操作的原子性，熟悉事务这个词 主要的操作都是FragmentTransaction的方法(一般我们为了向下兼容，都使用support.v4包里面的Fragment) getFragmentManager() // Fragment若使用的是support.v4包中的，那就使用getSupportFragmentManager代替 &lt;/code&gt; 主要的操作都是FragmentTransaction的方法 1234567891011121314151617181920212223242526272829FragmentTransaction transaction = fm.benginTransatcion();//开启一个事务transaction.add() //往Activity中添加一个Fragmenttransaction.remove() //从Activity中移除一个Fragment，如果被移除的Fragment没有添加到回退栈（回退栈后面会详细说），这个Fragment实例将会被销毁。transaction.replace()//使用另一个Fragment替换当前的，实际上就是remove()然后add()的合体~transaction.hide()//隐藏当前的Fragment，仅仅是设为不可见，并不会销毁transaction.show()//显示之前隐藏的Fragmentdetach()//当fragment被加入到回退栈的时候，该方法与*remove()*的作用是相同的，//反之，该方法只是将fragment从视图中移除，//之后仍然可以通过*attach()*方法重新使用fragment，//而调用了*remove()*方法之后，//不仅将Fragment从视图中移除，fragment还将不再可用。attach()//重建view视图，附加到UI上并显示。transatcion.commit()//提交一个事务 管理Fragment回退栈 跟踪回退栈状态 我们通过实现OnBackStackChangedListener接口来实现回退栈状态跟踪，具体如下1234567891011 public class XXX implements FragmentManager.OnBackStackChangedListener /** 实现接口所要实现的方法 **/@Override public void onBackStackChanged() &#123; //do whatevery you want &#125; /** 设置回退栈监听接口 **／ getSupportFragmentManager().addOnBackStackChangedListener(this); 管理回退栈 FragmentTransaction.addToBackStack(String) —将一个刚刚添加的Fragment加入到回退栈中 getSupportFragmentManager().getBackStackEntryCount() －获取回退栈中实体数量 getSupportFragmentManager().popBackStack(String name, int flags) －根据name立刻弹出栈顶的fragment getSupportFragmentManager().popBackStack(int id, int flags) －根据id立刻弹出栈顶的fragment]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Handler内存泄漏分析及解决]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FHandler%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[Handler内存泄漏分析及解决 一、介绍首先，请浏览下面这段handler代码： 12345678public class SampleActivity extends Activity &#123; private final Handler mLeakyHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; // ... &#125; &#125;&#125; 在使用handler时，这是一段很常见的代码。但是，它却会造成严重的内存泄漏问题。在实际编写中，我们往往会得到如下警告： 1⚠ In Android, Handler classes should be static or leaks might occur. 二、分析1、 Android角度 当Android应用程序启动时，framework会为该应用程序的主线程创建一个Looper对象。这个Looper对象包含一个简单的消息队列Message Queue，并且能够循环的处理队列中的消息。这些消息包括大多数应用程序framework事件，例如Activity生命周期方法调用、button点击等，这些消息都会被添加到消息队列中并被逐个处理。 另外，主线程的Looper对象会伴随该应用程序的整个生命周期。 然后，当主线程里，实例化一个Handler对象后，它就会自动与主线程Looper的消息队列关联起来。所有发送到消息队列的消息Message都会拥有一个对Handler的引用，所以当Looper来处理消息时，会据此回调[Handler#handleMessage(Message)]方法来处理消息。 2、 Java角度 在java里，非静态内部类 和 匿名类 都会潜在的引用它们所属的外部类。但是，静态内部类却不会。 三、泄漏来源请浏览下面一段代码： 1234567891011121314151617181920212223public class SampleActivity extends Activity &#123; private final Handler mLeakyHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; // ... &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Post a message and delay its execution for 10 minutes. mLeakyHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; /* ... */ &#125; &#125;, 1000 * 60 * 10); // Go back to the previous Activity. finish(); &#125;&#125; 当activity结束(finish)时，里面的延时消息在得到处理前，会一直保存在主线程的消息队列里持续10分钟。而且，由上文可知，这条消息持有对handler的引用，而handler又持有对其外部类（在这里，即SampleActivity）的潜在引用。这条引用关系会一直保持直到消息得到处理，从而，这阻止了SampleActivity被垃圾回收器回收，同时造成应用程序的泄漏。 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD注意，上面代码中的Runnable类—非静态匿名类—同样持有对其外部类的引用。从而也导致泄漏。 =======注意，上面代码中的Runnable类—非静态匿名类—同样持有对其外部类的引用。从而也导致泄漏。 c67abfcfd66909095068cb5f0c8632dc5547131b 四、泄漏解决方案 首先，上面已经明确了内存泄漏来源： 只要有未处理的消息，那么消息会引用handler，非静态的handler又会引用外部类，即Activity，导致Activity无法被回收，造成泄漏； Runnable类属于非静态匿名类，同样会引用外部类。 为了解决遇到的问题，我们要明确一点：静态内部类不会持有对外部类的引用。所以，我们可以把handler类放在单独的类文件中，或者使用静态内部类便可以避免泄漏。 另外，如果想要在handler内部去调用所在的外部类Activity，那么可以在handler内部使用弱引用的方式指向所在Activity，这样统一不会导致内存泄漏。 对于匿名类Runnable，同样可以将其设置为静态类。因为静态的匿名类不会持有对外部类的引用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SampleActivity extends Activity &#123; /** * Instances of static inner classes do not hold an implicit * reference to their outer class. */ private static class MyHandler extends Handler &#123; private final WeakReference&lt;SampleActivity&gt; mActivity; public MyHandler(SampleActivity activity) &#123; mActivity = new WeakReference&lt;SampleActivity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; SampleActivity activity = mActivity.get(); if (activity != null) &#123; // ... &#125; &#125; &#125; private final MyHandler mHandler = new MyHandler(this); /** * Instances of anonymous classes do not hold an implicit * reference to their outer class when they are "static". */ private static final Runnable sRunnable = new Runnable() &#123; @Override public void run() &#123; /* ... */ &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Post a message and delay its execution for 10 minutes. mHandler.postDelayed(sRunnable, 1000 * 60 * 10); // Go back to the previous Activity. finish(); &#125;&#125; 五、小结&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD虽然静态类与非静态类之间的区别并不大，但是对于Android开发者而言却是必须理解的。至少我们要清楚，如果一个内部类实例的生命周期比Activity更长，那么我们千万不要使用非静态的内部类。最好的做法是，使用静态内部类，然后在该类里使用弱引用来指向所在的Activity。 原文链接： http://www.jianshu.com/p/cb9b4b71a820虽然静态类与非静态类之间的区别并不大，但是对于Android开发者而言却是必须理解的。至少我们要清楚，如果一个内部类实例的生命周期比Activity更长，那么我们千万不要使用非静态的内部类。最好的做法是，使用静态内部类，然后在该类里使用弱引用来指向所在的Activity。 原文链接： http://www.jianshu.com/p/cb9b4b71a820 c67abfcfd66909095068cb5f0c8632dc5547131b]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MVC,MVP,MVVM的区别]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FMVC%2CMVP%2CMVVM%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[MVC,MVP,MVVM的区别 MVC软件可以分为三部分 视图（View）:用户界面 控制器（Controller）:业务逻辑 模型（Model）:数据保存 各部分之间的通信方式如下： View传送指令到Controller Controller完成业务逻辑后，要求Model改变状态 Model将新的数据发送到View，用户得到反馈 Tips：所有的通信都是单向的。 互动模式接受用户指令时，MVC可以分为两种方式。一种是通过View接受指令，传递给Controller。 另一种是直接通过Controller接受指令 MVPMVP模式将Controller改名为Presenter，同时改变了通信方向。 各部分之间的通信，都是双向的 View和Model不发生联系，都通过Presenter传递 View非常薄，不部署任何业务逻辑，称为”被动视图”(Passive View)，即没有任何主动性，而Presenter非常厚，所有逻辑都部署在那里。 MVVMMVVM模式将Presenter改名为ViewModel，基本上与MVP模式完全一致。 唯一的区别是，它采用双向绑定(data-binding)：View的变动，自动反映在ViewModel，反之亦然。]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ListView详解]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FListview%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[ListView详解 直接继承自AbsListView，AbsListView继承自AdapterView，AdapterView又继承自ViewGroup。 Adpater在ListView和数据源之间起到了一个桥梁的作用 RecycleBin机制RecycleBin机制是ListView能够实现成百上千条数据都不会OOM最重要的一个原因。RecycleBin是AbsListView的一个内部类。 RecycleBin当中使用mActiveViews这个数组来存储View，调用这个方法后就会根据传入的参数来将ListView中的指定元素存储到mActiveViews中。 mActiveViews当中所存储的View，一旦被获取了之后就会从mActiveViews当中移除，下次获取同样位置的时候将会返回null，所以mActiveViews不能被重复利用。 addScrapView()用于将一个废弃的View进行缓存，该方法接收一个View参数，当有某个View确定要废弃掉的时候（比如滚动出了屏幕）就应该调用这个方法来对View进行缓存，RecycleBin当中使用mScrapV iews和mCurrentScrap这两个List来存储废弃View。 getScrapView 用于从废弃缓存中取出一个View，这些废弃缓存中的View是没有顺序可言的，因此getScrapView()方法中的算法也非常简单，就是直接从mCurrentScrap当中获取尾部的一个scrap view进行返回。 我们都知道Adapter当中可以重写一个getViewTypeCount()来表示ListView中有几种类型的数据项，而setViewTypeCount()方法的作用就是为每种类型的数据项都单独启用一个RecycleBin缓存机制。 View的流程分三步，onMeasure()用于测量View的大小，onLayout()用于确定View的布局，onDraw()用于将View绘制到界面上。]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MVP]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FMVP%2F</url>
    <content type="text"><![CDATA[MVP 为什么需要MVP 尽量简单 大部分的安卓应用只使用View-Model结构,程序员现在更多的是和复杂的View打交道而不是解决业务逻辑。当你在应用中只使用Model-View时，到最后，你会发现“所有的事物都被连接到一起”。复杂的任务被分成细小的任务，并且很容易解决。越小的东西，bug越少，越容易debug，更好测试。在MVP模式下的View层将会变得简单，所以即便是他请求数据的时候也不需要回调函数。View逻辑变成十分直接。 后台任务 当你编写一个Actviity、Fragment、自定义View的时候，你会把所有的和后台任务相关的方法写在一个静态类或者外部类中。这样，你的Task不再和Activity联系在一起，这既不会导致内存泄露，也不依赖于Activity的重建。 优缺点优点： 降低耦合度，实现了Model和View真正的完全分离，可以修改View而不影响Modle 模块职责划分明显，层次清晰 隐藏数据 Presenter可以复用，一个Presenter可以用于多个View，而不需要更改Presenter的逻辑（当然是在View的改动不影响业务逻辑的前提下） 利于测试驱动开发。以前的Android开发是难以进行单元测试的（虽然很多Android开发者都没有写过测试用例，但是随着项目变得越来越复杂，没有测试是很难保证软件质量的；而且近几年来Android上的测试框架已经有了长足的发展——开始写测试用例吧），在使用MVP的项目中Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过Mock一个View对象，这个对象只需要实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter应用逻辑的正确性。 View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做到高度可复用的View组件。 代码灵活性 缺点： Presenter中除了应用逻辑以外，还有大量的View-&gt;Model，Model-&gt;View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。 由于对视图的渲染放在了Presenter中，所以视图和Presenter的交互会过于频繁。 如果Presenter过多地渲染了视图，往往会使得它与特定的视图的联系过于紧密。一旦视图需要变更，那么Presenter也需要变更了。 额外的代码复杂度及学习成本。 在MVP模式里通常包含4个要素： View :负责绘制UI元素、与用户进行交互(在Android中体现为Activity); View interface :需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试; Model :负责存储、检索、操纵数据(有时也实现一个Model interface用来降低耦合); Presenter :作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[为什么要使用SurfaceView来实现动画？]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FSurfaceView%2F</url>
    <content type="text"><![CDATA[为什么要使用SurfaceView来实现动画？因为View的绘图存在以下缺陷： View缺乏双缓冲机制 当程序需要更新View上的图像时，程序必须重绘View上显示的整张图片 新线程无法直接更新View组件 SurfaceView的绘图机制 一般会与SurfaceView结合使用 调用SurfaceView的getHolder()方法即可获得SurfaceView关联的SurfaceHolder SurfaceHolder提供了如下方法来获取Canvas对象 Canvas lockCanvas():锁定整个SurfaceView对象，获取该Surface上的Canvas Canvas lockCanvas(Rect dirty):锁定SurfaceView上Rect划分的区域，获取该Surface上的Canvas unlockCanvasAndPost(canvas):释放绘图、提交所绘制的图形，需要注意，当调用SurfaceHolder上的unlockCanvasAndPost方法之后，该方法之前所绘制的图形还处于缓冲之中，下一次lockCanvas()方法锁定的区域可能会“遮挡”它 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 public class SurfaceViewTest extends Activity&#123; // SurfaceHolder负责维护SurfaceView上绘制的内容 private SurfaceHolder holder; private Paint paint; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); paint = new Paint(); SurfaceView surface = (SurfaceView) findViewById(R.id.show); // 初始化SurfaceHolder对象 holder = surface.getHolder(); holder.addCallback(new Callback() &#123; @Override public void surfaceChanged(SurfaceHolder arg0, int arg1, int arg2, int arg3) &#123; &#125; @Override public void surfaceCreated(SurfaceHolder holder) &#123; // 锁定整个SurfaceView Canvas canvas = holder.lockCanvas(); // 绘制背景 Bitmap back = BitmapFactory.decodeResource( SurfaceViewTest.this.getResources() , R.drawable.sun); // 绘制背景 canvas.drawBitmap(back, 0, 0, null); // 绘制完成，释放画布，提交修改 holder.unlockCanvasAndPost(canvas); // 重新锁一次，"持久化"上次所绘制的内容 holder.lockCanvas(new Rect(0, 0, 0, 0)); holder.unlockCanvasAndPost(canvas); &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; &#125; &#125;); // 为surface的触摸事件绑定监听器 surface.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View source, MotionEvent event) &#123; // 只处理按下事件 if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; int cx = (int) event.getX(); int cy = (int) event.getY(); // 锁定SurfaceView的局部区域，只更新局部内容 Canvas canvas = holder.lockCanvas(new Rect(cx - 50, cy - 50, cx + 50, cy + 50)); // 保存canvas的当前状态 canvas.save(); // 旋转画布 canvas.rotate(30, cx, cy); paint.setColor(Color.RED); // 绘制红色方块 canvas.drawRect(cx - 40, cy - 40, cx, cy, paint); // 恢复Canvas之前的保存状态 canvas.restore(); paint.setColor(Color.GREEN); // 绘制绿色方块 canvas.drawRect(cx, cy, cx + 40, cy + 40, paint); // 绘制完成，释放画布，提交修改 holder.unlockCanvasAndPost(canvas); &#125; return false; &#125; &#125;); &#125; &#125; 上面的程序为SurfaceHolder添加了一个CallBack实例，该Callback中定义了如下三个方法： void surfaceChanged(SurfaceHolder holder, int format, int width, int height):当一个surface的格式或大小发生改变时回调该方法。 void surfaceCreated(SurfaceHolder holder):当surface被创建时回调该方法 void surfaceDestroyed(SurfaceHolder holder):当surface将要被销毁时回调该方法]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView和ListView的异同]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FRecyclerview%E5%92%8CListview%E7%9A%84%E5%BC%82%E5%90%8C%2F</url>
    <content type="text"><![CDATA[RecyclerView和ListView的异同 ViewHolder是用来保存视图引用的类，无论是ListView亦或是RecyclerView。只不过在ListView中，ViewHolder需要自己来定义，且这只是一种推荐的使用方式，不使用当然也可以，这不是必须的。只不过不使用ViewHolder的话，ListView每次getView的时候都会调用findViewById(int)，这将导致ListView性能展示迟缓。而在RecyclerView中使用RecyclerView.ViewHolder则变成了必须，尽管实现起来稍显复杂，但它却解决了ListView面临的上述不使用自定义ViewHolder时所面临的问题。 我们知道ListView只能在垂直方向上滚动，Android API没有提供ListView在水平方向上面滚动的支持。或许有多种方式实现水平滑动，但是请想念我，ListView并不是设计来做这件事情的。但是RecyclerView相较于ListView，在滚动上面的功能扩展了许多。它可以支持多种类型列表的展示要求，主要如下： LinearLayoutManager，可以支持水平和竖直方向上滚动的列表。 StaggeredGridLayoutManager，可以支持交叉网格风格的列表，类似于瀑布流或者Pinterest。 GridLayoutManager，支持网格展示，可以水平或者竖直滚动，如展示图片的画廊。 列表动画是一个全新的、拥有无限可能的维度。起初的Android API中，删除或添加item时，item是无法产生动画效果的。后面随着Android的进化，Google的Chat Hasse推荐使用ViewPropertyAnimator属性动画来实现上述需求。相比较于ListView，RecyclerView.ItemAnimator则被提供用于在RecyclerView添加、删除或移动item时处理动画效果。同时，如果你比较懒，不想自定义ItemAnimator，你还可以使用DefaultItemAnimator。 ListView的Adapter中，getView是最重要的方法，它将视图跟position绑定起来，是所有神奇的事情发生的地方。同时我们也能够通过registerDataObserver在Adapter中注册一个观察者。RecyclerView也有这个特性，RecyclerView.AdapterDataObserver就是这个观察者。ListView有三个Adapter的默认实现，分别是ArrayAdapter、CursorAdapter和SimpleCursorAdapter。然而，RecyclerView的Adapter则拥有除了内置的内DB游标和ArrayList的支持之外的所有功能。RecyclerView.Adapter的实现的，我们必须采取措施将数据提供给Adapter，正如BaseAdapter对ListView所做的那样。 在ListView中如果我们想要在item之间添加间隔符，我们只需要在布局文件中对ListView添加如下属性即可： 12android:divider="@android:color/transparent"android:dividerHeight="5dp" ListView通过AdapterView.OnItemClickListener接口来探测点击事件。而RecyclerView则通过RecyclerView.OnItemTouchListener接口来探测触摸事件。它虽然增加了实现的难度，但是却给予开发人员拦截触摸事件更多的控制权限。 ListView可以设置选择模式，并添加MultiChoiceModeListener，如下所示： 123456789101112131415161718192021222324 listView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);listView.setMultiChoiceModeListener(new MultiChoiceModeListener() &#123; public boolean onCreateActionMode(ActionMode mode, Menu menu) &#123; ... &#125; public void onItemCheckedStateChanged(ActionMode mode, int position,long id, boolean checked) &#123; ... &#125; public boolean onActionItemClicked(ActionMode mode, MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.menu_item_delete_crime: CrimeAdapter adapter = (CrimeAdapter)getListAdapter(); CrimeLab crimeLab = CrimeLab.get(getActivity()); for (int i = adapter.getCount() - 1; i &gt;= 0; i--) &#123; if (getListView().isItemChecked(i)) &#123; crimeLab.deleteCrime(adapter.getItem(i)); &#125; &#125; mode.finish(); adapter.notifyDataSetChanged(); return true; default: return false;&#125; public boolean onPrepareActionMode(ActionMode mode, Menu menu) &#123; ... &#125; public void onDestroyActionMode(ActionMode mode) &#123; ... &#125;&#125;); 而RecyclerView则没有此功能。 http://www.cnblogs.com/littlepanpc/p/4497290.html]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[查漏补缺]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2F%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%2F</url>
    <content type="text"><![CDATA[查漏补缺 请分析一张400*500尺寸的PNG图片加载到程序中占用内存中的大小 http://m.blog.csdn.net/article/details?id=7856519]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Zygote和System进程的启动过程]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FZygote%E5%92%8CSystem%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Zygote和System进程的启动过程 init脚本的启动 12345+------------+ +-------+ +-----------+|Linux Kernel+--&gt; |init.rc+-&gt; |app_process|+------------+ +-------+ +-----------+ create and public server socket linux内核加载完成后，运行init.rc脚本 1service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server socket zygote stream 666 /system/bin/app_process Zygote服务启动的进程名 —start-system-server 表明Zygote启动完成之后，要启动System进程。 socket zygote stream 666 在Zygote启动时，创建一个权限为666的socket。此socket用来请求Zygote创建新进程。socket的fd保存在名称为“ANDROID_SOCKET_zygote”的环境变量中。 Zygote进程的启动过程 12345678910111213 create rumtime +-----------+ +----------+ |app_process+----------&gt; |ZygoteInit| +-----------+ +-----+----+ | | | registerZygoteSocket() | +------+ startSystemServer() | |System| &lt;-------+ | +------+ fork | runSelectLoopMode() | v app_process进程 /system/bin/app_process 启动时创建了一个AppRuntime对象。通过AppRuntime对象的start方法，通过JNI调用创建了一个虚拟机实例，然后运行com.android.internal.os.ZygoteInit类的静态main方法，传递true(boolean startSystemServer)参数。 ZygoteInit类 ZygoteInit类的main方法运行时，会通过registerZygoteSocket方法创建一个供ActivityManagerService使用的server socket。然后通过调用startSystemServer方法来启动System进程。最后通过runSelectLoopMode来等待AMS的新建进程请求。 在registerZygoteSocket方法中，通过名为ANDROID_SOCKET_zygote的环境获取到zygote启动时创建的socket的fd，然后以此来创建server socket。 在startSystemServer方法中，通过Zygote.forkSystemServer方法创建了一个子进程，并将其用户和用户组的ID设置为1000。 在runSelectLoopMode方法中，会将之前建立的server socket保存起来。然后进入一个无限循环，在其中通过selectReadable方法，监听socket是否有数据可读。有数据则说明接收到了一个请求。selectReadable方法会返回一个整数值index。如果index为0，则说明这个是AMS发过来的连接请求。这时会与AMS建立一个新的socket连接，并包装成ZygoteConnection对象保存起来。如果index大于0，则说明这是AMS发过来的一个创建新进程的请求。此时会取出之前保存的ZygoteConnection对象，调用其中的runOnce方法创建新进程。调用完成后将connection删除。这就是Zygote处理一次AMS请求的过程。 System进程的启动 123456789101112131415161718192021+ | | v fork() +--------------+ |System Process| +------+-------+ | | RuntimeInit.zygoteInit() commonInit, zygoteInitNative | init1() SurfaceFlinger, SensorServic... | | | init2() +------------+ +-------&gt; |ServerThread| | +----+-------+ | | | | AMS, PMS, WMS... | | | | | | v v System进程是在ZygoteInit的handleSystemServerProcess中开始启动的。 首先，因为System进程是直接fork Zygote进程的，所以要先通过closeServerSocket方法关掉server socket。 调用RuntimeInit.zygoteInit方法进一步启动System进程。在zygoteInit中，通过commonInit方法设置时区和键盘布局等通用信息，然后通过zygoteInitNative方法启动了一个Binder线程池。最后通过invokeStaticMain方法调用SystemServer类的静态Main方法。 SystemServer类的main通过JNI调用cpp实现的init1方法。在init1方法中，会启动各种以C++开发的系统服务（例如SurfaceFlinger和SensorService）。然后回调ServerServer类的init2方法来启动以Java开发的系统服务。 在init2方法中，首先会新建名为”android.server.ServerThread”的ServerThread线程，并调用其start方法。然后在该线程中启动各种Service（例如AMS，PMS，WMS等）。启动的方式是调用对应Service类的静态main方法。 首先，AMS会被创建，但未注册到ServerManager中。然后PMS被创建，AMS这时候才注册到ServerManager中。然后到ContentService、WMS等。注册到ServerManager中时会制定Service的名字，其后其他进程可以通过这个名字来获取到Binder Proxy对象，以访问Service提供的服务。 执行到这里，System就将系统的关键服务启动起来了，这时候其他进程便可利用这些Service提供的基础服务了。 最后会调用ActivityManagerService的systemReady方法，在该方法里会启动系统界面以及Home程序。 Android进程启动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 +----------------------+ +-------+ +----------+ +----------------+ +-----------+ |ActivityManagerService| |Process| |ZygoteInit| |ZygoteConnection| |RuntimeInit| +--------------+-------+ +---+---+ +-----+----+ +-----------+----+ +------+----+ | | | | | | | | | | startProcessLocked() | | | | +---------------&gt; | | | | | | start() | | | | | "android.app.ActivityThread" | | | +-----------------&gt; | | | | | | | | | | | | | | | |openZygoteSocketIfNeeded() | | | +------+ | | | | | | | | | | | &lt;----+ | | | | | | | | | |sZygoteWriter.write(arg) | | | +------+ | | | | | | | | | | | | | | | | | &lt;----+ | | | | | | | | | +--------------&gt; | | | | | | | | | | |runSelectLoopMode() | | | | +-----------------+ | | | | | | | | | | | &lt;---------------+ | | | | | acceptCommandPeer() | | | | | | | | | | | | | | runOnce() | | | | +------------------&gt; | | | | | |forkAndSpecialize() | | | +-------------+ | | | | | | | | | | | &lt;-----------+ | | | | | handleChildProc() | | | | | | | | | | | | | | | | | | | zygoteInit() | | | | +-------------&gt; | | | | | | | | | | |in^okeStaticMain() | | | | +----------------&gt; | | | | |("android.app.ActivityThread") | | | | | | | | | | + + + + + AMS向Zygote发起请求（通过之前保存的socket），携带各种参数，包括“android.app.ActivityThread”。 Zygote进程fork自己，然后在新Zygote进程中调用RuntimeInit.zygoteInit方法进行一系列的初始化（commonInit、Binder线程池初始化等）。 新Zygote进程中调用ActivityThread的main函数，并启动消息循环。]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android动态加载dex技术初探]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2F%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Android动态加载dex技术初探http://blog.csdn.net/u013478336/article/details/50734108 Android使用Dalvik虚拟机加载可执行程序，所以不能直接加载基于class的jar，而是需要将class转化为dex字节码。 Android支持动态加载的两种方式是：DexClassLoader和PathClassLoader，DexClassLoader可加载jar/apk/dex，且支持从SD卡加载；PathClassLoader据说只能加载已经安装在Android系统内APK文件。 Android插件化基础Android简单来说就是如下操作： 开发者将插件代码封装成Jar或者APK 宿主下载或者从本地加载Jar或者APK到宿主中 将宿主调用插件中的算法或者Android特定的Class（如Activity） 插件化开发—动态加载技术加载已安装和未安装的apkhttp://blog.csdn.net/u010687392/article/details/47121729?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io为什么引入动态加载技术？ 一个应用程序dex文件的方法数最大不能超过65536个 可以让应用程序实现插件化、插拔式结构，对后期维护有益 什么是动态加载技术 动态加载技术就是使用类加载器加载相应的apk、dex、jar(必须含有dex文件)，再通过反射获得该apk、dex、jar内部的资源（class、图片、color等等）进而供宿主app使用。 关于动态加载使用的类加载器 PathClassLoader - 只能加载已经安装的apk，即/data/app目录下的apk。 DexClassLoader - 能加载手机中未安装的apk、jar、dex，只要能在找到对应的路径。 插件化技术学习 原因： 各大厂商都碰到了AndroidNative平台的瓶颈： 从技术上讲，业务逻辑的复杂代码急剧膨胀，各大厂商陆续触到65535方法数的天花板；同时，对模块热更新提出了更高的要求。 在业务层面上，功能模块的解耦以及维护团队的分离也是大势所趋。 插件化技术主要解决两个问题： 代码加载 资源加载 代码加载类的加载可以使用Java的ClassLoader机制，还需要组件生命周期管理。 资源加载用AssetManager的隐藏方法addAssetPath。 Android插件化原理解析——Hook机制之动态代理使用代理机制进行API Hook进而达到方法增强。 静态代理 动态代理：可以简单理解为JVM可以在运行时帮我们动态生成一系列的代理类。 代理Hook如果我们自己创建代理对象，然后把原始对象替换为我们的代理对象，就可以在这个代理对象中为所欲为了；修改参数，替换返回值，称之为Hook。 整个Hook过程简要总结如下： 寻找Hook点，原则是静态变量或者单例对象，尽量Hook public的对象和方法，非public不保证每个版本都一样，需要适配。 选择合适的代理方式，如果是接口可以用动态代理；如果是类可以手动写代理也可以使用cglib。 偷梁换柱－用代理对象替换原始对象 Android插件化原理解析——Hook机制之Binder Hook]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自定义控件]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[自定义控件 自定义View的步骤： 自定义View的属性 在View的构造方法中获得我们自定义View的步骤 ［3.重写onMeasure］(不必须) 重写onDraw]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[热修复技术]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2F%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[热修复技术 APP提早发出去的包，如果出现客户端的问题，实在是干着急，覆水难收。因此线上修复方案迫在眉睫。 概述基于Xposed中的思想，通过修改c层的Method实例描述，来实现更改与之对应的java方法的行为，从而达到修复的目的。 Xposed诞生于XDA论坛，类似一个应用平台，不同的是其提供诸多系统级的应用。可实现许多神奇的功能。Xposed需要以越狱为前提，像是iOS中的cydia。 Xposed可以修改任何程序的任何java方法（需root），github上提供了XposedInstaller，是一个android app。提供很多framework层，应用层级的程序。开发者可以为其开发一些系统或应用方面的插件，自定义android系统，它甚至可以做动态权限管理（XposedMods）。 Android系统启动与应用启动Zygote进程是Android手机系统启动后，常驻的一个名为‘受精卵’的进程。 zygote的启动实现脚本在/init.rc文件中 启动过程中执行的二进制文件在/system/bin/app_process 任何应用程序启动时，会从zygote进程fork出一个新的进程。并装载一些必要的class，invoke一些初始化方法。这其中包括像： ActivityThread ServiceThread ApplicationPackageManager 等应用启动中必要的类，触发必要的方法，比如：handleBindApplication，将此进程与对应的应用绑定的初始化方法；同时，会将zygote进程中的dalvik虚拟机实例复制一份，因此每个应用程序进程都有自己的dalvik虚拟机实例；会将已有Java运行时加载到进程中；会注册一些android核心类的jni方法到虚拟机中，支撑从c到java的启动过程。 Xposed做了手脚Xposed在这个过程改写了app_process(源码在Xposed : a modified app_process binary)，替换/system/bin/app_process这个二进制文件。然后做了两个事： 通过Xposed的hook技术，在上述过程中，对上面提到的那些加载的类的方法hook。 加载XposedBridge.jar 这时hook必要的方法是为了方便开发者为它开发插件，加载XposedBridge.jar是为动态hook提供了基础。在这个时候加载它意味着，所有的程序在启动时，都可以加载这个jar（因为上面提到的fork过程）。结合hook技术，从而达到了控制所有程序的所有方法。 为获得/system/bin/目录的读写权限，因而需要以root为前提。 Xposed的hook思想那么Xposed是怎么hook java方法的呢？要从XposedBridge看起，重点在XposedBridge.hookmethod(原方法的Member对象，含有新方法的XC_MethodHook对象)；，这里会调到 1private native synchronized static void hookMethodNative(Member method, Class&lt;?&gt; declaringClass, int slot, Object additionalInfo); 这个native的方法，通过这个方法，可以让所hook的方法，转向native层的一个c方法。如何做到？ 12When a transmit from java to native occurs, dvm sets up a native stack.In dvmCallJNIMethod(), dvmPlatformInvoke is used to call the native method(signature in Method.insns). 在jni这个中间世界里，类型数据由jni表来沟通java和c的世界；方法由c++指针结合DVM*系(如dvmSlotToMethod,dvmDecodeIndirectRef等方法)的api方法，操作虚拟机，从而实现java方法与c方法的世界。 那么hook的过程是这样：首先通过dexclassload来load所要hook的方法，分析类后，进c层，见代码XposedBridge_hookMethodNative方法，拿到要hook的Method类，然后通过dvmslotTomethod方法获取Method*指针， 1Method* method = dvmSlotToMethod(declaredClass, slot); declaredClass就是所hook方法所在的类，对应的jobject。slot是Method类中，描述此java对象在vm中的索引；那么通过这个方法，我们就获取了c层的Method指针,通过 1SET_METHOD_FLAG(method, ACC_NATIVE); 将该方法标记为一个native方法，然后通过 1method-&gt;nativeFunc = &amp;hookedMethodCallback; 定向c层方法到hookedMethodCallback，这样当被hook的java方法执行时，就会调到c层的hookedMethodCallback方法。 通过meth-&gt;nativeFunc重定向MethodCallBridge到hookedMethodCallback这个方法上，控制这个c++指针是无视java的private的。 另外，在method结构体中有 1method-&gt;insns = (const u2*) hookInfo; 用insns指向替换成为的方法，以便hookedMethodCallback可以获取真正期望执行的java方法。 现在所有被hook的方法，都指向了hookedMethodCallbackc方法中，然后在此方法中实现调用替换成为的java方法。 从Xposed提炼精髓回顾Xposed，以root为必要条件，在app_process加载XposedBidge.jar，从而实现有hook所有应用的所有方法的能力；而后续动态hook应用内的方法，其实只是load了从zypote进程复制出来的运行时的这个XposedBidge.jar，然后hook而已。因此，若在一个应用范围内的hook，root不是必须的，只是单纯的加载hook的实现方法，即可修改本应用的方法。 业界内也不乏通过「修改BaseDexClassLoader中的pathList，来动态加载dex」方式实现热修复。后者纯java实现，但需要hack类的优化流程，将打CLASS_ISPREVERIFIED标签的类，去除此标签，以解决类与类引用不在一个dex中的异常问题。这会放弃dex optimize对启动运行速度的优化。原则上，这对于方法数没有大到需要multidex的应用，损失更明显。而前者不触犯原有的优化流程，只点杀需要hook的方法，更为纯粹、有效。]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django本地项目部署到云服务器]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FDjango%2FDjango%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Django本地项目部署到云服务器开发环境开发语言： Python后台框架：Djangoweb服务器：nginxwsgi服务器：uwsgi 云服务器系统：Ubuntu 查看本地项目Django和Python版本： （可以直接安装Django最新版本就可以了，Python版本不能低于3.4） 12345678root@iZwz969jm0y04abuhgx4byZ:/home/projects/closet/closetUsers# python3Python 3.5.2 (default, Nov 12 2018, 13:43:14) [GCC 5.4.0 20160609] on linuxType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import django&gt;&gt;&gt; django.VERSION(2, 1, 4, 'final', 0)&gt;&gt;&gt; 参考了别家的教程 1. 预备安装1.1 安装数据库安装mysql Ubuntu上的MySQL搭建 1.2 安装Django安装Django Django初步使用移步Django系列教程： Django数据库配置 1.3 安装uwsgi1.3.1 uwsgi安装1root@iZwz969jm0y04abuhgx4byZ:~# python3 -m pip install uwsgi Successfully installed uwsgi-2.0.17 1.3.2 uwsgi测试测试 uwsgi 是否正常： 新建 test.py 文件，内容如下： 123def application(env, start_response): start_response('200 OK', [('Content-Type','text/html')]) return "cloestUsers World" 然后在终端运行： 1uwsgi --http :8001 --wsgi-file test.py 在浏览器内输入：http://127.0.0.1:8001，查看是否有&quot;cloestUsers World”输出，若没有输出，请检查你的安装过程。 1.3.3 uwsgi关闭12345678910111213killall -9 uwsgi # 强行关闭# 关闭某一个进程root@iZwz969jm0y04abuhgx4byZ:/home/projects/closet/closetUsers# netstat -ntplActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program nametcp 0 0 127.0.0.1:8005 0.0.0.0:* LISTEN 22256/java tcp 0 0 0.0.0.0:8009 0.0.0.0:* LISTEN 22256/java tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 18840/mysqld tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 3044/nginx.conf tcp 0 0 0.0.0.0:8080 0.0.0.0:* LISTEN 22256/java tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 11022/sshd root@iZwz969jm0y04abuhgx4byZ:/home/projects/closet/closetUsers# kill -9 22256# 查看哪个要关闭的进程的pid，使用kill -9 &lt;pid&gt; 1.4 安装nginx1.4.1 安装 Nginx安装命令如下： 12345678cd ~wget http://nginx.org/download/nginx-1.11.0.tar.gztar xf nginx-1.11.0.tar.gzcd nginx-1.11.0./configure --prefix=/usr/local/nginx-1.11.0 \--with-http_stub_status_module \--with-http_gzip_static_modulemake &amp;&amp; make install 你可以阅读 Nginx 安装配置 了解更多内容。 1.4.2 测试nginx查看nginx是否安装成功，查看nginx的版本： 12root@iZwz969jm0y04abuhgx4byZ:/home/projects/closet/closetUsers# nginx -vnginx version: nginx/1.10.3 (Ubuntu) 在/home/projects目录下新建一个test目录，在里面添加一个简单的html文件。然后在nginx.conf中简单配置： 12345678events&#123;&#125;http&#123; server&#123; server_name www.sukamay.xyz; # 域名或者ip地址 root /home/projects/test; index index.html; &#125;&#125; 启动该nginx：（启动之前，要将/usr/local/nginx/mime.types文件复制到该nginx.conf所在目录，并且必须使用绝对路径） 1nginx -c /home/projects/test/nginx.conf 如果端口被占用，则先释放该端口,则使用lsof -i :8082查看占用端口进程的pid，并使用kill -9 [pid]关闭相应的进程。 若想要关闭所有nginx打开的进程，可使用： 1killall -9 nginx 在浏览器中访问自己的域名http://www.sukamay.xyz，访问成功。（域名要先做好dns解析） 1.4.3 关闭nginx12nginx -s stop# or /etc/init.d/nginx stop 2. 在线项目部署部署本地Django项目到服务器，结合uwsgi+Django+nginx。 2.1 项目代码上传到服务器clone本地项目代码到服务器/通过ftp复制项目到服务器 我使用的是scp 12xxxdeMacBook-Pro:~ xxx$ scp -r /Users/xxx/Desktop/closet/closetUsers root@120.76.62.132:/home/projects/closetTest1.0# pattern: scp &lt;option&gt; &lt;local_file_path&gt; root@&lt;server_ip_address&gt;:&lt;goal_file_path&gt; 在我的项目目录/home/projects里创建一个closet目录，并在里面创建一个conf目录，用来存放配置文件,这样分离开来，方便更新维护项目代码。 12345678910111213141516171819202122root@iZwz969jm0y04abuhgx4byZ:/home/projects# tree -L 3.├── closet│ ├── closetUsers│ │ ├── closetUsers│ │ ├── jsonTest│ │ ├── manage.py│ │ ├── __pycache__│ │ ├── static│ │ ├── users│ └── conf│ ├── mime.types #copy from /usr/local/nginx/conf│ ├── nginx.conf #configure file of nginx │ ├── uwsgi.ini #configure file of uwsgi│ └── uwsgi.log└── closetTest1.0 └── closetUsers ├── closetUsers ├── manage.py └── users13 directories, 10 files 2.2 修改项目代码2.2.1 修改settings.py：1234DEBUG = False # Django是否加载静态资源ALLOWED_HOSTS = ['localhost','127.0.0.1','120.76.62.132'] # 允许访问的主机地址STATIC_ROOT = os.path.join(BASE_DIR, "static/") # 收集Django的静态文件到同一个static中 2.2.2 创建uwsgi.ini和uwsgi.loguwsgi.ini不变，依旧为： 123456789101112131415161718192021222324252627root@iZwz969jm0y04abuhgx4byZ:/home/projects/closet/conf# vim uwsgi.ini # closet uwsgi.ini file[uwsgi]socket = 127.0.0.1:8002# http = :8002 如果不通过nginx可以直接用http，但要通过web服务器就必须要用socket# http = 127.0.0.1:8002# the base directory (full path)chdir = /home/projects/closet/closetUsers# Django's wsgi filemodule = closetUsers.wsgi# process-related settings# mastermaster = true# maximum number of worker processesprocesses = 4# clear environment on exitvacuum = trueprocesses = 4"uwsgi.ini" 29L, 549C 1,0-1 Top 2.2.3 创建nginx.conf123456789101112131415161718192021222324root@iZwz969jm0y04abuhgx4byZ:/home/projects/closet/conf# vim nginx.conf http&#123; include mime.types; server&#123; listen 80; # server_name www.sukamay.xyz; server_name 120.76.62.132; index index.html ; root /home/projects/closet/closetUsers; charset utf-8; location /static &#123; alias /home/projects/closet/closetUsers/static; # your Django project's static files - amend as required &#125; # Finally, send all non-media requests to the Django server. location / &#123; include /etc/nginx/uwsgi_params; # the uwsgi_params file you installed uwsgi_pass 127.0.0.1:8002; &#125; &#125; &#125; 将 /usr/local/nginx/conf/mime.types文件copy到conf下 2.3 创建数据库、收集静态文件12python manage.py migrate python manage.py collectstatic 2.4 启动服务启动nginx 1nginx -c /home/projects/closet/conf/nginx.conf 后台启动uwsgi 1uwsgi /home/projects/closet/conf/uwsgi.ini -d /home/projects/closet/conf/uwsgi.log 访问 http://120.76.62.132/ （我没写默认index.html，访问的是http://120.76.62.132/users/）可以看到接口写好的返回内容， 则创建成功 3. error summary]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android：]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FAndroid%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Android： 五种布局： FrameLayout 、 LinearLayout 、 AbsoluteLayout 、 RelativeLayout 、 TableLayout 全都继承自ViewGroup，各自特点及绘制效率对比。 FrameLayout(框架布局) 此布局是五种布局中最简单的布局，Android中并没有对child view的摆布进行控制，这个布局中所有的控件都会默认出现在视图的左上角，我们可以使用android:layout_margin，android:layout_gravity等属性去控制子控件相对布局的位置。 LinearLayout(线性布局) 一行（或一列）只控制一个控件的线性布局，所以当有很多控件需要在一个界面中列出时，可以用LinearLayout布局。 此布局有一个需要格外注意的属性:android:orientation=“horizontal|vertical。 当android:orientation=&quot;horizontal时，说明你希望将水平方向的布局交给LinearLayout ，其子元素的android:layout_gravity=&quot;right|left&quot; 等控制水平方向的gravity值都是被忽略的，此时LinearLayout中的子元素都是默认的按照水平从左向右来排，我们可以用android:layout_gravity=&quot;top|bottom&quot;等gravity值来控制垂直展示。 反之，可以知道 当android:orientation=&quot;vertical时，LinearLayout对其子元素展示上的的处理方式。 AbsoluteLayout(绝对布局) 可以放置多个控件，并且可以自己定义控件的x,y位置 RelativeLayout(相对布局) 这个布局也是相对自由的布局，Android 对该布局的child view的 水平layout&amp; 垂直layout做了解析，由此我们可以FrameLayout的基础上使用标签或者Java代码对垂直方向 以及 水平方向 布局中的views进行任意的控制. 相关属性： 1234 android:layout_centerInParent="true|false" android:layout_centerHorizontal="true|false" android:layout_alignParentRight="true|false" TableLayout(表格布局) 将子元素的位置分配到行或列中，一个TableLayout由许多的TableRow组成 Activity生命周期。 启动Activity:onCreate()—&gt;onStart()—&gt;onResume()，Activity进入运行状态。 Activity退居后台:当前Activity转到新的Activity界面或按Home键回到主屏：onPause()—&gt;onStop()，进入停滞状态。 Activity返回前台:onRestart()—&gt;onStart()—&gt;onResume()，再次回到运行状态。 Activity退居后台，且系统内存不足，系统会杀死这个后台状态的Activity（此时这个Activity引用仍然处在任务栈中，只是这个时候引用指向的对象已经为null），若再次回到这个Activity,则会走onCreate()–&gt;onStart()—&gt;onResume()(将重新走一次Activity的初始化生命周期) 锁屏：onPause()-&gt;onStop() 解锁：onStart()-&gt;onResume() 更多流程分支，请参照以下生命周期流程图 通过Acitivty的xml标签来改变任务栈的默认行为 使用android:launchMode=&quot;standard|singleInstance|singleTask|singleTop&quot;来控制Acivity任务栈。 任务栈是一种后进先出的结构。位于栈顶的Activity处于焦点状态,当按下back按钮的时候,栈内的Activity会一个一个的出栈,并且调用其onDestory()方法。如果栈内没有Activity,那么系统就会回收这个栈,每个APP默认只有一个栈,以APP的包名来命名. standard : 标准模式,每次启动Activity都会创建一个新的Activity实例,并且将其压入任务栈栈顶,而不管这个Activity是否已经存在。Activity的启动三回调(onCreate()-&gt;onStart()-&gt;onResume())都会执行。 singleTop : 栈顶复用模式.这种模式下,如果新Activity已经位于任务栈的栈顶,那么此Activity不会被重新创建,所以它的启动三回调就不会执行,同时Activity的onNewIntent()方法会被回调.如果Activity已经存在但是不在栈顶,那么作用与standard模式一样. singleTask: 栈内复用模式.创建这样的Activity的时候,系统会先确认它所需任务栈已经创建,否则先创建任务栈.然后放入Activity,如果栈中已经有一个Activity实例,那么这个Activity就会被调到栈顶,onNewIntent(),并且singleTask会清理在当前Activity上面的所有Activity.(clear top) singleInstance : 加强版的singleTask模式,这种模式的Activity只能单独位于一个任务栈内,由于栈内复用的特性,后续请求均不会创建新的Activity,除非这个独特的任务栈被系统销毁了 Activity的堆栈管理以ActivityRecord为单位,所有的ActivityRecord都放在一个List里面.可以认为一个ActivityRecord就是一个Activity栈 Activity缓存方法。 有a、b两个Activity，当从a进入b之后一段时间，可能系统会把a回收，这时候按back，执行的不是a的onRestart而是onCreate方法，a被重新创建一次，这是a中的临时数据和状态可能就丢失了。 可以用Activity中的onSaveInstanceState()回调方法保存临时数据和状态，这个方法一定会在活动被回收之前调用。方法中有一个Bundle参数，putString()、putInt()等方法需要传入两个参数，一个键一个值。数据保存之后会在onCreate中恢复，onCreate也有一个Bundle类型的参数。 示例代码： 12345678910111213141516171819@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //这里，当Acivity第一次被创建的时候为空 //所以我们需要判断一下 if( savedInstanceState != null )&#123; savedInstanceState.getString("anAnt"); &#125;&#125;@Overrideprotected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); outState.putString("anAnt","Android");&#125; 一、onSaveInstanceState (Bundle outState) 当某个activity变得“容易”被系统销毁时，该activity的onSaveInstanceState就会被执行，除非该activity是被用户主动销毁的，例如当用户按BACK键的时候。 注意上面的双引号，何为“容易”？言下之意就是该activity还没有被销毁，而仅仅是一种可能性。这种可能性有哪些？通过重写一个activity的所有生命周期的onXXX方法，包括onSaveInstanceState和onRestoreInstanceState方法，我们可以清楚地知道当某个activity（假定为activity A）显示在当前task的最上层时，其onSaveInstanceState方法会在什么时候被执行，有这么几种情况： 1、当用户按下HOME键时。 这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，故系统会调用onSaveInstanceState，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则 2、长按HOME键，选择运行其他的程序时。 3、按下电源按键（关闭屏幕显示）时。 4、从activity A中启动一个新的activity时。 5、屏幕方向切换时，例如从竖屏切换到横屏时。（如果不指定configchange属性）在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行 总而言之，onSaveInstanceState的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的activity，则onSaveInstanceState会被系统调用，这是系统的责任，因为它必须要提供一个机会让你保存你的数据（当然你不保存那就随便你了）。另外，需要注意的几点： 1.布局中的每一个View默认实现了onSaveInstanceState()方法，这样的话，这个UI的任何改变都会自动地存储和在activity重新创建的时候自动地恢复。但是这种情况只有在你为这个UI提供了唯一的ID之后才起作用，如果没有提供ID，app将不会存储它的状态。 2.由于默认的onSaveInstanceState()方法的实现帮助UI存储它的状态，所以如果你需要覆盖这个方法去存储额外的状态信息，你应该在执行任何代码之前都调用父类的onSaveInstanceState()方法（super.onSaveInstanceState()）。既然有现成的可用，那么我们到底还要不要自己实现onSaveInstanceState()?这得看情况了，如果你自己的派生类中有变量影响到UI，或你程序的行为，当然就要把这个变量也保存了，那么就需要自己实现，否则就不需要。 3.由于onSaveInstanceState()方法调用的不确定性，你应该只使用这个方法去记录activity的瞬间状态（UI的状态）。不应该用这个方法去存储持久化数据。当用户离开这个activity的时候应该在onPause()方法中存储持久化数据（例如应该被存储到数据库中的数据）。 4.onSaveInstanceState()如果被调用，这个方法会在onStop()前被触发，但系统并不保证是否在onPause()之前或者之后触发。 二、onRestoreInstanceState (Bundle outState) 至于onRestoreInstanceState方法，需要注意的是，onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的，（本人注：我昨晚调试时就发现原来不一定成对被调用的！） onRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行 另外，onRestoreInstanceState的bundle参数也会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原。还有onRestoreInstanceState在onstart之后执行。至于这两个函数的使用，给出示范代码（留意自定义代码在调用super的前或后）： 12345678910111213141516171819@Overridepublic void onSaveInstanceState(Bundle savedInstanceState) &#123; savedInstanceState.putBoolean("MyBoolean", true); savedInstanceState.putDouble("myDouble", 1.9); savedInstanceState.putInt("MyInt", 1); savedInstanceState.putString("MyString", "Welcome back to Android"); // etc. super.onSaveInstanceState(savedInstanceState);&#125;@Overridepublic void onRestoreInstanceState(Bundle savedInstanceState) &#123; super.onRestoreInstanceState(savedInstanceState); boolean myBoolean = savedInstanceState.getBoolean("MyBoolean"); double myDouble = savedInstanceState.getDouble("myDouble"); int myInt = savedInstanceState.getInt("MyInt"); String myString = savedInstanceState.getString("MyString");&#125; Fragment的生命周期和activity如何的一个关系 这我们引用本知识库里的一张图片： 为什么在Service中创建子线程而不是Activity中 这是因为Activity很难对Thread进行控制，当Activity被销毁之后，就没有任何其它的办法可以再重新获取到之前创建的子线程的实例。而且在一个Activity中创建的子线程，另一个Activity无法对其进行操作。但是Service就不同了，所有的Activity都可以与Service进行关联，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。 Intent的使用方法，可以传递哪些数据类型。 通过查询Intent/Bundle的API文档，我们可以获知，Intent/Bundle支持传递基本类型的数据和基本类型的数组数据，以及String/CharSequence类型的数据和String/CharSequence类型的数组数据。而对于其它类型的数据貌似无能为力，其实不然，我们可以在Intent/Bundle的API中看到Intent/Bundle还可以传递Parcelable（包裹化，邮包）和Serializable（序列化）类型的数据，以及它们的数组/列表数据。 所以要让非基本类型和非String/CharSequence类型的数据通过Intent/Bundle来进行传输，我们就需要在数据类型中实现Parcelable接口或是Serializable接口。 http://blog.csdn.net/kkk0526/article/details/7214247 Fragment生命周期 注意和Activity的相比的区别,按照执行顺序 onAttach(),onDetach() onCreateView(),onDestroyView() Service的两种启动方法，有什么区别1.在Context中通过public boolean bindService(Intent service,ServiceConnection conn,int flags) 方法来进行Service与Context的关联并启动，并且Service的生命周期依附于Context(不求同时同分同秒生！但求同时同分同秒屎！！)。 2.通过public ComponentName startService(Intent service)方法去启动一个Service，此时Service的生命周期与启动它的Context无关。 3.要注意的是，whatever，都需要在xml里注册你的Service，就像这样:123&lt;service android:name=".packnameName.youServiceName" android:enabled="true" /&gt; 广播(Broadcast Receiver)的两种动态注册和静态注册有什么区别。 静态注册：在AndroidManifest.xml文件中进行注册，当App退出后，Receiver仍然可以接收到广播并且进行相应的处理 动态注册：在代码中动态注册，当App退出后，也就没办法再接受广播了 ContentProvider使用方法 http://blog.csdn.net/juetion/article/details/17481039 目前能否保证service不被杀死 Service设置成START_STICKY kill 后会被重启（等待5秒左右），重传Intent，保持与重启前一样 提升service优先级 在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = &quot;1000&quot;这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。 【结论】目前看来，priority这个属性貌似只适用于broadcast，对于Service来说可能无效 提升service进程优先级 Android中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进行进程的回收 当service运行在低内存的环境时，将会kill掉一些存在的进程。因此进程的优先级将会很重要，可以在startForeground()使用startForeground()将service放到前台状态。这样在低内存时被kill的几率会低一些。 【结论】如果在极度极度低内存的压力下，该service还是会被kill掉，并且不一定会restart() onDestroy方法里重启service service +broadcast 方式，就是当service走onDestory()的时候，发送一个自定义的广播，当收到广播的时候，重新启动service 也可以直接在onDestroy()里startService 【结论】当使用类似口口管家等第三方应用或是在setting里-应用-强制停止时，APP进程可能就直接被干掉了，onDestroy方法都进不来，所以还是无法保证 监听系统广播判断Service状态 通过系统的一些广播，比如：手机重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的Service是否还存活，别忘记加权限 【结论】这也能算是一种措施，不过感觉监听多了会导致Service很混乱，带来诸多不便 在JNI层,用C代码fork一个进程出来 这样产生的进程,会被系统认为是两个不同的进程.但是Android5.0之后可能不行 root之后放到system/app变成系统级应用 大招: 放一个像素在前台(手机QQ) 动画有哪两类，各有什么特点？三种动画的区别 tween 补间动画。通过指定View的初末状态和变化时间、方式，对View的内容完成一系列的图形变换来实现动画效果。AlphaScaleTranslateRotate。 frame 帧动画AnimationDrawable 控制animation-list xml布局 PropertyAnimation 属性动画 Android的数据存储形式。 SQLite：SQLite是一个轻量级的数据库，支持基本的SQL语法，是常被采用的一种数据存储方式。Android为此数据库提供了一个名为SQLiteDatabase的类，封装了一些操作数据库的api SharedPreference： 除SQLite数据库外，另一种常用的数据存储方式，其本质就是一个xml文件，常用于存储较简单的参数设置。 File： 即常说的文件（I/O）存储方法，常用语存储大数量的数据，但是缺点是更新数据将是一件困难的事情。 ContentProvider: Android系统中能实现所有应用程序共享的一种数据存储方式，由于数据通常在各应用间的是互相私密的，所以此存储方式较少使用，但是其又是必不可少的一种存储方式。例如音频，视频，图片和通讯录，一般都可以采用此种方式进行存储。每个Content Provider都会对外提供一个公共的URI（包装成Uri对象），如果应用程序有数据需要共享时，就需要使用Content Provider为这些数据定义一个URI，然后其他的应用程序就通过Content Provider传入这个URI来对数据进行操作。 Sqlite的基本操作。 http://blog.csdn.net/zgljl2012/article/details/44769043 如何判断应用被强杀 在Application中定义一个static常量，赋值为－1，在欢迎界面改为0，如果被强杀，application重新初始化，在父类Activity判断该常量的值。 应用被强杀如何解决 如果在每一个Activity的onCreate里判断是否被强杀，冗余了，封装到Activity的父类中，如果被强杀，跳转回主界面，如果没有被强杀，执行Activity的初始化操作，给主界面传递intent参数，主界面会调用onNewIntent方法，在onNewIntent跳转到欢迎页面，重新来一遍流程。 Json有什么优劣势。 怎样退出终止App Asset目录与res目录的区别。res 目录下面有很多文件，例如 drawable,mipmap,raw 等。res 下面除了 raw 文件不会被压缩外，其余文件都会被压缩。同时 res目录下的文件可以通过R 文件访问。Asset 也是用来存储资源，但是 asset 文件内容只能通过路径或者 AssetManager 读取。 官方文档 Android怎么加速启动Activity。分两种情况，启动应用 和 普通Activity启动应用 ：Application 的构造方法，onCreate 方法中不要进行耗时操作，数据预读取(例如 init 数据) 放在异步中操作启动普通的Activity：A 启动B 时不要在 A 的 onPause 中执行耗时操作。因为 B 的 onResume 方法必须等待 A 的 onPause 执行完成后才能运行 Android内存优化方法：ListView优化，及时关闭资源，图片缓存等等。 Android中弱引用与软引用的应用场景。 Bitmap的四种属性，与每种属性队形的大小。 View与View Group分类。自定义View过程：onMeasure()、onLayout()、onDraw()。 如何自定义控件： 自定义属性的声明和获取 分析需要的自定义属性 在res/values/attrs.xml定义声明 在layout文件中进行使用 在View的构造方法中进行获取 测量onMeasure 布局onLayout(ViewGroup) 绘制onDraw onTouchEvent onInterceptTouchEvent(ViewGroup) 状态的恢复与保存 Android长连接，怎么处理心跳机制。 View树绘制流程 下拉刷新实现原理 你用过什么框架，是否看过源码，是否知道底层原理。 Retrofit EventBus glide Android5.0、6.0新特性。 Android5.0新特性： MaterialDesign设计风格 支持多种设备 支持64位ART虚拟机 Android6.0新特性 大量漂亮流畅的动画 支持快速充电的切换 支持文件夹拖拽应用 相机新增专业模式 Android7.0新特性 分屏多任务 增强的Java8语言模式 夜间模式 Context区别 Activity和Service以及Application的Context是不一样的,Activity继承自ContextThemeWraper.其他的继承自ContextWrapper 每一个Activity和Service以及Application的Context都是一个新的ContextImpl对象 getApplication()用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法，getApplicationContext()比getApplication()方法的作用域会更广一些，任何一个Context的实例，只要调用getApplicationContext()方法都可以拿到我们的Application对象。 Activity在创建的时候会new一个ContextImpl对象并在attach方法中关联它，Application和Service也差不多。ContextWrapper的方法内部都是转调ContextImpl的方法 创建对话框传入Application的Context是不可以的 尽管Application、Activity、Service都有自己的ContextImpl，并且每个ContextImpl都有自己的mResources成员，但是由于它们的mResources成员都来自于唯一的ResourcesManager实例，所以它们看似不同的mResources其实都指向的是同一块内存 Context的数量等于Activity的个数 + Service的个数 + 1，这个1为Application IntentService的使用场景与特点。 IntentService是Service的子类，是一个异步的，会自动停止的服务，很好解决了传统的Service中处理完耗时操作忘记停止并销毁Service的问题 优点： 一方面不需要自己去new Thread 另一方面不需要考虑在什么时候关闭该Service onStartCommand中回调了onStart，onStart中通过mServiceHandler发送消息到该handler的handleMessage中去。最后handleMessage中回调onHandleIntent(intent)。 图片缓存 查看每个应用程序最高可用内存： 12int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); Log.d("TAG", "Max memory is " + maxMemory + "KB"); Gradle 构建工具、Groovy语法、Java Jar包里面只有代码，aar里面不光有代码还包括代码还包括资源文件，比如 drawable 文件，xml 资源文件。对于一些不常变动的 Android Library，我们可以直接引用 aar，加快编译速度 你是如何自学Android 首先是看书和看视频敲代码，然后看大牛的博客，做一些项目，向github提交代码，觉得自己API掌握的不错之后，开始看进阶的书，以及看源码，看完源码学习到一些思想，开始自己造轮子，开始想代码的提升，比如设计模式，架构，重构等。]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 内存泄漏总结]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2FAndroid%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Android 内存泄漏总结内存管理的目的就是让我们在开发中怎么有效的避免我们的应用出现内存泄漏的问题。内存泄漏大家都不陌生了，简单粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。最近自己阅读了大量相关的文档资料，打算做个 总结 沉淀下来跟大家一起分享和学习，也给自己一个警示，以后 coding 时怎么避免这些情况，提高应用的体验和质量。 我会从 java 内存泄漏的基础知识开始，并通过具体例子来说明 Android 引起内存泄漏的各种原因，以及如何利用工具来分析应用内存泄漏，最后再做总结。 Java 内存分配策略Java 程序运行时的内存分配策略有三种,分别是静态分配,栈式分配,和堆式分配，对应的，三种存储策略使用的内存空间主要分别是静态存储区（也称方法区）、栈区和堆区。 静态存储区（方法区）：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。 栈区 ：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 堆区 ： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。 栈与堆的区别：在方法体内定义的（局部变量）一些基本类型的变量和对象的引用变量都是在方法的栈内存中分配的。当在一段方法块中定义一个变量时，Java 就会在栈中为该变量分配内存空间，当超过该变量的作用域后，该变量也就无效了，分配给它的内存空间也将被释放掉，该内存空间可以被重新使用。 堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组。在堆中分配的内存，将由 Java 垃圾回收器来自动管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，这个特殊的变量就是我们上面说的引用变量。我们可以通过这个引用变量来访问堆中的对象或者数组。 举个例子: 1234567891011public class Sample &#123; int s1 = 0; Sample mSample1 = new Sample(); public void method() &#123; int s2 = 1; Sample mSample2 = new Sample(); &#125;&#125;Sample mSample3 = new Sample(); Sample 类的局部变量 s2 和引用变量 mSample2 都是存在于栈中，但 mSample2 指向的对象是存在于堆上的。mSample3 指向的对象实体存放在堆上，包括这个对象的所有成员变量 s1 和 mSample1，而它自己存在于栈中。 结论： 局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中。—— 因为它们属于方法中的变量，生命周期随方法而结束。 成员变量全部存储与堆中（包括基本数据类型，引用和引用的对象实体）—— 因为它们属于类，类对象终究是要被new出来使用的。 了解了 Java 的内存分配之后，我们再来看看 Java 是怎么管理内存的。 Java是如何管理内存Java的内存管理就是对象的分配和释放问题。在 Java 中，程序员需要通过关键字 new 为每个对象申请内存空间 (基本类型除外)，所有的对象都在堆 (Heap)中分配空间。另外，对象的释放是由 GC 决定和执行的。在 Java 中，内存的分配是由程序完成的，而内存的释放是由 GC 完成的，这种收支两条线的方法确实简化了程序员的工作。但同时，它也加重了JVM的工作。这也是 Java 程序运行速度较慢的原因之一。因为，GC 为了能够正确释放对象，GC 必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC 都需要进行监控。 监视对象状态是为了更加准确地、及时地释放对象，而释放对象的根本原则就是该对象不再被引用。 为了更好理解 GC 的工作原理，我们可以将对象考虑为有向图的顶点，将引用关系考虑为图的有向边，有向边从引用者指向被引对象。另外，每个线程对象可以作为一个图的起始顶点，例如大多程序从 main 进程开始执行，那么该图就是以 main 进程顶点开始的一棵根树。在这个有向图中，根顶点可达的对象都是有效对象，GC将不回收这些对象。如果某个对象 (连通子图)与这个根顶点不可达(注意，该图为有向图)，那么我们认为这个(这些)对象不再被引用，可以被 GC 回收。以下，我们举一个例子说明如何用有向图表示内存管理。对于程序的每一个时刻，我们都有一个有向图表示JVM的内存分配情况。以下右图，就是左边程序运行到第6行的示意图。 Java使用有向图的方式进行内存管理，可以消除引用循环的问题，例如有三个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的。这种方式的优点是管理内存的精度很高，但是效率较低。另外一种常用的内存管理技术是使用计数器，例如COM模型采用计数器方式管理构件，它与有向图相比，精度行低(很难处理循环引用的问题)，但执行效率很高。 什么是Java中的内存泄露在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。 在C++中，内存泄漏的范围更大一些。有些对象被分配了内存空间，然后却不可达，由于C++中没有GC，这些内存将永远收不回来。在Java中，这些不可达的对象都由GC负责回收，因此程序员不需要考虑这部分的内存泄露。 通过分析，我们得知，对于C++，程序员需要自己管理边和顶点，而对于Java程序员只需要管理边就可以了(不需要管理顶点的释放)。通过这种方式，Java提高了编程的效率。 因此，通过以上分析，我们知道在Java中也有内存泄漏，但范围比C++要小一些。因为Java从语言上保证，任何对象都是可达的，所有的不可达对象都由GC管理。 对于程序员来说，GC基本是透明的，不可见的。虽然，我们只有几个函数可以访问GC，例如运行GC的函数System.gc()，但是根据Java语言规范定义， 该函数不保证JVM的垃圾收集器一定会执行。因为，不同的JVM实现者可能使用不同的算法管理GC。通常，GC的线程的优先级别较低。JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些。除非在一些特定的场合，GC的执行影响应用程序的性能，例如对于基于Web的实时系统，如网络游戏等，用户不希望GC突然中断应用程序执行而进行垃圾回收，那么我们需要调整GC的参数，让GC能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行，Sun提供的HotSpot JVM就支持这一特性。 同样给出一个 Java 内存泄漏的典型例子， 123456Vector v = new Vector(10);for (int i = 1; i &lt; 100; i++) &#123; Object o = new Object(); v.add(o); o = null; &#125; 在这个例子中，我们循环申请Object对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。 详细Java中的内存泄漏 1.Java内存回收机制 不论哪种语言的内存分配方式，都需要返回所分配内存的真实地址，也就是返回一个指针到内存块的首地址。Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控，Java会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收，这样也可以消除引用循环的问题。在Java语言中，判断一个内存空间是否符合垃圾收集标准有两个：一个是给对象赋予了空值null，以下再没有调用过，另一个是给对象赋予了新值，这样重新分配了内存空间。 2.Java内存泄漏引起的原因 内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。j Java内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。具体主要有如下几大类： 1、静态集合类引起内存泄漏： 像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。 例如 1234567Static Vector v = new Vector(10);for (int i = 1; i&lt;100; i++)&#123;Object o = new Object();v.add(o);o = null;&#125; 在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。 2、当集合里面的对象属性被修改后，再调用remove()方法时不起作用。 例如： 123456789101112131415161718192021public static void main(String[] args)&#123;Set&lt;Person&gt; set = new HashSet&lt;Person&gt;();Person p1 = new Person("唐僧","pwd1",25);Person p2 = new Person("孙悟空","pwd2",26);Person p3 = new Person("猪八戒","pwd3",27);set.add(p1);set.add(p2);set.add(p3);System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:3 个元素!p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变set.remove(p3); //此时remove不掉，造成内存泄漏set.add(p3); //重新添加，居然添加成功System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:4 个元素!for (Person person : set)&#123;System.out.println(person);&#125;&#125; 3、监听器 在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。 4、各种连接 比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。 5、内部类和外部模块的引用 内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：public void registerMsg(Object b);这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。 6、单例模式 不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏，考虑下面的例子： 12345678910111213141516171819class A&#123;public A()&#123;B.getInstance().setA(this);&#125;....&#125;//B类采用单例模式class B&#123;private A a;private static B instance=new B();public B()&#123;&#125;public static B getInstance()&#123;return instance;&#125;public void setA(A a)&#123;this.a=a;&#125;//getter...&#125; 显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况 Android中常见的内存泄漏汇总 集合类泄漏集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量 (比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它)，那么没有相应的删除机制，很可能导致集合所占用的内存只增不减。比如上面的典型例子就是其中一种情况，当然实际上我们在项目中肯定不会写这么 2B 的代码，但稍不注意还是很容易出现这种情况，比如我们都喜欢通过 HashMap 做一些缓存之类的事，这种情况就要多留一些心眼。 单例造成的内存泄漏由于单例的静态特性使得其生命周期跟应用的生命周期一样长，所以如果使用不恰当的话，很容易造成内存泄漏。比如下面一个典型的例子， 12345678910111213public class AppManager &#123;private static AppManager instance;private Context context;private AppManager(Context context) &#123;this.context = context;&#125;public static AppManager getInstance(Context context) &#123;if (instance == null) &#123;instance = new AppManager(context);&#125;return instance;&#125;&#125; 这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个Context，所以这个Context的生命周期的长短至关重要： 1、如果此时传入的是 Application 的 Context，因为 Application 的生命周期就是整个应用的生命周期，所以这将没有任何问题。 2、如果此时传入的是 Activity 的 Context，当这个 Context 所对应的 Activity 退出时，由于该 Context 的引用被单例对象所持有，其生命周期等于整个应用程序的生命周期，所以当前 Activity 退出时它的内存并不会被回收，这就造成泄漏了。 正确的方式应该改为下面这种方式： 12345678910111213public class AppManager &#123;private static AppManager instance;private Context context;private AppManager(Context context) &#123;this.context = context.getApplicationContext();// 使用Application 的context&#125;public static AppManager getInstance(Context context) &#123;if (instance == null) &#123;instance = new AppManager(context);&#125;return instance;&#125;&#125; 或者这样写，连 Context 都不用传进来了： 12345678910111213141516171819202122232425262728在你的 Application 中添加一个静态方法，getContext() 返回 Application 的 context，...context = getApplicationContext();... /** * 获取全局的context * @return 返回全局context对象 */ public static Context getContext()&#123; return context; &#125;public class AppManager &#123;private static AppManager instance;private Context context;private AppManager() &#123;this.context = MyApplication.getContext();// 使用Application 的context&#125;public static AppManager getInstance() &#123;if (instance == null) &#123;instance = new AppManager();&#125;return instance;&#125;&#125; 匿名内部类/非静态内部类和异步线程非静态内部类创建静态实例造成的内存泄漏 有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法： 123456789101112131415public class MainActivity extends AppCompatActivity &#123;private static TestResource mResource = null;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);setContentView(R.layout.activity_main);if(mManager == null)&#123;mManager = new TestResource();&#125;//...&#125;class TestResource &#123;//...&#125;&#125; 这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。正确的做法为： 将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请按照上面推荐的使用Application 的 Context。当然，Application 的 context 不是万能的，所以也不能随便乱用，对于有些地方则必须使用 Activity 的 Context，对于Application，Service，Activity三者的Context的应用场景如下： 其中： NO1表示 Application 和 Service 可以启动一个 Activity，不过需要创建一个新的 task 任务队列。而对于 Dialog 而言，只有在 Activity 中才能创建 匿名内部类android开发经常会继承实现Activity/Fragment/View，此时如果你使用了匿名类，并被异步线程持有了，那要小心了，如果没有任何措施这样一定会导致泄露 1234567891011public class MainActivity extends Activity &#123;...Runnable ref1 = new MyRunable();Runnable ref2 = new Runnable() &#123; @Override public void run() &#123; &#125;&#125;; ...&#125; ref1和ref2的区别是，ref2使用了匿名内部类。我们来看看运行时这两个引用的内存： 可以看到，ref1没什么特别的。 但ref2这个匿名类的实现对象里面多了一个引用： this$0这个引用指向MainActivity.this，也就是说当前的MainActivity实例会被ref2持有，如果将这个引用再传入一个异步线程，此线程和此Acitivity生命周期不一致的时候，就造成了Activity的泄露。 Handler 造成的内存泄漏Handler 的使用造成的内存泄漏问题应该说是最为常见了，很多时候我们为了避免 ANR 而不在主线程进行耗时操作，在处理网络任务或者封装一些请求回调等api都借助Handler来处理，但 Handler 不是万能的，对于 Handler 的使用代码编写一不规范即有可能造成内存泄漏。另外，我们知道 Handler、Message 和 MessageQueue 都是相互关联在一起的，万一 Handler 发送的 Message 尚未被处理，则该 Message 及发送它的 Handler 对象将被线程 MessageQueue 一直持有。 由于 Handler 属于 TLS(Thread Local Storage) 变量, 生命周期和 Activity 是不一致的。因此这种实现方式一般很难保证跟 View 或者 Activity 的生命周期保持一致，故很容易导致无法正确释放。 举个例子： 1234567891011121314151617181920212223public class SampleActivity extends Activity &#123;private final Handler mLeakyHandler = new Handler() &#123;@Overridepublic void handleMessage(Message msg) &#123; // ...&#125;&#125;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);// Post a message and delay its execution for 10 minutes.mLeakyHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; /* ... */ &#125;&#125;, 1000 * 60 * 10);// Go back to the previous Activity.finish();&#125;&#125; 在该 SampleActivity 中声明了一个延迟10分钟执行的消息 Message，mLeakyHandler 将其 push 进了消息队列 MessageQueue 里。当该 Activity 被 finish() 掉时，延迟执行任务的 Message 还会继续存在于主线程中，它持有该 Activity 的 Handler 引用，所以此时 finish() 掉的 Activity 就不会被回收了从而造成内存泄漏（因 Handler 为非静态内部类，它会持有外部类的引用，在这里就是指 SampleActivity）。 修复方法：在 Activity 中避免使用非静态内部类，比如上面我们将 Handler 声明为静态的，则其存活期跟 Activity 的生命周期就无关了。同时通过弱引用的方式引入 Activity，避免直接将 Activity 作为 context 传进去，见下面代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SampleActivity extends Activity &#123; /** * Instances of static inner classes do not hold an implicit * reference to their outer class. */ private static class MyHandler extends Handler &#123; private final WeakReference&lt;SampleActivity&gt; mActivity; public MyHandler(SampleActivity activity) &#123; mActivity = new WeakReference&lt;SampleActivity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; SampleActivity activity = mActivity.get(); if (activity != null) &#123; // ... &#125; &#125; &#125; private final MyHandler mHandler = new MyHandler(this); /** * Instances of anonymous classes do not hold an implicit * reference to their outer class when they are "static". */ private static final Runnable sRunnable = new Runnable() &#123; @Override public void run() &#123; /* ... */ &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Post a message and delay its execution for 10 minutes. mHandler.postDelayed(sRunnable, 1000 * 60 * 10); // Go back to the previous Activity. finish(); &#125;&#125; 综述，即推荐使用静态内部类 + WeakReference 这种方式。每次使用前注意判空。 前面提到了 WeakReference，所以这里就简单的说一下 Java 对象的几种引用类型。 Java对引用的分类有 Strong reference, SoftReference, WeakReference, PhatomReference 四种。 在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术。 软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清除已失效的软/弱引用。 假设我们的应用会用到大量的默认图片，比如应用中有默认的头像，默认游戏图标等等，这些图片很多地方会用到。如果每次都去读取图片，由于读取文件需要硬件操作，速度较慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生OutOfMemory异常。这时，我们可以考虑使用软/弱引用技术来避免这个问题发生。以下就是高速缓冲器的雏形： 首先定义一个HashMap，保存软引用对象。 1private Map &lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap &lt;String, SoftReference&lt;Bitmap&gt;&gt; (); 再来定义一个方法，保存Bitmap的软引用到HashMap。 使用软引用以后，在OutOfMemory异常发生之前，这些缓存的图片资源的内存空间可以被释放掉的，从而避免内存达到上限，避免Crash发生。 如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。 另外可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。 ok，继续回到主题。前面所说的，创建一个静态Handler内部类，然后对 Handler 持有的对象使用弱引用，这样在回收时也可以回收 Handler 持有的对象，但是这样做虽然避免了 Activity 泄漏，不过 Looper 线程的消息队列中还是可能会有待处理的消息，所以我们在 Activity 的 Destroy 时或者 Stop 时应该移除消息队列 MessageQueue 中的消息。 下面几个方法都可以移除 Message： 123456789public final void removeCallbacks(Runnable r);public final void removeCallbacks(Runnable r, Object token);public final void removeCallbacksAndMessages(Object token);public final void removeMessages(int what);public final void removeMessages(int what, Object object); 尽量避免使用 static 成员变量如果成员变量被声明为 static，那我们都知道其生命周期将与整个app进程生命周期一样。 这会导致一系列问题，如果你的app进程设计上是长驻内存的，那即使app切到后台，这部分内存也不会被释放。按照现在手机app内存管理机制，占内存较大的后台进程将优先回收，yi’wei如果此app做过进程互保保活，那会造成app在后台频繁重启。当手机安装了你参与开发的app以后一夜时间手机被消耗空了电量、流量，你的app不得不被用户卸载或者静默。 这里修复的方法是： 不要在类初始时初始化静态成员。可以考虑lazy初始化。架构设计上要思考是否真的有必要这样做，尽量避免。如果架构需要这么设计，那么此对象的生命周期你有责任管理起来。 避免 override finalize()1、finalize 方法被执行的时间不确定，不能依赖与它来释放紧缺的资源。时间不确定的原因是： 虚拟机调用GC的时间不确定 Finalize daemon线程被调度到的时间不确定 2、finalize 方法只会被执行一次，即使对象被复活，如果已经执行过了 finalize 方法，再次被 GC 时也不会再执行了，原因是： 含有 finalize 方法的 object 是在 new 的时候由虚拟机生成了一个 finalize reference 在来引用到该Object的，而在 finalize 方法执行的时候，该 object 所对应的 finalize Reference 会被释放掉，即使在这个时候把该 object 复活(即用强引用引用住该 object )，再第二次被 GC 的时候由于没有了 finalize reference 与之对应，所以 finalize 方法不会再执行。 3、含有Finalize方法的object需要至少经过两轮GC才有可能被释放。 资源未关闭造成的内存泄漏对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。 一些不良代码造成的内存压力有些代码并不造成内存泄露，但是它们，或是对没使用的内存没进行有效及时的释放，或是没有有效的利用已有的对象而是频繁的申请新内存。 比如： Bitmap 没调用 recycle()方法，对于 Bitmap 对象在不使用时,我们应该先调用 recycle() 释放内存，然后才它设置为 null. 因为加载 Bitmap 对象的内存空间，一部分是 java 的，一部分 C 的（因为 Bitmap 分配的底层是通过 JNI 调用的 )。 而这个 recyle() 就是针对 C 部分的内存释放。 构造 Adapter 时，没有使用缓存的 convertView ,每次都在创建新的 converView。这里推荐使用 ViewHolder。 总结对 Activity 等组件的引用应该控制在 Activity 的生命周期之内； 如果不能就考虑使用 getApplicationContext 或者 getApplication，以避免 Activity 被外部长生命周期的对象引用而泄露。 尽量不要在静态变量或者静态内部类中使用非静态外部成员变量（包括context )，即使要使用，也要考虑适时把外部成员变量置空；也可以在内部类中使用弱引用来引用外部类的变量。 对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做避免内存泄漏： 将内部类改为静态内部类 静态内部类中使用弱引用来引用外部类的成员变量 Handler 的持有的引用对象最好使用弱引用，资源释放时也可以清空 Handler 里面的消息。比如在 Activity onStop 或者 onDestroy 的时候，取消掉该 Handler 对象的 Message和 Runnable. 在 Java 的实现过程中，也要考虑其对象释放，最好的方法是在不使用某对象时，显式地将此对象赋值为 null，比如使用完Bitmap 后先调用 recycle()，再赋为null,清空对图片等资源有直接引用或者间接引用的数组（使用 array.clear() ; array = null）等，最好遵循谁创建谁释放的原则。 正确关闭资源，对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销。 保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期。]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[框架源码分析]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2F%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[框架源码分析 Retrofit EventBus Glide]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[事件分发机制]]></title>
    <url>%2F2019%2F05%2F11%2FGuideBook%2FAndroid%2F%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[事件分发机制 对于一个根ViewGroup来说,发生点击事件首先调用dispatchTouchEvent 如果这个ViewGroup的onIterceptTouchEvent返回true就表示它要拦截当前事件,接着这个ViewGroup的onTouchEvent就会被调用.如果onIterceptTouchEvent返回false,那么就会继续向下调用子View的dispatchTouchEvent方法 当一个View需要处理事件的时候,如果它没有设置onTouchListener,那么直接调用onTouchEvent.如果设置了Listenter 那么就要看Listener的onTouch方法返回值.为true就不调,为false就调onTouchEvent View的默认实现会在onTouchEvent里面把touch事件解析成Click之类的事件 点击事件传递顺序 Activity -&gt; Window -&gt; View 一旦一个元素拦截了某事件,那么一个事件序列里面后续的Move,Down事件都会交给它处理.并且它的onInterceptTouchEvent不会再调用 View的onTouchEvent默认都会消耗事件,除非它的clickable和longClickable都是false(不可点击),但是enable属性不会影响]]></content>
      <categories>
        <category>GuideBook</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[软工经验汇总：]]></title>
    <url>%2F2019%2F05%2F11%2FMess%2F%E8%BD%AF%E5%B7%A5%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB%EF%BC%9A%2F</url>
    <content type="text"><![CDATA[软工经验汇总： 保存每次的会议记录，每次开会找一个会议记录员（Q&amp;A，ToDoList，讨论内容。目标，讨论结果，分工安排 项目初期寻找一个合适的项目管理平台，包括项目需求跟踪、任务完成进度等等 找文档的模版！ 工作量的合理预估！给一个弹性的时间！（哭了，忽略的前后端的整合让人头秃 阶段性的项目检查！（比如，前端的孩子写的是纯静态的，使用的位置都是绝对位置，后期调起来相当不方便 找相关的工具： 项目进度：ones.ai 讨论：在线腾讯文档 uml绘制：staruml 开发工具，求问有没有代码直接导出图的 数据库图：powerDesign]]></content>
      <categories>
        <category>Mess</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面试]]></title>
    <url>%2F2019%2F05%2F11%2FMess%2F%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[面试 TCP协议中第三次握手失败会怎样？ http和https区别，为什么https安全，（答了数据加密），加密过程，对称还是非对称 安卓activity生命周期 安卓跨进程通信，进程间通信机制 事务的特性，描述一下一致性是什么 除了关系型数据库，对于其他的数据库还有什么了解吗 C++的new和malloc有什么区别 多态是如何实现的 图的遍历方式，怎么遍历 排序方法，哪个最慢，哪个最费空间，哪个最不费空间 leetcode53，用了动规，问你觉得这个方法的分治思想体现在哪 to know： web： android 数据库： C++： 算法： 面试经验小结？ 明确一下自己面试的岗位需要什么技能？ 比如我面后台会问数据库、操作系统、服务器、C++相关的知识 看面经，有些问题重复率还是蛮高的，可以预先想一下答案，总归有点谱 面经大概主要看： 面试流程 面试题目 对了面试完之后如果面试官说有什么问题想问他的，可以问一下自己的面试表现如何，还有什么技能需要提升之类，表达一下自己的好学之心！ 针对简历 我们一般会问自己在简历上的经历，简历上的项目，会细致问自己写的项目]]></content>
      <categories>
        <category>Mess</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CNN]]></title>
    <url>%2F2019%2F05%2F11%2FSLAM%2FCNN%2F</url>
    <content type="text"><![CDATA[CNN 卷积层原图像经过卷积模版之后得到的？ 池化层这里再展开叙述池化层的具体作用。 特征不变性，也就是我们在图像处理中经常提到的特征的尺度不变性，池化操作就是图像的resize，平时一张狗的图像被缩小了一倍我们还能认出这是一张狗的照片，这说明这张图像中仍保留着狗最重要的特征，我们一看就能判断图像中画的是一只狗，图像压缩时去掉的信息只是一些无关紧要的信息，而留下的信息则是具有尺度不变性的特征，是最能表达图像的特征。 特征降维，我们知道一幅图像含有的信息是很大的，特征也很多，但是有些信息对于我们做图像任务时没有太多用途或者有重复，我们可以把这类冗余信息去除，把最重要的特征抽取出来，这也是池化操作的一大作用。 在一定程度上防止过拟合，更方便优化。 激活函数 全连接层 卷积神经网络之 fine-tuning何谓fine-tuning？fine-tuning就是使用已用于其他目标、预训练好模型的权重或者部分权重，作为初始值开始训练。 那为什么我们不用随机选取选几个数作为权重初始值？原因很简单，第一，自己从头训练卷积神经网络容易出现问题；第二，fine-tuning能很快收敛到一个较理想的状态，省时又省心。 那fine-tuning的具体做法是？ • 复用相同层的权重，新定义层取随机权重初始值 • 调大新定义层的的学习率，调小复用层学习率]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[R-CNN]]></title>
    <url>%2F2019%2F05%2F11%2FSLAM%2FR-CNN%2F</url>
    <content type="text"><![CDATA[R-CNNR-CNN论文解析]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SLAM]]></title>
    <url>%2F2019%2F05%2F11%2FSLAM%2FSLAM%2F</url>
    <content type="text"><![CDATA[SLAM漫谈SLAM技术（上） 漫谈SLAM技术（下） SLAM技术在国内的发展现状 SLAM介绍（算法基本流程） 详细分析SLAM的实现和应用 特征点的匹配 列举几个目前比较有名的SLAM算法：PTAM,MonoSLAM, ORB-SLAM,RGBD-SLAM,RTAB-SLAM,LSD-SLAM。 SLAM的两大类别： 根据传感器类别（激光雷达和摄像头）分为激光SLAM和视觉SLAM 传感器： 激光雷达：单线多线 摄像头：单目、双目、单目结构光、双目结构光、ToF 不同相机的区别？ 基于单目、双目、全景相机的算法？ IMU 名词介绍：1、视觉SLAM方法：（1）图像信息使用 视觉SLAM方法根据使用图像信息的不同可分为直接法，间接法。 直接法，常见于稠密或半稠密的SLAM中，指的是采用图像上每个像素的信息（亮度值）来估计相机位姿；间接法，常用于稀疏的SLAM中，只使用显著的图像部位（即特征）用于位姿估计的计算。 直接法最基本的原理是亮度一致性约束，由于摄像机可以直接测量光的亮度，那么它的优化目标函数是光度误差（如下图），优化变量可以是两幅图像之间的位姿关系，也可以是特征Patch的位置。 根据直接法使用的像素的不同，可以分为稠密直接法和半稠密直接法。在上述介绍的SLAM系统中，DTAM为稠密直接法，它使用了所有的像素；LSD-SLAM和DSO为半稠密直接法，它使用了梯度明显的像素；SVO也为半稠密直接法，它使用了FAST特征点周围邻域的像素。直接方法较多的使用了图像上像素的信息，在纹理较差的部分比间接法更鲁棒。但当场景中的光照变化后，直接法容易失效，亮度一致性约束要求两幅图像之间的光度误差尽可能地小。 间接法使用图像中的特征（点或者线）进行匹配，然后根据匹配关系求解（如下图），它的优化目标函数是特征的重投影误差，优化的变量一般为相对位姿。间接法选取的特征一般要求比较显著，对视角和光照变化具有不变性，对模糊和噪声有一定的弹性，这需要在计算速度和特征质量上取得平衡。计算机视觉领域研究了很多不同的特征提取和特征描述，它们对旋转、尺度不变，和计算速度的性能都不一样。选择合适的特征依赖于平台的计算能力，视觉SLAM算法运行的环境，还有图像的帧率。可选的角点提取器如Harris角点（Harris and Stephens, 1988）、Shi-Tomasi角点（Shi and Tomasi, 1994），FAST角点（Mair et al, 2010）等，特征描述包括但不限于BRIEF，BRISK，SURF，SIFT，FREAK，ORB和像素级别局部区块特征等。 2、角点提取器Harris 角点：Shi-Tomasi角点：Shi-Tomasi 算法是Harris 算法的改进。Harris 算法最原始的定义是将矩阵 M 的行列式值与 M 的迹相减，再将差值同预先给定的阈值进行比较。后来Shi 和Tomasi 提出改进的方法，若两个特征值中较小的一个大于最小阈值，则会得到强角点。 如上面第二幅图中，对自相关矩阵 M 进行特征值分析，产生两个特征值和两个特征方向向量。因为较大的不确定度取决于较小的特征值，也就是，所以通过寻找最小特征值的最大值来寻找好的特征点也就解释的通了。Shi 和Tomasi 的方法比较充分，并且在很多情况下可以得到比使用Harris 算法更好的结果。 FAST角点:Shi-Tomasi 算法是Harris 算法的改进。Harris 算法最原始的定义是将矩阵 M 的行列式值与 M 的迹相减，再将差值同预先给定的阈值进行比较。后来Shi 和Tomasi 提出改进的方法，若两个特征值中较小的一个大于最小阈值，则会得到强角点。 如上面第二幅图中，对自相关矩阵 M 进行特征值分析，产生两个特征值和两个特征方向向量。因为较大的不确定度取决于较小的特征值，也就是，所以通过寻找最小特征值的最大值来寻找好的特征点也就解释的通了。Shi 和Tomasi 的方法比较充分，并且在很多情况下可以得到比使用Harris 算法更好的结果。 3、特征描述SIFT提到特征点算法，首先就是大名鼎鼎的SIFT算法了。SIFT的全称是Scale Invariant Feature Transform，尺度不变特征变换，2004年由加拿大教授David G.Lowe提出的。SIFT特征对旋转、尺度缩放、亮度变化等保持不变性，是一种非常稳定的局部特征。SIFT算法主要有以下几个步骤： 高斯差分金字塔的构建使用组和层的结构构建了一个具有线性关系的金字塔（尺度空间），这样可以在连续的高斯核尺度上查找图像的特征点；另外，它使用一阶的高斯差分来近似高斯的拉普拉斯核，大大的减少了运算量。 尺度空间的极值检测及特征点的定位搜索上一步建立的高斯尺度空间，通过高斯差分来识别潜在的对尺度和旋转不变的特征点。但是，在离散空间中，局部极值点可能并不是真正意义的极值点，真正的极值点有可能落在离散点的间隙中，SIFT通过尺度空间DoG函数进行曲线拟合寻找极值点。 特征方向赋值基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向，后续的所有操作都是对于关键点的方向、尺度和位置进行变换，从而提供这些特征的不变性。 特征描述子的生成通过上面的步骤已经找到的SIFT特征点的位置、方向、尺度信息，最后使用一组向量来描述特征点及其周围邻域像素的信息。 SIFT算法中及包含了特征点的提取算法，也有如何生成描述子的算法，更进一步的SIFT算法介绍可参看SIFT特征详解 SURFSURF全称 Speeded Up Robust Features，是在SIFT算法的基础上提出的，主要针对SIFT算法运算速度慢，计算量大的缺点进行了改进。SURF的流程和SIFT比较类似，这些改进体现在以下几个方面： 特征点检测是基于Hessian矩阵，依据Hessian矩阵行列式的极值来定位特征点的位置。并且将Hession特征计算与高斯平滑结合在一起，两个操作通过近似处理得到一个核模板。 在构建尺度空间时，使用box filter与源图像卷积，而不是使用DoG算子。 SURF使用一阶Haar小波在x、y两个方向的响应作为构建特征向量的分布信息。 FAST特征点提取算法SIFT和SURF是非常好的，稳定的特征点算法，但运算速度是其一大弊端，无法做到实时的特征提取和匹配，其应用就有了很大的局限性。FAST特征提取算法弥补了这一局限，检测局部像素灰度变化明显的地方，以速度快而著称，其全称为：Features From Accelerated Segment Test。在FAST算法的思想很简单：如果一个像素与周围邻域的像素差别较大（过亮或者过暗），那么可以认为该像素是一个角点。和其他的特征点提取算法相比，FAST算法只需要比较像素和其邻域像素的灰度值大小，十分便捷。FAST算法提取角点的步骤： 在图像中选择像素p，假设其灰度值为：IpIp 设置一个阈值T，例如：IpIp的20% 选择p周围半径为3的圆上的16个像素，作为比较像素 假设选取的圆上有连续的N个像素大于Ip+TIp+T或者Ip−TIp−T，那么可以认为像素p就是一个特征点。（N通常取12，即为FAST-12；常用的还有FAST-9,FAST-11）。 FAST算法只检测像素的灰度值，其运算速度极快，同时不可避免的也有一些缺点 检测到的特征点过多并且会出现“扎堆”的现象。这可以在第一遍检测完成后，使用非最大值抑制（Non-maximal suppression），在一定区域内仅保留响应极大值的角点，避免角点集中的情况。 FAST提取到的角点没有方向和尺度信息 上面的介绍的SIFT和SURF算法都包含有各自的特征点描述子的计算方法，而FAST不包含特征点描述子的计算，仅仅只有特征点的提取方法，这就需要一个特征点描述方法来描述FAST提取到的特征点，以方便特征点的匹配。下面介绍一个专门的特征点描述子的计算算法。 BRIEF描述子BRIEF是一种二进制的描述子，其描述向量是0和1表示的二进制串。0和1表示特征点邻域内两个像素（p和q）灰度值的大小：如果p比q大则选择1，反正就取0。在特征点的周围选择128对这样的p和q的像素对，就得到了128维由0，1组成的向量。那么p和q的像素对是怎么选择的呢？通常都是按照某种概率来随机的挑选像素对的位置。BRIEF使用随机选点的比较，速度很快，而且使用二进制串表示最终生成的描述子向量，在存储以及用于匹配的比较时都是非常方便的，其和FAST的搭配起来可以组成非常快速的特征点提取和描述算法。 ORB算法ORB的全称是Oriented FAST and Rotated BRIEF，是目前来说非常好的能够进行的实时的图像特征提取和描述的算法，它改进了FAST特征提取算法，并使用速度极快的二进制描述子BRIEF。针对FAST特征提取的算法的一些确定，ORB也做了相应的改进。 使用非最大值抑制，在一定区域内仅仅保留响应极大值的角点，避免FAST提取到的角点过于集中。 FAST提取到的角点数量过多且不是很稳定，ORB中可以指定需要提取到的角点的数量N，然后对FAST提取到的角点分别计算Harris响应值，选择前N个具有最大响应值的角点作为最终提取到的特征点集合。 FAST提取到的角点不具有尺度信息，在ORB中使用图像金字塔，并且在每一层金字塔上检测角点，以此来保持尺度的不变性。 FAST提取到的角点不具有方向信息，在ORB中使用灰度质心法(Intensity Centroid)来保持特征的旋转不变性。 像素级别局部区块特征4、相机单目只需要一个操作数，获取深度图的原理不同。 双目需要两个操作数，双目视觉系统，是通过左右两个对齐的摄像机的成像结果，基于极限约束计算视差图，再由几何关系得到深度数据的，但是这样做的局限是：1、两个摄像机的位置距离限制了深度数据的获取。2、由于抖动等不稳定因素使得两个摄像机的对齐困难。 双目双目可以通过标定（几何）或实时匹配（视觉匹配）得到相机的（一般为相对的）位姿（稀疏点云）再通过匹配同名点，前方交会，得到深度。（摄影测量）根据核线和匹配代价，交会所有点，得到所有点深度。（密集匹配）各种密集匹配算法或策略和匹配代价，交会所有点，得到深度。 单目1.RGDB2.基于特征（如灭点特征）确定要求深度的对象，设计变换函数和相对应的变换参数，通过特征提取提取特征，根据特征计算变化参数，根据多个特征观测，估计得到变换函数，对对象使用变换函数计算其深度。 如，拍一个正方体，我已知其在物方的规则形态，如果在单目中也提取了此正方体的特征（如线特征），根据这个特征的成像结合透视成像关系，计算得到特征的变换函数，然后对整个正方体的每个像素，都带入这一特征关系，得到整个正方形的深度。3.深度学习 类型第二种，只不过，这个特征和函数我们都不显示的找到它，而是让超参去自己找，自己拟合，通过大量的样本训练 ，就可以得到近似的结果。 to do： SLAM发展的历史 关于SLAM的一些名词解释，输入输出是什么 视觉里程计、IMU 2d-2d对级几何 pnp，icp（输入输出、作用）， 要具体理解每个名称的意义 一些SLAM框架的介绍，各自的优劣比较 后端优化的方式（EKF， 数学推导式（式子参数的意义、怎么来的 雅可比矩阵是什么 opencv中常用的函数 k聚类 语义SLAM是什么 缩写的全称 参考：作者，论文名称，发表时间，发表刊物 SLAM部分： 历史发展，综述 基本原理：]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SLAM_0 SLAM for dummies]]></title>
    <url>%2F2019%2F05%2F11%2FSLAM%2FSLAM_0_forDummies%2F</url>
    <content type="text"><![CDATA[SLAM_0 SLAM for dummiesConcept: SLAM is concerned with the problem of building a map of an unknown environmentby a mobile robot while at the same time navigating the environment using the map. SLAM consists of: Landmark extraction Data association State estimation state update landmark update]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SLAM_2_矩阵相关知识]]></title>
    <url>%2F2019%2F05%2F11%2FSLAM%2FSLAM_2_%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[SLAM_2_矩阵相关知识参考： 矩阵分析，Roger A.Horn，Charles R.Johnson 矩阵分析与应用，张贤达 单应矩阵及其分解 SVD分解 本质矩阵及其分解 奇异值矩阵 最小二乘和随机采样一致性（RANSAC） 三角测量 啊啊啊啊！线代令人忧伤 ​]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mask R-CNN]]></title>
    <url>%2F2019%2F05%2F11%2FSLAM%2FMask%20R-CNN%2F</url>
    <content type="text"><![CDATA[Mask R-CNN1. Framework 2. Algorithm 首先，输入一幅你想处理的图片，然后进行对应的预处理操作，或者预处理后的图片； 然后，将其输入到一个预训练好的神经网络中（ResNeXt等）获得对应的feature map； 接着，对这个feature map中的每一点设定预定个的ROI，从而获得多个候选ROI； 接着，将这些候选的ROI送入RPN网络进行二值分类（前景或背景）和BB回归，过滤掉一部分候选的ROI； 接着，对这些剩下的ROI进行ROIAlign操作（即先将原图和feature map的pixel对应起来，然后将feature map和固定的feature对应起来）； 最后，对这些ROI进行分类（N类别分类）、BB回归和MASK生成（在每一个ROI里面进行FCN操作）。 3. Detail3.1 Faster-rcnn3.2 FCN3.3 ROIAlignReference]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SLAM_3_进度汇报]]></title>
    <url>%2F2019%2F05%2F11%2FSLAM%2FSLAM_3_%E8%BF%9B%E5%BA%A6%E6%B1%87%E6%8A%A5%2F</url>
    <content type="text"><![CDATA[SLAM_3_进度汇报ppt汇报内容： 符号定义：$t = 0 ,… ,N$ 时间内，机器人的位姿为：$x_0 , \dots , x_N$ ，同时有路标 $y_1, \dots , y_M$运动和观测方程记为： \begin{matrix}x_k = f(x_{k-1},u_k) + w_k \\ z_{k,j} = h(y_j,x_k) + v_{k,j} \end{matrix} \space \space k = 1,\dots ,N, j = 1,\dots,M去除噪声的理想情况下： \begin{matrix}x_k = f(x_{k-1},u_k) \\ z_{k,j} = h(y_j,x_k) \end{matrix} \space \space k = 1,\dots ,N, j = 1,\dots,M纯视觉SLAM（$z_{k,j}​$ 为像素坐标）： \begin{matrix} z_{k,j} = h(y_j,x_k) \end{matrix} \space \space k = 1,\dots ,N, j = 1,\dots,M纯视觉SLAM（$y_{k,j}$为相机坐标）： \begin{matrix} y'_{k,j} = h(y_j,x_k) \end{matrix} \space \space k = 1,\dots ,N, j = 1,\dots,M对于方程（4）已知任意两个量可求第三个量，$y_j，x_k​$ 待求 初始化：零时刻相机坐标与世界坐标重合，即 $y_{0,j} = y’_{0,j}$ 后端优化（考虑噪声影响）： \begin{matrix}x_k = f(x_{k-1},u_k) + w_k \\ z_{k,j} = h(y_j,x_k) + v_{k,j} \end{matrix} \space \space k = 1,\dots ,N, j = 1,\dots,M初始化已知3d信息——ICP——单目中，只得到像素坐标，二维和三维获取位姿——对级几何]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SoftwareManagement_ 0 overview]]></title>
    <url>%2F2019%2F05%2F11%2FSoftwareManagement%2FManagement_0%2F</url>
    <content type="text"><![CDATA[SoftwareManagement_ 0 overviewSoftware Engineering Management Cell: 15000215319 Email: caobuyang@tongji.edu.cn Success criteria Schedule Budget Scope General issues affecting most software Heterogeneity Business and social change Security wage microservers Project management knowledge areaScope management Risk management Time management Cost management Human Resources management Communications management Quality management Procurement management]]></content>
      <categories>
        <category>SoftwareManagement</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Concepts]]></title>
    <url>%2F2019%2F05%2F11%2FSLAM%2FbasicConcepts%2F</url>
    <content type="text"><![CDATA[Concepts1. Image ClassificationIt consists of classifying an image into one of many different categories. Known Dateset: ImageNet 2. LocalizationSimilar to classification, localization finds the location of a single object inside the image. Known Dateset: Application: smart scropping 3. Instance segmentation4. Object detectionObject detection is the problem of finding and classifying a variable number of objects on an image. 4.1 Practical uses Face detection Counting Visual Search Engine Aerial image analysis 4.2 Problems and challenges Variable number of objects sizing modeling 4.3 Classical approach4.4 Deep learning approach OverFeat R-CNN Fast R-CNN 5. Datasets Name # Images (trainval) # Classes Last updated ImageNet 450k 200 2015 COCO 120k 80 2014 Pascal VOC 12k 20 2012 Oxford-IIIT Pet 7k 37 2012 KITTI Vision 7k 3 2014 Detection: Authentication: Verifycation:]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Case Study]]></title>
    <url>%2F2019%2F05%2F11%2FSoftwareManagement%2FCaseStudy_0%2F</url>
    <content type="text"><![CDATA[Case Studyrisk Identification: Weather cooking fuel Transportation analysis: Plan: Monitor: 交通、决策、天气]]></content>
      <categories>
        <category>SoftwareManagement</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Management_1 Software Process]]></title>
    <url>%2F2019%2F05%2F11%2FSoftwareManagement%2FManagement_1%2F</url>
    <content type="text"><![CDATA[Management_1 Software ProcessSoftware process modelSoftware Processstructured process : such as waterfall model , Agile model etc basic activities: specification, development, validation and evolution Some modelswaterfall model incremetntal development reuse-oriented software engineering: the systems is assembled from existing components. May be plan-driven or agile. waterfallinflexible, Agile/scrumProcess activitiesCoping with changethe Rational Unified process1234graph LR inception--&gt;elaboration elaboration--&gt;construction construction--&gt;transaction configuration management]]></content>
      <categories>
        <category>SoftwareManagement</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SLAM_1 视觉SLAM十四讲]]></title>
    <url>%2F2019%2F05%2F11%2FSLAM%2FSLAM_1_%E8%A7%86%E8%A7%89SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2%2F</url>
    <content type="text"><![CDATA[SLAM_1 视觉SLAM十四讲第二讲：初识SLAM2.1 相机：2.1.1 相机的本质： 以二维投影形式记录了三维世界的信息 此过程丢掉了一个维度：距离 2.1.2 各类相机主要区别：有没有深度信息 单目：没有深度，必须通过移动相机产生深度 Moving View Stereo 双目：通过视差计算深度Stereo RGBD：通过物理方法测量深度 深度相机： 物理手段测量深度 结构光ToF 主动测量，功耗大 深度值较准确 量程较小，易受干扰 单目相机计算量比较大，需要初始化。单张图像不具备尺度信息。 2.1.3 相机公共点： 利用图像和场景的几何关系，计算相机运动和场景结构Motion &amp; Structure 三维空间的运动和结构 图像来自连续的视频 第三讲 ： 三维空间刚体运动向量： 内积、外积 Q：坐标系之间的转换？ 旋转矩阵 3.3、旋转向量，欧拉角Q：角轴描述旋转，和旋转矩阵的相互转换？ 描述两个坐标系之间的转换： 旋转矩阵 角轴 欧拉角（Z-Y-X轴分别转多少度）存在奇异性问题 3.4、四元数eigen开源库 第三讲课后习题 第四讲：李代数和李群第四讲课后习题 雅可比矩阵 第五讲：相机的成像第六讲：非线性优化关于函数的求导？ 第七讲：视觉里程计图像特征点性质： 可重复性 可区别性 高效率 本地性 特征点由关键点和描述子组成。 FAST角点检测 灰度质心法 快速近似最近邻（FLANN） RANSAC(随机采样一致性) 三角测量 7.7 3D-2D： PnP7.7.1 直接线性变换7.7.2 Bundle Adjustment7.9 3D-3D：ICP7.9.1 SVD矩阵的范数 第八讲：视觉里程计 2直接法Lucas-Kanade 光流]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SoftwareManagement_4 Risk management]]></title>
    <url>%2F2019%2F05%2F11%2FSoftwareManagement%2FManagement_4%2F</url>
    <content type="text"><![CDATA[SoftwareManagement_4 Risk managementrisk list]]></content>
      <categories>
        <category>SoftwareManagement</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Management_5 Software Economy]]></title>
    <url>%2F2019%2F05%2F11%2FSoftwareManagement%2FManagement_5%2F</url>
    <content type="text"><![CDATA[Management_5 Software Economy [ ] Exercise：explain goods and services in software scope in “what, how, for whom” [ ] Exercise: Economy as policy tool Q1: Goods are items that are tangible, such as pens, salt, apples, and hats. Services are activities provided by other people, who include doctors, lawn care workers, dentists, barbers, waiters, or online servers. Taken together, it is the production), distribution), and consumption) of goods and services which underpins all economic activity and trade. According to economic theory, consumption) of goods and services is assumed to provide utility (satisfaction) to the consumer or end-user, although businesses also consume goods and services in the course of producing other goods and services.#Channels_and_intermediaries) Difference: ownership intangibility Involvement quality evaluation of service inventories are absent time is very important in services]]></content>
      <categories>
        <category>SoftwareManagement</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Management_6]]></title>
    <url>%2F2019%2F05%2F11%2FSoftwareManagement%2FManagement_6%2F</url>
    <content type="text"><![CDATA[Management_6PreviewQuestions for thinking Referring the relationship of demand and supply, trying to think the law of software demand and supply. This exercises will be discussed in the next lessons. You should not submit this exercise to the teacher. Preview Chapter 2 Core Concepts and Principles Chapter 3 Why Platform Businesses Are Unlike Product or Service Businesses from the reference book“Platform Ecosystems Aligning Architecture, Governance, and Strategy, written by Amrit Tiwana. Exercise Clicker Questions of Chapter Four, in the file Ch04_Clicker Questions. 成本和费用]]></content>
      <categories>
        <category>SoftwareManagement</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ppt]]></title>
    <url>%2F2019%2F05%2F11%2FSoftwareManagement%2FMgtPro_1%2F</url>
    <content type="text"><![CDATA[pptto do: overview： 主要功能？应用领域？ 项目范围管理： 1. Overview 项目概述 将内容扩充，因为一些细节没有定义好，比如说系统功能没有那么明确，应用领域也不明确。 2. Inception 这部分我们的工作是： 确定利益相关者 -&gt; 向利益相关者提问 -&gt; 每个人阐述自己观点 -&gt; 确定项目内容等 其中用到的方法：Role play 提问式 requirements gathering:Types:User requirement definition:System requirement specification:Constraints:method: Role-play Scenario-based (describe by use case diagram) homogeneous comparison (amazon, dangdang) 3. Elicitation 这部分的工作： 利益相关者提取需求 -&gt; 开会审查需求 -&gt; 确定需求 -&gt; QFD -&gt; 初步场景建模? -&gt; 规约草稿 重点是： 利益相关者的观点提取成需求 QFDQFD 方法 FAQ： 不知道这个要不要考虑 • Stages include: Requirements discovery, Requirements classification and organization, Requirements prioritization and negotiation, Requirements specification 4. Elaboration 开发用例 -&gt; 构建分析模型 用例图？ 5. Negotiation 谈判条件(多少钱啊怎么的) 这个估计就是做做样子 6. Validation 这里我们可以挑几个问题讨论，然后给出问题及答案 Method: Requirement reviews prototyping test-case generation 7.?managementTo 8? 7. 文档内容123graph LRA(Overview &amp; Inception) --&gt; B(Introduction)C(others) --&gt; D(Overall Descripption &amp; External Interface Requirements &amp; ...) 附图]]></content>
      <categories>
        <category>SoftwareManagement</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MgtPro_3 requirement elicitation]]></title>
    <url>%2F2019%2F05%2F11%2FSoftwareManagement%2FMgtPro_3%2F</url>
    <content type="text"><![CDATA[MgtPro_3 requirement elicitationstep 3：prioritization需求排序维度模型：8个维度 排序方法：每个维度为10分制，最终结果为加权后求得的评估值。每个维度应有多人进行打分随后取平均值。 8个维度说明：1. 目标契合度（20%）目标对需求优先级的影响非常关键，因为目标体现了需求实现的最终价值。我们需要结合产品当前阶段和Roadmap，进行需求契合程度的判断。 2. 需求价值（10%） 需求价值分为用户价值，公司价值两块来分析，使用四象限法进行分数指标的确定。在不同的产品类型侧重的价值方向不同，所以究竟是用户价值更重要还是公司价值更重要是需要通过自己判断的。但如果两者都体现了很好的价值，那么评分自然可以较高。 3. Kano模型（10%） Kano模型是非常经典的判断模型，包含基本型需求&gt;期望型需求&gt;兴奋型需求 实际运用中需要根据现有需求的分布情况进行综合判断，有时期望形的需求可以比必须需求更重要。因为必须需求也要看用户群范围，如果必须需求的用户群并不大，或者现有产品阶段的必须需求覆盖面已经较广时，期望需求评分可以更高。 4. 重要紧急程度（10%） 重要紧急程度的分析可以运用在众多领域，包含重要且紧急&gt;重要不紧急&gt;紧急不重要&gt;不重要也不紧急。比较简单，不做赘述。 5. ROI投入产出比（20%）投入产出建议将投入分两部分进行分析，投入包含产品设计和产品实现两个阶段，这两个阶段有时并不会等价。产出也需要进行细致分析，因为通常而言，产出和时间的关系非常大，有些产品的长尾效应非常严重。 6. 需求来源（10%）需求来源也是一个参考维度，因为谁提的需求可以用来判断需求的真实场景和缘由。其中老板的需求，或者是用户直接的被验真的需求是最高分，但一定是要经过细致的需求分析，确认是真实需求的需求。其余像产品规划，用户非直接需求的分数相对较低。 7. 需求依赖（约束）（10%）这里的需求依赖主要指的是本需要求是否是其他需求的前置需求，或后置需求。这体现了开发中的前后排期关系，非常重要。一般包含前置需求的优先级 ＞ 后置需求的优先级；前置需求的重要性和紧迫性 ＞ 后置需求的重要性和紧迫性。 8. 技术风险（10%）开发的难度，可能出现的开发风险程度。注意工期过长，也会导致风险增加，所以只要开发上的不确定因素越多（如服务器资源，开源系统性能等），此值越低。 8个维度具体衡量标准及实际操作方法：1、目标契合度：首先明确产品的定位和市场的定位，随后确定核心要求。 2、需求价值：基于两点： 是否是核心用户的：人数*单用户价值 是否是刚性需求： 有无替代方案 发生频率 持续时间 3、KANO模型： 选取需求并选择适合的用户 与用户交流获得反馈 分析结果并进行需求排序 4、重要紧急程度：重要程度评判的原则： 1 不做会造成严重的问题和恶劣的影响的 2 做了会产生巨大好处和极佳效果的 3 跟重要合作对象或投资人有关的 4 跟核心用户利益有关的 5 跟大部分用户权益有关的 6 跟效率或成本有关的 7 跟用户体验有关的 判断紧急程度按照以下原则： 1 不做错误会持续发生，造成严重影响 2 在一定时间内可控，但长期会有糟糕的影响 3 做了立刻能解决很多问题、产生正面的影响 4 做了在一段时间后可以有良好的效果 5、ROI投入产出比：投入产出比主要考量效益和成本。效益可以包含直接收入，运营效率及推广成本，用户的效益等。成本主要是人力成本、时间成本和金钱成本等。潜在风险有时候也是未来的一种成本。较小的成本获取较高收益的需求一般优先级较高。 6、需求来源：需求的主要参与者 7、需求依赖：用例说明中，若该用例存在前置需求，则前置需求的优先级应高于后置需求的优先级。 8、技术风险：应由技术部门给出该部分的评估，可根据以下信息： 这个功能咱们能不能实现？ 能实现的话，需要多少人多长时间？ 有没有其他实现的建议或者方案？ 参考： 需求优先级排定的八个维度 KANO模型 网上书店行业市场调查分析报告 四象限法则 step 4：specification其实我感觉就是具体的文档说明，产出为需求分析文档 软件功能：使用用例图以及用例说明来展示 软件外部接口说明 软件性能说明 软件属性说明 是否有使用标准、编程语言、数据库完整性方针、资源限制、运行环境方面的要求 参考的SRS文档结构 part 2：validation review prototyping test-case]]></content>
      <categories>
        <category>SoftwareManagement</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MgtPro_2 requirement gathering]]></title>
    <url>%2F2019%2F05%2F11%2FSoftwareManagement%2FMgtPro_2%2F</url>
    <content type="text"><![CDATA[MgtPro_2 requirement gatheringby role-play 1、role-play game1.1、项目经理： 非功能性需求 1.2、管理员： 下架商品 消息提醒 查看销量（只能查询从该出版社进口的书籍的销量 调整进价 1.3、客服： 更改订单的一定内容（例如收货地址 查询订单信息 举报 转接另一个客服 和买家沟通 自动回复 1.4、用户： 查询书 购物车 收藏书 推荐书 订单生成、修改、查询、删除、统计 退换货 搜索书 消息提醒 物流跟踪 支付 跟客服交流、投诉 针对订单的评价 2、scenario-based2.1、功能性需求 图书系统 图书信息管理 书籍上架/下架 书籍信息修改 书籍查询(所有的订单的信息) 库存管理 增/减 查询 订单系统 交易模块 支付(微信、支付宝、网银) 计算价格 订单管理模块 订单创建 订单修改 取消订单 订单查询 服务系统 销售服务 客服和用户沟通 物流跟踪 退换货 投诉 书籍服务 推荐 收藏 评论 举报 消息通知 出版社通知 用户通知 管理员通知 统计分析系统 销量 书籍分析 用户系统 管理员 超级管理员 封禁用户 修改用户信息 删除评论 客服(订单管理员) 图书管理员 普通用户 购物车 添加书 删除书 个人信息管理 2.2、非功能性需求 性能 响应时间 吞吐量 并发用户数 安全性 网站安全 交易/资金安全 数据安全 用户信息安全 可靠性 失效率 健壮性 系统失效后恢复时间 数据出错率 易使用性 易理解性 易操作性 易学习性 可维护性 易分析性 已测试性 可移植性 适应的平台数 可复用板块比率 可重用性 可复用率 可恢复性 系统失效后能否自动修复 约束 成本 硬件环境、软件环境 商业规则 开发时间 法律 资源]]></content>
      <categories>
        <category>SoftwareManagement</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SRS part2]]></title>
    <url>%2F2019%2F05%2F11%2FSoftwareManagement%2FMgtPro_4_SRS_part2%2F</url>
    <content type="text"><![CDATA[SRS part22. Overall DescriptionThis section of the SRS gives an overview description of the general factors that affectthe product and its requirements. This section does not state specific requirements.Instead, it provides a background for those requirements. 2.1 Product Perspective\ 产品上下文关联（是否是产品系列的后续成员etc Online bookstore system is a new, web-based product design to provide online bookselling. While the web-based application is the main focus of the project, there is also a server- side component which will be responsible for database and synchronization services. And there should be a client-side smart phone application to provide necessary working information to drivers. The scope of the project encompasses both server- and client- side functionalities. The diagram shown above demonstrates the interactions between the user and the system, including the system structure. 2.2 Product Functions\ 产品的主要功能（详细说明在后面） 可用类图说明 图书系统 图书信息管理 书籍上架/下架：图书管理员可以上架下架书籍，书籍下架后，客户无法购买该书籍。 书籍信息修改：图书管理员可更改某本书籍的具体信息，如书的价格、标签、打折信息、促销信息、书的简介等 书籍查询：系统所有用户均可查找书籍的相关信息 库存管理 增/减：【？仓库管理员】可以增加减少某本书的仓库容量 查询：【？仓库管理员】可以查询书籍的仓库容量 订单系统 交易模块 支付(微信、支付宝、网银)：customers would pay by credit card, Alipay, or WeChat. 计算价格：The system must calculate taxes and delivery fee as well as applying discounts to the sale when applicable. 订单管理模块 订单创建：客户可通过系统可以创建订单 订单修改：客服可通过系统修改订单的部分信息（如订单的收货地址 取消订单：在书籍未发货前，客户可通过系统取消自身的订单 订单查询： 客户可通过系统查询自身产生的订单状态 客服可通过系统查询自己所负责区域的客户所产生的所有订单 服务系统 销售服务 客服和用户沟通：客服可与客户沟通，帮助客户购买到想要的书籍 物流跟踪：系统提供每个订单的物流状况 退换货：系统支持客户退换购买的书籍 投诉：系统支持客户投诉客服的服务态度 书籍服务 推荐：系统提供推荐书单，如年度榜单、本月/本季度最热销书籍 收藏：客户可将书籍添加到自己的收藏书单内 评论：客户可对某本书籍编写书评 举报：客户可举报书籍 消息通知 出版社通知：当某本书的库存到达某一阈值时，系统将会给出版社发送进货通知 用户通知： 系统发送流程信息提示（如登陆成功、订单创建成功 若书籍缺货，系统应发送缺货提醒并给出确切的deadline，a compatible deadline is informed to the customer. 管理员通知：？ 统计分析系统 销量：The system must allow a manager to generate reports on bestselling books, and on most profitable customers 书籍分析： 用户系统 管理员 超级管理员 封禁用户：超级管理员可以封禁普通用户账号 修改用户信息：超级管理员可以修改普通用户信息 删除评论：超级管理员可以删除含敏感信息的或不适宜的书籍评论 客服(订单管理员) 图书管理员 普通用户 购物车 添加书： 删除书 个人信息管理：修改个人基本信息 After requirement classification, we got some subsystems mainly based on the entity that function is related to. Details of functions that each subsystem implements are listed as follows. Book system Book Information Management Books on shelves / off shelves: Librarians can put books on the shelves. If a book is off shelves, customers could not buy the book via the system. Book information modification: The librarian can change the specific information of a book, such as book price, label, discount information, promotion information, book introduction, etc. Book search: All users of the system can find information about books. Inventory management Increase/decrease: [? Warehouse administrator] can increase the warehouse capacity of a book Inquire:【? Warehouse administrator] can query the warehouse capacity of books Order System Trading module Payment (WeChat, Alipay, online banking): customers would pay by credit card, Alipay, or WeChat. The system must calculate taxes and delivery fee as well as applying discounts to the sale when applicable. Order Management Module Order creation: Customers can create orders through the system Order modification: Customer service can modify part of the order information through the system (such as the order receipt address) Cancellation of orders: Customers can cancel their orders through the system before the books are shipped. Order Tracking: Customers can check the status of their own orders through the system Customer service can query all orders generated from the area where customers work in through the system service system Sales service Customer service and user communication: Customer service can communicate with customers to help customers purchase the books they want. Logistics tracking: the system provides the logistics status of each order Return and exchange: the system supports customers to return or exchange the purchased books Complaint: System support customer complaints Customer service attitude Book service Recommendation: The system provides a list of book recommendations, such as the annual list, the best selled books during this month / this quarter Collection: Customers can add books to their collections Comments: Customers can write a book review of a book Report: Customers can report a book if the book has some sensitive content. notification Publisher notice: When the inventory of a book reaches a certain threshold, the system will send a delivery notice to the publisher. User notification: The system sends a process information prompt (if the login is successful, the order is created successfully) If the book is out of stock, the system should send a stockout reminder and a compatible deadline is informed to the customer. Administrator notification:? Statistical Analysis System Sales: The system must allow a manager to generate reports on bestselling books, and on most profitable customers ？ Book analysis: ？ User system Administrator Super administrator Blocked users: Super administrators can block ordinary user accounts Modify user information: Super administrator can modify common user information Delete comments: Super administrators can delete book comments with sensitive information or inappropriate content. Customer Service (Order Administrator) ? librarian ? general user shopping cart Add a book: customers can add books to their shopping cart delete the book: customers can delete books from their shopping cart. Personal Information Management: Customers can modifying personal basic information through the system. 2.2.2 Features The system should run on an internet-based environment. The system is a web-service-based application. The system should have a centralized database. The system should have authentication functionality. The system should be scalable and extendable, e.g. extend Mobile APP. The system should have reasonable external interface, e.g. add new interface for PayPal. The system should have a user-friendly UI and be easy to use. The driver should be able to download his working schedule, see the routes, and commit the work when he is done via his smart phone. 2.3 User Classes and Characteristics\ 用户类 用户特征 用户： 客户：可以查询书籍信息，购买书籍 仓库管理员：可查询书籍的库存信息，更改书籍的库存信息 超级管理员：可以修改用户 客服：可以与用户沟通，修改订单的部分信息 Customer can inquiry the information of book through the system without any particular prerequisite. But customer must log in the system before buying books, query orders or return book. Warehouse administrator can query the inventory information of books and change the inventory information of books Super administrator take charge of the common users and book reviews in the system. They can block the common users, modify user information and delete inappropriate book review. Customer service can communicate with users and modify part of the order information. 2.4 Operating Environment\ 操作环境：硬件平台、操作系统、版本 2.5 Design and Implementation Constraints\&lt;Describe any items or issues that will limit the options available to the developers. These might include: corporate or regulatory policies; hardware limitations (timing requirements, memory requirements); interfaces to other applications; specific technologies, tools, and databases to be used; parallel operations; language requirements; communications protocols; security considerations; design conventions or programming standards (for example, if the customer’s organization will be responsible for maintaining the delivered software).> 项目设计和实现约束 2.6 User Documentation\ 用户手册 2.7 Assumptions and Dependencies\ 假设和依赖，可能使用的第三方组件]]></content>
      <categories>
        <category>SoftwareManagement</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MgtPro_5]]></title>
    <url>%2F2019%2F05%2F11%2FSoftwareManagement%2FMgtPro_5%2F</url>
    <content type="text"><![CDATA[MgtPro_51. risk identification1.1 DiagrammingEquipment 设备未到位（缺失、不足 设备因不可坑因素损坏 ProcessPeopleMaterialsEnvironment 新的开发工具学习期比预期长 开发工具不如期望的那样有效，开发人员需要时间创建工作环境或者切换新的工具； Management Type Possible risk Technology People Organizational Tools Requirements Estimation 1.2 type-basedTechnology 系统架构不合理 可复用组件不适用 数据库 对于并发性的支持 事件的四大特性（一致性、持久性、原子性、隔离性） 数据库数据丢失（ 数据库数据安全（恶意攻击，恶意入侵数据库，备份数据的保护 服务器 设备失效，宕机 设计质量低下，导致重复设计； 一些必要的功能无法使用现有的代码和库实现，开发人员必须使用新的库或者自行开发新的功能； 代码和库质量低下，导致需要进行额外的测试，修正错误，或重新制作； 过高估计了增强型工具对计划进度的节省量； 分别开发的模块无法有效集成，需要重新设计或制作。 People 人员的变更：人员辞职（底层程序员、管理层人员），关键人员因不可抗因素没办法工作，新的人员的加入 人员技术水平不够 人员培训效果不足 人员消极怠工 人员之间沟通不足引发冲突，导致工作因沟通不够出现错误或额外的重复工作 Organizational 分工不合理（工作难度分配不合理、工作种类分工不合理） 运转资金不足 仅由管理层或市场人员进行技术决策，导致计划进度缓慢，计划时间延长； 低效的项目组结构降低生产率； 管理层审查 决策的周期比预期的时间长； 预算削减，打乱项目计划； 缺乏必要的规范，导致工作失误与重复工作； 非技术的第三方的工作(预算批准、设备采购批准、法律方面的审查、安全保证等)时间比预期的延长。 Tools 代码生成失误 工具不兼容 源码丢失 Requirements 需求已经成为项目基准，但需求还在继续变化； 需求定义欠佳，而进一步的定义会扩展项目范畴； 产品定义含混的部分比预期需要更多的时间； 在做需求中客户参与不够 Estimation 工作量工作时间工作进度预估错误 低估软件规模 低估缺陷修复率 1.3 Brainstorm客户风险： 客户对于交付的产品不满意 scope risk： 产品跨领域 1.4 Document review非功能需求法律： 某些地区有特定的法律法规，系统需要根据所在地区进行调整 2. classificationRBS 2.1 External Unpredictable 设备风险 Natural Hazards（设备因不可坑因素损坏 设备未到位 非技术的第三方的工作(预算批准、设备采购批准、法律方面的审查、安全保证等)时间比预期的延长。 2.2 Externel Predictable market risk： 软件功能不符合市场需求，投入市场后反映惨淡 行业竞争 运营风险： 经营成本上升，宣传成本，人员成本上升 通货膨胀 汇率 2.3 Internal Non-technical Environment 新的开发工具学习期比预期长 开发工具不如期望的那样有效，开发人员需要时间创建工作环境或者切换新的工具； People 人员的变更：人员辞职（底层程序员、管理层人员），关键人员因不可抗因素没办法工作，新的人员的加入 人员技术水平不够 人员培训效果不足 人员消极怠工 人员之间沟通不足引发冲突，导致工作因沟通不够出现错误或额外的重复工作 Organizational 分工不合理（工作难度分配不合理、工作种类分工不合理） 运转资金不足 仅由管理层或市场人员进行技术决策，导致计划进度缓慢，计划时间延长； 低效的项目组结构降低生产率； 管理层审查 决策的周期比预期的时间长； 预算削减，打乱项目计划； 缺乏必要的规范，导致工作失误与重复工作； 非技术的第三方的工作(预算批准、设备采购批准、法律方面的审查、安全保证等)时间比预期的延长。 Requirements 需求已经成为项目基准，但需求还在继续变化； 需求定义欠佳，而进一步的定义会扩展项目范畴； 产品定义含混的部分比预期需要更多的时间； 在做需求中客户参与不够 Estimation 工作量工作时间工作进度预估错误 低估软件规模 低估缺陷修复率 客户风险 客户对于交付的产品不满意 scope risk： 产品跨领域发展 2.4 Technical 数据库 对于并发性的支持 事件的四大特性（一致性、持久性、原子性、隔离性） 数据库数据丢失（ 数据库数据安全（恶意攻击，恶意入侵数据库，备份数据的保护 服务器 设备失效，宕机 design： 设计质量低下，导致重复设计； 一些必要的功能无法使用现有的代码和库实现，开发人员必须使用新的库或者自行开发新的功能； 代码和库质量低下，导致需要进行额外的测试，修正错误，或重新制作； 过高估计了增强型工具对计划进度的节省量； 分别开发的模块无法有效集成，需要重新设计或制作。 Tools： 代码生成失误 工具不兼容 源码丢失 2.5 Legal 某些地区有特定的法律法规，系统需要根据所在地区进行调整 专利问题，使用第三方库涉及的侵权问题 消费者权益受损，平台未及时处理而遭诉讼 3. risk analysis分工：各自按照流程风险分析，register，应对措施= =自己看ppt吧 文添： 2.5+ppt 陈超： 2.1、2.2（+补充 陈润乾、罗媚、谈瑞： 2.3 3个人 梁程伟： 2.4（+补充 Pre 建议： 资源分配，依据什么将资源分配给WBS中的任务 介绍一下自己使用的风险管理工具 WBS从不同的方面进行分解？合理分解（对于WBS不同的划分 甘特图 注意所写的风险是否与软件开发是否有关 参考一些现有的技术文档 现有的技术模型 PPT流程： Risk Mgt Plan（略） Risk Identification 使用方法：brainstorm、diagramming、document review 展示RBS Risk Analysis 定性分析：probability-impact矩阵，impact分析表 定量分析：决策树、蒙特卡洛分析 response 面对的态度：积极、消极 strategy WBS（使用工具：甘特图、ones.ai 建议： schedule中包含工作的分配和资源的分配 给这个分值的原因 WBS分解的依据]]></content>
      <categories>
        <category>SoftwareManagement</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2.3 Internal non-technical]]></title>
    <url>%2F2019%2F05%2F11%2FSoftwareManagement%2FMgtPro_6_RiskMgt%2F</url>
    <content type="text"><![CDATA[2.3 Internal non-technical2.3.3 Organizational 分工不合理（工作难度分配不合理、工作种类分工不合理） 及时根据当前工作进度调整工作分工 进行工作分工时跟技术人员沟通 运转资金不足 技术中心及相关设计人员慎重研究设计变更，减少设计变更造成的各种损失 加强设备管理，及时利用，减少浪费 仅由管理层或市场人员进行技术决策，导致计划进度缓慢，计划时间延长； 进行技术决策时与技术人员进行有效的沟通 低效的项目组结构降低生产率； 选取一个有强领导力的管理者 设置一定的奖惩机制，激励员工提高生产率 对项目组结构进行一定的重构或微调 管理层审查 决策的周期比预期的时间长； 管理层审查应设置deadline 分级审查 定期向管理层汇报风险/问题 预算削减，打乱项目计划； 压缩生产成本 剪掉优先级低的需求实现 缺乏必要的规范，导致工作失误与重复工作； 项目开始前明确良好的规范 定期检查项目进行是否符合规范 非技术的第三方的工作(预算批准、设备采购批准、法律方面的审查、安全保证等)时间比预期的延长。 若存在多方审批，并行进行，选取最优的审批方式 安排项目时间时预留一定的审查时间 2.3.4 Requirements 需求已经成为项目基准，但需求还在继续变化； 明确合同约束，建立需求基线 建立变更审批流程 明确和树立需求基线是需求变更的依据 小的需求变更也要经过正规的需求管理流程 客户下达变更的流程尽可能规范化，留下书面依据 分级管理需求变更 需求定义欠佳，而进一步的定义会扩展项目范畴； 需求分析工程中对于需求给出明确的定义，有明确的产出文档 制定需求的基线 分级管理客户需求 产品定义含混的部分比预期需要更多的时间； 项目开发的每个阶段应设置一定的监管，保证项目开发前相关的具体的需求文档已经形成 在做需求中客户参与不够 采用原型开发获取客户需求 2.3.5 Estimation 工作量工作时间工作进度预估错误： 动态调整工作的进度，实时跟踪项目的进度。 低估软件规模： 进行软件规模预估时应当结合历史数据考虑。 通过科学的战略评估防止评估错误的风险。需要依靠软件开发管理的专家来帮助项目更好地评估。 低估缺陷修复率： 提高代码质量和开发管理。 2.3.6 客户风险 客户对于交付的产品不满意： 加强与客户进行质量标准制定的沟通，统一双方的标准和检测方法 技术部门做好软件开发的安排，保证开发的进度。 产品经理加大与客户的交流与沟通，及时处理客户的需求和意见。 2.3.7 scope risk： 产品跨领域发展： Take good care of scope management. 2.3 Internal non-technical2.3.3 Organizational Unreasonable division of labor (unreasonable distribution of work difficulty, unreasonable division of work types) Adjust the division of work according to the current work schedule Communicate with technical staff when performing work division Insufficient working capital The technical center and related designers carefully study design changes and reduce various losses caused by design changes. Strengthen equipment management, use in time, reduce waste Technical decisions are made only by management or market personnel, resulting in slow schedules and extended planning time; Communicate effectively with technical staff when making technical decisions Inefficient project team structure reduces productivity; Choose a manager with strong leadership Set a certain reward and punishment mechanism to motivate employees to increase productivity Make certain refactoring or fine-tuning of the project team structure Management review The decision cycle is longer than expected; Management review should set the deadline Grading review Report risks/issues to management on a regular basis Budget cuts and disruption of project plans; Compress production costs Cut off the low priority requirement implementation Lack of necessary norms, resulting in work errors and duplication of work; Defining good specifications before the project begins Regularly check the project for compliance Non-technical third-party work (budget approval, equipment purchase approval, legal review, security assurance, etc.) was extended beyond expectations. If there are multiple approvals, proceed in parallel and select the best approval method. Reserve a certain review time when scheduling project time 2.3.4 Requirements Demand has become the benchmark for the project, but demand continues to change; Clarify contractual constraints and establish a baseline of demand Establish a change approval process Clarify and establish a baseline of demand as the basis for demand changes Small demand changes also go through formal demand management processes The customer’s process of issuing changes is as standardized as possible, leaving a written basis Hierarchical management requirements change The definition of demand is poor, and further definitions will expand the scope of the project; A clear definition of the requirements in the requirements analysis project, with clear output documentation Develop a baseline for demand Hierarchical management of customer needs The ambiguous part of the product definition takes more time than expected; Each stage of project development should be set up with certain supervision to ensure that the specific requirements documents related to the project development have been formed. Insufficient customer involvement in doing demand Prototype development to obtain customer needs 2.3.5 Estimation Workload working time work progress estimate error: Dynamically adjust the progress of the work and track the progress of the project in real time. Underestimate the size of the software: Software size estimation should be considered in conjunction with historical data. Prevent the assessment of the risk of errors through a scientific strategic assessment. Experts in software development management are needed to help the project better evaluate. Underestimate the defect repair rate: Improve code quality and development management. 2.3.6 Customer Risk The customer is not satisfied with the delivered product: Strengthen communication with customers on quality standards, and unify standards and testing methods The technical department will make arrangements for software development to ensure the progress of development. The product manager increases communication and communication with customers and timely handles customer needs and opinions. 2.3.7 scope risk: Product cross-domain development:Take good care of scope management.]]></content>
      <categories>
        <category>SoftwareManagement</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Management_3 Risk Management]]></title>
    <url>%2F2019%2F05%2F11%2FSoftwareManagement%2FManagement_3%2F</url>
    <content type="text"><![CDATA[Management_3 Risk ManagementPrevention Crane]]></content>
      <categories>
        <category>SoftwareManagement</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Management_2]]></title>
    <url>%2F2019%2F05%2F11%2FSoftwareManagement%2FManagement_2%2F</url>
    <content type="text"><![CDATA[Management_2Software pricePlan-driven deveplomentplan sections ​ introduction ​ project organization never stop learning Project schedulingusing barchart to represent your schedule Agile planningEstimation]]></content>
      <categories>
        <category>SoftwareManagement</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MgtPro_8_QualityMgt]]></title>
    <url>%2F2019%2F05%2F11%2FSoftwareManagement%2FMgtPro_8_Quality%2F</url>
    <content type="text"><![CDATA[MgtPro_8_QualityMgtQuality Baseline/Goals1. Functionality:a. Suitability: The function of the sub-functions in the system should meet the principle of high cohesion and low coupling. The number of database table rows does not exceed 1 million rows, the maximum capacity of the database does not exceed 1000 GB, and the disk space needs at least 40G. 1000000. All the requirement should be implemented as requirement document says. The maximum number of transactions per day is 3,000. The average number of concurrent transactions is 20, and the maximum number of concurrent transactions is 50. The estimated number of users is 10,000, the number of login users per day is about 3000, and the bandwidth of the network is 100M bandwidth. The system can simultaneously satisfy 10,000 user requests and provide browsing capabilities for 25,000 concurrent users. b. Accuracy: The data stored by the system should be atomic and persistent. The accuracy of the calculation is 7 digits after the decimal point. c. Interoperability (Interoperability): The system should have good interaction with the delivery platform. d. Compliance: Software coding should follow a uniform standard. 2. Reliability: There is a prompt for the input, the data is checked to prevent data anomalies. The system is robust and should be able to handle various abnormal situations that occur during system operation, such as human error, illegal data input, hardware device failure, etc. The system should be able to handle it correctly and avoid it properly. The probability that the service cannot be completed due to the failure of the software system is less than 5‰. The system is required to run 24 hours a day, and the continuous operation failure time of the whole year cannot exceed 10 hours. The system defect rate has a maximum of 1 failure every 1,000 hours. In 1,000,000 transactions, there is a maximum of 1 time when the system needs to be restarted. 3. Usability:a. Learnability: Within 3 months of the introduction of the product, 60% of users should be able to use it to complete the transfer task within 45 seconds, the failure rate is controlled within one ten thousandth. 60% of users will realize that this is the bank’s online banking within 5 seconds of seeing the product for the first time. 80% of users can successfully buy a book within 5 minutes after receiving a half-hour system introduction training. b. Operability: Some rural areas have poor network quality and low bandwidth. Guarantee the availability of the system under conditions of poor network environment. In 95% of the failures, the system takes up to 20 seconds to restart. Provide data backup and recovery functions to enable timely recovery and restore of data (provided by hardware and third-party software) when system data is lost due to system errors or other reasons or system data is corrupted. 4. Efficiency:a. Time Behaviour: In 95% of cases, the general time response time does not exceed 1.5 seconds, and the peak time does not exceed 4 seconds. The time required for the positioning system to display from the click to the first interface must not exceed 300 milliseconds. When the network is unblocked, the time required to dial-up to the GPRS network must not exceed 5 seconds. When the network is unblocked, the website page refresh time does not exceed 10 seconds. In the recommended configuration environment: the login response time is within 2 seconds, the refresh response time of the column is within 2 seconds, the response time of the entry page list is refreshed within 2 seconds, and the response time of the information entry is turned on within 1 second, and the department and personnel list response is refreshed. Time is 2 seconds. Search during the off-peak hours according to the number and name specific conditions, and the search results can be obtained within 3 seconds. b. Resource Behaviour: CPU usage &lt;=50%. Memory usage &lt;=50%. 5. Maintainability:a. Changeability: After receiving the modification request, the general modification should be completed within 1-2 days; for the major demand or design modification after the assessment, it should be completed within 1 week. 90% of the BUG modification time does not exceed 1 working day, and the other does not exceed 2 working days. The circle complexity of the code must be within 10. Any method of any object does not allow more than 200 lines of code. Install the new version and keep all database contents and all personal settings unchanged. The product must provide tools to track any database fields. b. Testability: The maximum circle complexity of a module cannot exceed 15. The delivered system must pass unit testing and be 100% covered. Development activities must use regression testing and allow for a complete test to be re-run within 12 hours. 6. Portability: The code change rate should be less than 20% when the system is migrated. The installation success rate should be greater than 90% when the system is transplanted. Functional integrity should reach 90% and above in the new target environment after system migration. 7. Security Strict access control. After the user is authenticated, the user can only access the data within the scope of his or her rights, and can only perform operations within its scope of authority. Different users have different identities and rights. They need to provide trusted authorization management services under the premise of authenticity of users, protect data from illegal/over-authorized access and tampering, and ensure confidentiality and integrity of data. Sex. Provide running log management and security auditing functions to track the historical usage of the system. Can withstand general malicious attacks from the Internet. Such as viruses (including Trojans) attacks, password guessing attacks, hacking, etc. At least 99% of attacks need to be detected within 10 seconds. Network delivery data should be encrypted. It is necessary to ensure that data is not sneaked, stolen or tampered with during collection, transmission and processing. Business data needs to be encrypted at the time of storage to ensure that it is not hackable. 8. Compatibility The system should support IOS, Android, Windows operating system; The system should support Oracle, DB2 database system; Up to 5% of system implementations need to be specific to a particular operating system. The average time to replace the relational database system is no more than 2 hours, and no data loss is guaranteed. Quality MetricThe following metrics are majorly used for generating the daily/weekly status report with accurate data during test case development/execution phase and this is also useful for tracking the project status and Quality of the software. 1. percentage Test cases Executed:This metric is used to obtain the execution status of the test cases in terms of percentage. TestCaseExecuted\% = \frac{No_{TestCaseExecuted}}{Total \space No_{TestCasesWritten}}* 100.2. percentage Test cases not executed:This metric is used to obtain the pending execution status of the test cases in terms of percentage. TestCasesNotExecuted\% = \frac{No_{TestCasesNotExecuted}}{Total \space No_{TestCasesWritten}} * 100. 3. percentage Test cases Passed:This metric is used to obtain the Pass percentage of the executed test cases. Test Cases Passed\% = \frac{No_{ Test Cases Passed} }{Total \space No_{Test Cases Executed}} * 100.4. percentage Test cases Failed: This metric is used to obtain the Fail percentage of the executed test cases. Test Cases Failed \%= \frac{No_{ Test Cases Failed }}{ Total \space No_{ Test Cases Executed}}* 100.5. percentage Test cases Blocked: This metric is used to obtain the blocked percentage of the executed test cases. A detailed report can be submitted by specifying the actual reason of blocking the test cases. Test Cases Blocked \% = \frac{No_{ Test Cases Blocked}}{ Total \space No_{ Test Cases Executed}}* 100. 6. Defect Density Defect Density = No_{ Defects identified }/ size(Here “Size” is considered as requirement. Hence here the Defect Density is calculated as number of defects identified per requirement. Similarly, Defect Density can be calculated as number of Defects identified per 100 lines of code [OR] No. of defects identified per module etc.) 7. Defect Removal Efficiency (DRE) Defect Removal Efficiency(DRE) = (\frac{No_{ Defects Found During QA Testing}}{ No_{ Defects Found During QA Testing}} +No_{ Defects Found By End user}) * 100DRE is used to identify the test effectiveness of the system. 8. Defect Leakage:Defect Leakage is the Metric which is used to identify the efficiency of the QA testing i.e., how many defects are missed / slipped during the QA testing. Defect Leakage = \frac{No_{ Defects Found in UAT }}{No_{ Defects Found in QA Testing.}}* 1009. Defects by Priority:This metric is used to identify the no. of defects identified based on the Severity / Priority of the defect which is used to decide the quality of the software. \begin{align} Critical Defects\% &= \frac{No_{ Critical Defects Identified }}{ Total \space No_{ Defects Identified} }* 100 \\ High Defects\% &= \frac{No_{ High Defects Identified}}{Total \space No_{ Defects Identified}} * 100 \\ Medium Defects\% &=\frac{ No_{ Medium Defects Identified }}{ Total \space No_{ Defects Identified}} * 100 \\ Low Defects\% &= \frac{No_{ Low Defects Identified}}{Total \space No_{ Defects Identified}} * 100 \end{align}]]></content>
      <categories>
        <category>SoftwareManagement</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[项目主要成果]]></title>
    <url>%2F2019%2F05%2F11%2FMess%2F%E9%A1%B9%E7%9B%AE%E4%B8%BB%E8%A6%81%E6%88%90%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[项目主要成果​ 我们制作了android平台的应用，应用软件工程的相关知识，我们进行了需求分析、需求建模、概要设计、详细设计、编程、测试的过程，产生了一系列说明文档，对于产品的各个方面进行了详细的描述，各文档说明如下： 需求规约文档： 进行项目初期的市场调研，对于项目的需求以及项目的整体流程、涉及的范围有大体的了解。 需求分析文档：以需求规约中得到的大体需求进行一定的抽象和细化，抽离出符合软件开发要求的需求，主要使用系统总体流程图来描述系统整体的业务流程，使用用例图来描述抽离出的功能点，使用活动图和序列图来描述用例的业务逻辑。 概要设计文档：对于项目的开发进行概要的设计，包括软件结构设计、接口设计、界面设计、数据库设计以及系统出错处理设计。其中使用架构图描述软件结构设计，类图和子类图描述组件间的接口，制作产品原型来描述界面设计，绘制ER图来描述数据库的表设计以及使用相关文档说明描述系统出错处理设计。 详细设计文档：在概要设计的基础上进行更详细的设计，考虑使用的算法，类的设计和函数的设计等。 ​ 我们制作了一个已经可运行的应用，应用实现了我们进行需求建模时所总结归纳的基本功能，包括： 对于用户的注册登录注销，修改用户信息 拍照以及上传照片 增删改某件衣物信息，查看衣物信息，查看衣柜 接收推送消息，可根据天气进行当日搭配推荐 评价、收藏货更新某个搭配 选择生成某个搭配，可挑选场合，系统将会针对该场合生成对应的搭配 对于系统的增删改用户 衣型识别 生成搭配 项目主要成果： 心得体会： 项目图片： 硬件研制： 项目日志： 其他：]]></content>
      <categories>
        <category>Mess</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[专业综合项目]]></title>
    <url>%2F2019%2F05%2F11%2FMess%2F%E4%B8%93%E4%B8%9A%E7%BB%BC%E5%90%88%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[专业综合项目 从第3周开始： 每周选择3组来进行汇报 每两周研究生会来面对面交流 可选topic： 环视图像中语义视觉目标的分割：识别目标：方向标志、减速带、泊车位 inverse tone mapping with deep learning，低维到高维的映射（LDR-HDR） 基于单目相机的时间里程器。15221927149 移动端游戏平台（休闲类小游戏，时长为几分钟）游戏大厅+游戏 15801758610 ros驱动的移动机器人 人脸表情和姿态迁移，facerig 云书籍，类似豆瓣的东西 语义slam相关研究 手写数字串识别：切片+单字识别，CRNN 为图片自动加标签（微软有相关的API 室内导航？ VIO？]]></content>
      <categories>
        <category>Mess</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Web_1 web architecture?]]></title>
    <url>%2F2019%2F05%2F11%2FWeb%2FWeb_1%2F</url>
    <content type="text"><![CDATA[Web_1 web architecture?HyperText Markup Language 主动指针（多媒体：图片、音频等 被动指针（href Web Browser ArchitectureA controller A set of clients A set of interpreters Web typeStatic web documentActive web document Textual representation: js，可以改变网页内控件 Binary representation: 相对独立，与网页的控件没有交互 ==typescript== Dynamic web documentruns on web server : can create a html document each time a request arrives Common Gateway Interface ==install php(first) , apache== 不考虑网页状态，不断动态更新可能会导致服务器压力很大 由此，Ajax诞生]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Web_2 HTML basis]]></title>
    <url>%2F2019%2F05%2F11%2FWeb%2FWeb_2%2F</url>
    <content type="text"><![CDATA[Web_2 HTML basisMarkup language Exercise：简历（html+css]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MgtPro_9_MonteCarlo]]></title>
    <url>%2F2019%2F05%2F08%2FSoftwareManagement%2FMgtPro_9_MonteCarlo%2F</url>
    <content type="text"><![CDATA[MgtPro_9_MonteCarloMonte Carlo method​ Monte Carlo simulation is a method in the risk analysis and evaluation of engineering projects. It is a quantitative analysis method. When the number of random variables input in the project evaluation is more than three, there may be three or more states in each input variable. Monte Carlo simulation techniques should be used. ​ The principle of this method is to use a random sampling method to extract the values of a set of input variables, and calculate the project evaluation index based on the numerical values of the input variables. Through a large number of simulations of tens of thousands or even millions of times, the final evaluation is obtained. The probability distribution of the indicator and the cumulative probability distribution map, expected value, variance, and standard deviation, and the probability that the calculation item will change from feasible to infeasible, thereby estimating the risk assumed by the project investment. General steps for Monte Carlo simulation Select a random variable, the variable that is most sensitive to the net present value. Determine the probability distribution of random variables Extract random numbers for each random variable Convert the extracted random number into the sampled value of each input variable The sampled values constitute a set of project evaluation basic data Calculate the value of the evaluation index under a random condition based on the basic data. Repeat the above process and perform repeated simulations to obtain multiple sets of evaluation index values. Organize the expected value, variance, standard deviation, probability distribution and cumulative probability distribution of the evaluation indicators obtained from the simulation results, draw the cumulative probability map, and at the same time, check whether the simulation times meet the predetermined accuracy requirements. Based on the above results, the impact of each random variable on project revenue is analyzed. Sample:The time of the total construction period is estimated based on historical data simulation of each stage. According to the elements we divide in WBS, select random variables as four processes of software development: requirements engineering, design, development, testing The total duration is the sum of the four processes Determine the probability distribution of random variables According to historical data, pessimistic estimates, general estimates and optimistic estimates of each variable are obtained. It is assumed that the random variables obey the Gaussian distribution and the parameters of the Gaussian distribution are determined from the historical data. All variable are distributed as Gaussian distribution. Extract random numbers for each random variable Convert the extracted random number into the sampled value of each input variable The sampled values constitute a set of project evaluation basic data Calculate the value of the evaluation index under a random condition based on the basic data. Repeat the above process and perform repeated simulations to obtain multiple sets of evaluation index values. Organize the expected value, variance, standard deviation, probability distribution and cumulative probability distribution of the evaluation indicators obtained from the simulation results, draw the cumulative probability map, and at the same time, check whether the simulation times meet the predetermined accuracy requirements. Ex StandVar 103.8 19.2]]></content>
  </entry>
  <entry>
    <title><![CDATA[MgtPro_7]]></title>
    <url>%2F2019%2F05%2F06%2FSoftwareManagement%2FMgtPro_7%2F</url>
    <content type="text"><![CDATA[1. introduction purpose scope assumptions 主要照之前的部分 2. Project practices scope management（using appendix） quality management doc structure planning assurance Control risk management identification 思维导图类似物（包含总体的风险，根据我们分的大点 analysis（加引言） impact 表 展示矩阵图 蒙特卡洛 response 3. Work Breakdown Structure(WBS)4. Project Organization team structure roles、responsibilities， and authorities 5. Resource Allocation staffing profile schedule 6. Glossary第一次文档 分工： 3、4、5：超哥，谈瑞 1、6、impact的表，可能性-影响矩阵，决策树（5个）: 文添 2.1、quality planning、identification：梁程伟 2.2、2.3：罗媚，陈润乾 quality management Planning:[short] ，output： 管理计划 衡量标准 checklist Output需求跟踪矩阵 Assurance Quality Planning Doc Template 1.0 Quality Assurance Plan 1.1 Introduction ​ 1.2 Purpose​ 1.3 Policy Statement 1.4 Scope 2.0 Management 2.1 Organization structure ​ 2.2 Roles and Responsibilities ​ 2.2.1 Technical Monitor/Senior Management 2.2.2 Task Leader​ 2.2.3 Quality Assurance Team​ 2.2.4 Technical staff 3.0 Required Documentation 4.0 Quality Assurance Procedures ​ 4.1 Walkthrough Procedure 4.2 Review Procedure​ 4.3 Audit Procedure ​ 4.4 Evaluation Procedure ​ 4.5 Process Improvement 5.0 Problem Reporting procedure 6.0 Quality Assurance Metrics Appendix]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F15%2FSoftwareManagement%2FMgtPro_0%2F</url>
    <content type="text"><![CDATA[MgtPro_0标准－IEEE/ANSI 830-1998 1、引言1.1 需求文档的目的1.2 产品范围1.3 定义、首字母缩写词和缩略词1.4 参考文献1.5 文档的其余部分概览2、一般描述2.1 产品透视2.2 产品功能2.3 用户特征2.4 一般约束2.5 假设和依赖性3、专门需求覆盖功能，非功能和接口需求——显然，这是文档中最实质性的部分，但是因为在组织的实践中存在极大的变数，对这一节定义标准的结构是不适当的。需求可能记录外部接口，描述系统功能和特征、定义逻辑的数据库需求、设计约束、系统总体特征和质量特征。4、附录 英文版 introduction 互联网书店的要求清单从下一章开始，我们将通过我们刚刚为您概述的流程的每个阶段，跟随一个运行的示例，我们称之为Internet Bookstore。我们将要完成的用例以及我们将要发现的类存在，以满足我们的客户（我们将要构建的书店的所有者）指定的某些要求。这些要求包括以下内容： 书店应通过互联网接受订单。 书店应保留最多1,000,000名客户的帐户清单。 书店应为所有帐户提供密码保护。 书店应提供搜索主书目录的能力。 书店应在该目录上提供多种搜索方法，包括按作者搜索，按标题搜索，按ISBN编号搜索，以及按关键字搜索。 书店应提供允许客户通过信用卡支付的安全方式。 书店应提供允许客户通过采购订单支付的安全方式。 书店应提供一种特殊类型的帐户，预先通过采购订单支付。 书店应提供Web和数据库以及运输履行系统之间的电子链接。 书店应提供Web和数据库以及库存管理系统之间的电子链接。 书店应保持对书籍的评论，并允许任何人上传评论评论。 书店应根据客户意见对书籍进行评级。 Requirements List for The Internet BookstoreStarting in the next chapter, we’re going to be following a running example, which we call The Internet Bookstore, through each phase of the process we’ve just outlined for you. The use cases we’ll be working through, and the classes we’ll discover, exist to satisfy certain requirements that our client (the owner of the bookstore we’re going to build) has specified. These requirements include the following: The bookstore shall accept orders over the Internet. The bookstore shall maintain a list of accounts for up to 1,000,000 customers. The bookstore shall provide password protection for all accounts. The bookstore shall provide the ability to search the master book catalog. The bookstore shall provide a number of search methods on that catalog, including search by author, search by title, search by ISBN number, and search by keyword. The bookstore shall provide a secure means of allowing customers to pay by credit card. The bookstore shall provide a secure means of allowing customers to pay via purchase order. The bookstore shall provide a special kind of account that is preauthorized to pay via purchase order. The bookstore shall provide electronic links between the Web and database and the shipping fulfillment system. The bookstore shall provide electronic links between the Web and database and the inventory management system. The bookstore shall maintain reviews of books, and allow anyone to upload review comments. The bookstore shall maintain ratings on books, based on customer inputs.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Djangohexo搭建github博客]]></title>
    <url>%2F2019%2F01%2F17%2FGuideBook%2Fhexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hexo搭建github博客1. 前提条件 已有GitHub账号 （Mac）已安装Xcode command line tools 安装的工具我使用的是npm和brew 2. 安装git与Node.js12brew install gitbrew install node 3. 安装Hexo1npm install -g hexo-cli 为了便于发布到GitHub上，建议同时安装hexo-deployer-git 1npm install hexo-deployer-git --save 4. 初始化，建立博客项目选定博客网站项目程序文件的存放位置，如~/develop/hexo/github/，Bash中cd进入该目录下，执行命令： 1hexo init 执行完毕后，该命令将在当前目录下生成一套标准的Hexo博客项目模板 5. 生成网站上面的操作只是生成了一套网站构成所需的“源代码”，实际发布时需要根据这套“源代码”当中的配置文件、博客文档（.md文件）、主题模板等，进行组合构建，生成服务器可识别的标准HTML网站目录，此时可使用该命令： 1hexo g 执行完毕后，在public目录下可看到我们自己书写的博客文档（.md文件）与所选的博客主题模板链接组合，生成的最终静态网站文件，该目录也差不多就是之后发布到GitHub上的实际文件（实际发布到GitHub的是.deploy_git目录），外部的网站“源代码”不会上传到github.io库 6. 启动本地服务器启动本地服务器可即时查看网站运行效果： 1hexo s 默认地址是 localhost:4000 7. 选择主题Hexo可随时使用、更换博客主题 主题文件可在Hexo官方主题网页中下载，以Material为例，点击主题预览图下方的主题名称链接即可进入该主题的源码发布页面 GitHub - viosey/hexo-theme-material: Material Design theme for hexo. 根据主题安装指导，下载项目至博客项目下的themes目录中，文件夹命名为material，并在博客配置文件_config.yml中指定使用该主题： 1theme: material 将material主题目录下的_config.template.yaml重命名为_config.yaml 参考Material主题文档进行必要配置 再次执行 hexo g将会根据新主题重新构建整个博客 注意：1.5.6版本在执行hexo g时会报出TypeError错误，可参考Issue686修改dnsprefetch.ejs文件解决 8. 发布博客8.1 创建github.io仓库在自己的GitHub中，创建新仓库，标准命名为GitHub用户名.github.io，例如我的：wavky.github.io 仓库Readme、License之类的留空即可，之后在发布上传时会被强制覆盖抹掉 8.2 配置SSH密钥参考 https://my.oschina.net/ryaneLee/blog/638440配置SSH密钥一节 8.3 修改博客配置文件_config.yml1234deploy: type: git repo: GitHub上传仓库的完整路径，如 https://github.com/wavky/wavky.github.io.git branch: master 8.4 发布到GitHub在hexo g生成完毕后，可执行该命令发布博客到GitHub上： 1hexo d 或在生成网站的同时进行发布： 1hexo g -d 8.5 查看效果点击仓库页面中的GH Pages按钮，应该可以看到真正发布在互联网上的效果 9. 绑定域名GitHub Pages 默认提供的是 GitHub用户名.github.io（例如我的：wavky.github.io）作为博客访问地址，可设置绑定自定义域名 在博客项目目录的source文件夹中，创建一个CNAME文件，存储预备使用的个人域名，如： 12# 在source目录下echo story.wavky.com &gt; CNAME 清理Hexo缓存并重新生成发布 12hexo cleanhexo g -d GitHub项目页面中Setting设置界面，滚到GitHub Pages部分确认域名无误 在个人域名提供商（如阿里云万网）中，进入DNS设置界面，追加一条CNAME记录，这里我指定以story前缀的个人域名跳转到原来的默认的博客域名wavky.github.io，记录如下： 注：其他类型的域名绑定方式（例如IP指向等），在最后一步DNS设置中操作会不一样 作者：Wavky 链接：https://www.jianshu.com/p/cb0750324e26 來源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。]]></content>
  </entry>
  <entry>
    <title><![CDATA[QT_tablewidget]]></title>
    <url>%2F2019%2F01%2F17%2FGuideBook%2FQT_tablewidget%2F</url>
    <content type="text"><![CDATA[qt tablewidget2018-6-11 基于qt的tablewidget 实现文件系统的模拟，treewidget实现树形目录 配置：mac 10.13。 Qt 5.9 参考博文：https://www.cnblogs.com/zhoug2020/p/3789076.html //前面一部分基本都是按照这个博主写的来的，后面基本都是随便找的🌚🙈，这里当总结一下，因为不这样下次依旧不记得咋整。。。 文件系统提供的操作： 格式化 报错了。。。吐血。。🙃，调了半天了，太难过了，我还是洗洗睡了吧 创建子目录。 ok😃 删除子目录。 Ok 显示目录。 ok 更改当前目录。 Ok，一点树形目录就可以啦 创建文件。ok 打开文件。ok 关闭文件。还没写，ok？直接关就好了啊。。。 写文件。 需要界面，害没写 读文件。 同上，两功能一起，害没写，关写了个界面。。丑到哭泣，美工弱鸡哭唧唧 删除文件。 Ok 属性界面，害没写，o得k？ 使用tablewidget 实现： 好多功能，看着心疼=. = 操作表单，（添加删除行 ✔️ 双击某行打开该行文件 右键菜单 ✔️ 打开某行重命名 ✔️ 嗷嗷！重命名还么有写成功！ 1. qt tablewidget初始化123456789101112131415161718192021222324252627282930313233343536373839404142//å¯¹tablewidgetçš„åˆå§‹åŒ– ui-&gt;tableWidget-&gt;setColumnCount(4); ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setDefaultSectionSize(150); //è®¾ç½®è¡¨å¤´ QStringList header; header&lt;&lt;tr("åç§°")&lt;&lt;tr("ä¿®æ”¹æ—¥æœŸ")&lt;&lt;tr("å¤§å°")&lt;&lt;tr("ç§ç±»"); ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(header); //è®¾ç½®è¡¨åç§°åŠ ç²— QFont font = ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;font(); font.setBold(true); ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setFont(font); ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setStretchLastSection(true); //è®¾ç½®å……æ»¡è¡¨å®½åº¦ ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;sectionResizeMode(QHeaderView::ResizeToContents); //ui-&gt;tableWidget-&gt;verticalHeader()-&gt;setResizeMode(QHeaderView::ResizeToContents); ui-&gt;tableWidget-&gt;verticalHeader()-&gt;setDefaultSectionSize(20); //è®¾ç½®è¡Œé«˜ ui-&gt;tableWidget-&gt;setFrameShape(QFrame::NoFrame); ui-&gt;tableWidget-&gt;setShowGrid(false); ui-&gt;tableWidget-&gt;verticalHeader()-&gt;setVisible(false); ui-&gt;tableWidget-&gt;setSelectionMode(QAbstractItemView::ExtendedSelection); ui-&gt;tableWidget-&gt;setSelectionBehavior(QAbstractItemView::SelectRows); ui-&gt;tableWidget-&gt;setEditTriggers(QAbstractItemView::SelectedClicked); ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;resizeSection(0,150); ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setFixedHeight(25); ui-&gt;tableWidget-&gt;setStyleSheet("selection-background-color:lightblue;"); ui-&gt;tableWidget-&gt;setAlternatingRowColors(true); ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setStyleSheet("QHeaderView::section&#123;background:lightgray;&#125;"); ui-&gt;tableWidget-&gt;horizontalScrollBar()-&gt;setStyleSheet("QScrollBar&#123;background:transparent; height:10px;&#125;" "QScrollBar::handle&#123;background:lightgray; border:2px solid transparent; border-radius:5px;&#125;" "QScrollBar::handle:hover&#123;background:gray;&#125;" "QScrollBar::sub-line&#123;background:transparent;&#125;" "QScrollBar::add-line&#123;background:transparent;&#125;"); ui-&gt;tableWidget-&gt;verticalScrollBar()-&gt;setStyleSheet("QScrollBar&#123;background:transparent; width: 10px;&#125;" "QScrollBar::handle&#123;background:lightgray; border:2px solid transparent; border-radius:5px;&#125;" "QScrollBar::handle:hover&#123;background:gray;&#125;" "QScrollBar::sub-line&#123;background:transparent;&#125;" "QScrollBar::add-line&#123;background:transparent;&#125;"); ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setHighlightSections(false); 什么鬼什么鬼 2. 创建目录文件12345678910111213141516171819202122QCursor cur = this-&gt;cursor();QMenu* popMenu = new QMenu(this);QPoint point = QCursor::pos();QTableWidgetItem *item = ui-&gt;tableWidget-&gt;itemAt(point);popMenu-&gt;addAction(rMenu.action_open);popMenu-&gt;addAction(rMenu.action_rename);popMenu-&gt;addSeparator();popMenu-&gt;addAction(rMenu.action_delete);popMenu-&gt;addAction(rMenu.action_atrribute);popMenu-&gt;addAction(rMenu.action_flush);popMenu-&gt;addSeparator();popMenu-&gt;addAction(rMenu.action_create_folder);//è®¾ç½®å¿«æ·é”® 这就是我坚持用英文写注释的原因= =rMenu.action_open-&gt;setShortcut(QKeySequence::Open);rMenu.action_create_folder-&gt;setShortcut(QKeySequence::New);rMenu.action_flush-&gt;setShortcut(QKeySequence::Refresh);rMenu.action_delete-&gt;setShortcut(QKeySequence::Delete);popMenu-&gt;exec(QCursor::pos());event-&gt;accept(); Connect 方法需要写在ui初始化函数里，写在成员函数里会被多次唤醒导致一些奇奇怪怪的东西？ 3. 右键菜单创建123auto rootItem = new QTreeWidgetItem(ui&gt;treeWidget,QStringList(“myFile"));rootItem-&gt;setIcon(0,folderIcon);itemNode.insert(root,rootItem); 对于tablewidget 表的初始化，设置表头表的格式等等 2018.6.20 //made by may 乱糟糟的重新整理一遍？ 4. 文件相关操作12345678910111213141516171819 QDir dir = QDir::current(); if(!dir.exists("myFile"))&#123; dir.mkdir("myFile"); &#125; //mkdir为创建新的目录 if(root!=NULL)&#123; qDebug()&lt;&lt;"i am so cool! "&lt;&lt;root-&gt;fileName; &#125; QDir dir = QDir::current(); QString path = dir.absolutePath(); qDebug()&lt;&lt;path; path = path + QDir::separator() + "myFile"; QFile* tempFile = new QFile; dir.mkpath(path); dir.setCurrent(path); dir.setPath(path); //此处修改了当前路径补充：file-&gt;setFileName(fileName) 为在该路径下创建一个新的文件，默认为txt，其实吧。。。。我也还不知道怎么创建其他形式的文件（比如ppt啥的，但是印象中mac好像都是要打开对应的app才能新建文件的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546QFileInfoList Widget::getFileList(QString path,node* root)&#123; QDir dir(path); QDir absDir = QDir::currentPath(); QString absPath = absDir.absolutePath(); qDebug()&lt;&lt;"absPath : "&lt;&lt;absPath; QFileIconProvider fileIconPro; QIcon icon; QString fileName; QFileInfoList fileInfoList = dir.entryInfoList(); dir.setSorting(QDir::Name); QFileInfoList folderList = dir.entryInfoList(QDir::NoDotAndDotDot | QDir::Dirs|QDir::Files); qDebug()&lt;&lt;"now path: "&lt;&lt;path; for(int i = 0;i != folderList.size();i++)&#123; QString name = folderList.at(i).absoluteFilePath(); if(absPath.contains('/'))&#123; fileName = name.replace(path+"/",""); fileName = fileName.replace(absPath+"/",""); qDebug()&lt;&lt;"parent: "&lt;&lt;root-&gt;fileName&lt;&lt;" child: "&lt;&lt;fileName; &#125;else&#123; fileName = name.replace(path+"\\",""); fileName = fileName.replace(absPath+"\\",""); qDebug()&lt;&lt;"parent: "&lt;&lt;root-&gt;fileName&lt;&lt;" child: "&lt;&lt;fileName; &#125; QFileInfo fileInfo = folderList.at(i); QString type; int permission; if(fileInfo.suffix() == "")&#123; type = "folder"; permission = ReadOnly; icon = fileIconPro.icon(QFileIconProvider::Folder); &#125;else&#123; type = fileInfo.suffix(); permission = Write; icon = fileIconPro.icon(fileInfo); &#125; int locate = 0; FCB fcb(count++,fileName,type,fileInfo.created(),fileInfo.lastModified(),locate,fileInfo.size(),permission,0); catalog.insert(root,fileName,fcb); qDebug()&lt;&lt;"path :"&lt;&lt;name; node* childRoot = catalog.find(root,fileName); auto item = insertTreeItem(root,fileName,icon); if(childRoot != NULL &amp;&amp; item != NULL) itemNode.insert(childRoot,item); QFileInfoList childFileList = getFileList(name,childRoot); fileInfoList.append(childFileList); &#125; return fileInfoList;&#125; 图标获取， qt提供了相当方便的图标获取，但提供的图标有限，此处我只用了文本的和文件夹的，也还够用 创建新的文件或文件夹 treewidget操作: 添加item 获取某一个文件下的所有文件getFileList 获取表单此时选择的列 右键菜单相应事件 //相当生气了辣鸡pages！我决定去官网下wps，再见pages，辣鸡玩意，表格绕文本能不能别叠起来，能不能别乱跑，操碎老妈子的心了，文档从开始到放弃啊啊啊 //md真好用]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenGL环境建立]]></title>
    <url>%2F2019%2F01%2F17%2FGuideBook%2FOpenGL%E7%8E%AF%E5%A2%83%E7%9A%84%E5%BB%BA%E7%AB%8B%2F</url>
    <content type="text"><![CDATA[OpenGL环境的建立：tutorial library 上面是教程，下面是出的错的解决方法 画个三角形 error：ld: symbol(s) not found for architecture x86_64 clang: error: linker command failed with exit code 1 (use -v to see invocation) solve：缺少某个库，在build phases-&gt;link binary with libraries处添加“libgltools.dylib”文件，之后就报了另一个错。。。 error：ld: library not found for -lgltools clang: error: linker command failed with exit code 1 (use -v to see invocation) solve：library https://blog.csdn.net/harryptter/article/details/50380686 （ ！在这里强烈👍一下我们孙雨馨同学，找的教程太管用了！）]]></content>
  </entry>
  <entry>
    <title><![CDATA[xcode真机测试（无开发者模式]]></title>
    <url>%2F2019%2F01%2F17%2FGuideBook%2Fxcode%E7%9C%9F%E6%9C%BA%E6%B5%8B%E8%AF%95%20%E6%97%A0%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[xcode真机测试 无开发者模式%&gt;. &lt; 作为交不起开发者账号年费的穷逼，hci作业要用到真机测试只能酱紫了噗 % 希望哪天可以自己做个app上架，不求发家致富只求流量钱能够我交个年费 测试设备：mac 10.13.4； xcode9.4； iphone ios 11.3 将自己的手机用数据线连到电脑上，开启信任 xcode打开需要模拟的工程，此处为ARPra1，将测试设备调整为自己的设备 添加开发者账户，xcode-&gt;prefrence-&gt;account ,点击“+” -&gt; apple ID,输入自己的apple ID，点击manage，添加开发者证书 返回工程，打开general，将identify处的bundle id 改为未出现过的id名，team处改成刚刚添加的apple id run一下这个项目你就会发现手机上装了个app，如果无法打开，打开手机上的 设置——通用——设备管理——将Apple id所对应的开发者设置为信任 ok，现在可以愉快的测试啦]]></content>
  </entry>
  <entry>
    <title><![CDATA[Django实现衣型识别]]></title>
    <url>%2F2019%2F01%2F04%2FGuideBook%2FDjango%2FDjango%E5%AE%9E%E7%8E%B0%E8%A1%A3%E5%9E%8B%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Django实现衣型识别衣型识别出：类型、颜色、款式 [ ] 主要物体提取（目标检测），imageAI [ ] 裁剪图片，cv2 [ ] 生成透明背景的图片 [ ] 类型识别：CNN网络， tf [x] 颜色和配色提取：haishoku 库，获取主要颜色和配色，haishoku [ ] 一些小函数： [x] RGB（Tuple、十六进制互转 [ ] string、url互转 [ ] 向数据库中批量添加数据]]></content>
  </entry>
  <entry>
    <title><![CDATA[Django图片上传和访问]]></title>
    <url>%2F2019%2F01%2F02%2FGuideBook%2FDjango%2FDjango%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%92%8C%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[Django图片上传和访问配置： nginx+Django 1. 图片上传1.1 settings.py12345678910111213# closetUsers/settings.py# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/2.1/howto/static-files/# 收集Django的静态文件到同一个static中STATIC_ROOT = os.path.join(BASE_DIR, "static/")STATIC_URL = '/static/'MEDIA_ROOT = os.path.join(STATIC_ROOT, "media/")MEDIA_URL = '/media/'IMG_ROOT = os.path.join(STATIC_ROOT, "img")IMG_URL = 'img/' 1.2 views.py1234567891011121314151617181920# users/views.py# 上传图片到静态文件的文件夹@csrf_exemptdef upload_img(request): if request.method == 'POST': img = request.FILES.get('file', None) if not img: return JsonResponse(data=&#123;"msg": "没有上传的图片文件"&#125;, status=status.HTTP_400_BAD_REQUEST) # to do, 验证用户权限 if 'name' not in img: return JsonResponse(data=&#123;"msg": "无名文件无法上传"&#125;, status=status.HTTP_400_BAD_REQUEST) file_path = os.path.join(settings.IMG_ROOT, img.name) dest_img_path = open(file_path, 'wb+') for chunk in img.chunks(): dest_img_path.write(chunk) dest_img_path.close() return JsonResponse(data=&#123;"msg": "图片上传成功", "url": file_path&#125;, status=status.HTTP_202_ACCEPTED) else: return JsonResponse(data=&#123;"msg": "this method is not allowed"&#125;, status=status.HTTP_405_METHOD_NOT_ALLOWED) 1.3 urls.py12# users/urls.py path('upload/', views.upload_img), 2. 图片访问所有访问静态文件都可以使用该方法，图片访问为只读请求，不需要经过用户认证等权限处理，使用该方法的好处是不需要经过django的进一步处理，减轻服务器的压力。 修改nginx.conf配置文件，添加一下部分 123location /img &#123; alias /home/projects/closet/closetUsers/tempPhotos; #存放图片的文件夹路径&#125; 访问方式：http://120.76.62.132/img/tank_sample_4.jpeg 403Forbbien alwasy 404]]></content>
  </entry>
  <entry>
    <title><![CDATA[Django+nginx+uwsgi配置]]></title>
    <url>%2F2019%2F01%2F01%2FGuideBook%2FDjango%2FDjango%2Bnginx%2Buwsgi%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Django+nginx+uwsgi配置Django+nginx+uwsgi配置 在线项目部署 1. uwsgi安装测试1.1 uwsgi安装1root@iZwz969jm0y04abuhgx4byZ:~# python3 -m pip install uwsgi 1.2 uwsgi测试测试 uwsgi 是否正常： 新建 test.py 文件，内容如下： 123def application(env, start_response): start_response('200 OK', [('Content-Type','text/html')]) return "Hello World" 然后在终端运行： 1uwsgi --http :8001 --wsgi-file test.py 在浏览器内输入：http://127.0.0.1:8001，查看是否有&quot;Hello World”输出，若没有输出，请检查你的安装过程。 2. nginx 安装测试2.1 安装 Nginx安装命令如下： 12345678cd ~wget http://nginx.org/download/nginx-1.11.0.tar.gztar xf nginx-1.11.0.tar.gzcd nginx-1.11.0./configure --prefix=/usr/local/nginx-1.11.0 \--with-http_stub_status_module \--with-http_gzip_static_modulemake &amp;&amp; make install 你可以阅读 Nginx 安装配置 了解更多内容。 3. Django安装测试笔者用的是python3以上的版本 1pip install django 测试 django 是否正常，运行： 123django-admin.py startproject demositecd demositepython2.7 manage.py runserver 0.0.0.0:8002 在浏览器内输入：http://127.0.0.1:8002，检查django是否运行正常。 项目组织结构： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566root@iZwz969jm0y04abuhgx4byZ:/home/projects/closet/closetUsers# tree.├── closetUsers│ ├── __init__.py│ ├── __pycache__│ │ ├── __init__.cpython-37.pyc│ │ ├── settings.cpython-37.pyc│ │ ├── urls.cpython-37.pyc│ │ └── wsgi.cpython-37.pyc│ ├── settings.py│ ├── urls.py│ └── wsgi.py├── __init__.py├── jsonTest│ ├── modifyUserInfo.json│ └── test.json├── manage.py├── __pycache__│ ├── __init__.cpython-37.pyc│ ├── manage.cpython-37.pyc│ ├── settings.cpython-37.pyc│ ├── urls.cpython-37.pyc│ └── wsgi.cpython-37.pyc├── settings.py├── static├── tempPhotos├── urls.py├── users│ ├── admin.py│ ├── apps.py│ ├── backends.py│ ├── forms.py│ ├── __init__.py│ ├── matches.py│ ├── migrations│ │ ├── 0001_initial.py│ │ ├── 0002_auto_20181222_1315.py│ │ ├── 0003_auto_20181222_1428.py│ │ ├── 0004_auto_20181229_1631.py│ │ ├── __init__.py│ │ └── __pycache__│ │ ├── 0001_initial.cpython-37.pyc│ │ ├── 0002_auto_20181222_1315.cpython-37.pyc│ │ ├── 0003_auto_20181222_1428.cpython-37.pyc│ │ ├── 0004_auto_20181229_1631.cpython-37.pyc│ │ └── __init__.cpython-37.pyc│ ├── models.py│ ├── permissions.py│ ├── __pycache__│ │ ├── admin.cpython-37.pyc│ │ ├── backends.cpython-37.pyc│ │ ├── __init__.cpython-37.pyc│ │ ├── matches.cpython-37.pyc│ │ ├── models.cpython-37.pyc│ │ ├── permissions.cpython-37.pyc│ │ ├── serializers.cpython-37.pyc│ │ ├── urls.cpython-37.pyc│ │ └── views.cpython-37.pyc│ ├── serializers.py│ ├── test.png│ ├── tests.py│ ├── urls.py│ └── views.py└── wsgi.py10 directories, 52 files]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android打包]]></title>
    <url>%2F2018%2F12%2F27%2FGuideBook%2FAndroid%2FAndroid_%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Android 打包keystore.jks Password: closet123 Error:error: failed to read PNG signature: file does not start with PNG signature. android studio 打包apk时报错. 错误：无法读取PNG签名：文件没有从PNG签名开始。 一般都是图片格式有问题 可能是后缀更改了，可能是图片压缩时产生的问题。 重新处理图片再加载 Solve: 找到对应的图片,右键编辑下,重新另存为png类型的图片即可 生成keystore.jks 1234567891011121314151617181920212223242526272829303132333435363738394041luomeideMacBook-Pro:MyApplication 2 luomei$ keytool -list -v -keystore /Users/luomei/Desktop/closet/app/keystore.jks输入密钥库口令: 密钥库类型: JKS密钥库提供方: SUN您的密钥库包含 1 个条目别名: closet创建日期: 2018年12月30日条目类型: PrivateKeyEntry证书链长度: 1证书[1]:所有者: CN=closet, OU=closetTJ, O=closetTJ, L=shanghai, ST=shanghai, C=86发布者: CN=closet, OU=closetTJ, O=closetTJ, L=shanghai, ST=shanghai, C=86序列号: f0fd6fc生效时间: Sun Dec 30 15:23:13 CST 2018, 失效时间: Thu Dec 24 15:23:13 CST 2043证书指纹: SHA1: CD:57:AE:DF:A5:13:C6:6D:3B:1A:4B:21:4B:FC:60:75:FE:FA:29:3C SHA256: 8F:56:BD:59:35:DE:7E:68:97:E0:E8:18:E0:86:0D:EF:1C:B0:22:BD:9D:2B:71:1D:27:D3:41:4E:88:34:66:B2签名算法名称: SHA256withRSA主体公共密钥算法: 2048 位 RSA 密钥版本: 3扩展: #1: ObjectId: 2.5.29.14 Criticality=falseSubjectKeyIdentifier [KeyIdentifier [0000: 83 3E 3F 13 08 81 C6 D1 0F B2 69 D7 5C AB D4 24 .&gt;?.......i.\..$0010: D7 CD AD 58 ...X]]**************************************************************************************Warning:JKS 密钥库使用专用格式。建议使用 "keytool -importkeystore -srckeystore /Users/luomei/Desktop/closet/app/keystore.jks -destkeystore /Users/luomei/Desktop/closet/app/keystore.jks -deststoretype p格式 PKCS12。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Django拓展auth用户]]></title>
    <url>%2F2018%2F12%2F22%2FGuideBook%2FDjango%2FDjango%E6%8B%93%E5%B1%95auth%20%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[Django拓展auth 用户完成注册登录登出注销操作 ！！！拓展auth用户请务必在 python manage.py migrate 前进行！！！ 新建一个project：closetUsers 修改 settings.py 12345678910111213141516171819202122232425#closetUsers/settings.pyINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'users', # modify 'rest_framework', # modify 'django_filters', # modify ]#update database config DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'closetUser', 'USER': 'may', 'PASSWORD': 'may233', 'HOST': '120.76.62.132', 'PORT': '3306', &#125;&#125;#add auth_user_model !after! add the extended userAUTH_USER_MODEL = 'users.User' #pattern: &lt;appName&gt;.&lt;className&gt; 新建一个app：users 修改 users/__init__.py 1234#users/__init__.pyimport pymysqlpymysql.install_as_MySQLdb()#use for django2.x version to link mysql database 在 users底下添加文件 urls.py ，修改 closetUsers.urls.py 12345678910#closetUsers/urls.pyfrom django.contrib import adminfrom django.urls import pathfrom django.conf.urls import include #add thisurlpatterns = [ path('admin/', admin.site.urls), path('', include('users.urls')), #add this, pattern: &lt;appName&gt;.urls] 修改 users.models.py， 添加拓展的用户类，继承自 AbstractUser， 注：如原来的auth.User 已有的属性不需要再添加 12345678910111213141516#users/models.pyfrom django.db import modelsfrom django.contrib.auth.models import AbstractUser# Create your models here.class User(AbstractUser): """ save the user info """ style = models.CharField(max_length=30, default='casual', null=True, blank=True) profile = models.URLField(default='http://120.76.62.132:8080/photos/40padded.jpg', blank=True) phone = models.CharField(max_length=11, null=True, blank=True) def __str__(self): return self.username 建表 123xxxdeMacBook-Pro:closetUsers xxx$ python3 manage.py migratexxxdeMacBook-Pro:closetUsers xxx$ python3 manage.py makemigrations usersxxxdeMacBook-Pro:closetUsers xxx$ python3 manage.py migrate users 重写UserCreationForm, UserChangeForm， 在users 底下新建 form.py文件，其实我只是想要提供一个restful的API而不是建立一个网站，因而应该不需要使用到表单创建，但Django文档中说明拓展User需要重写这两个表单因此还是重写了。 1234567891011121314151617181920212223242526#users/forms.pyfrom django.contrib.auth.forms import UserCreationForm, UserChangeFormfrom django import formsfrom .models import Userclass RegisterForm(UserCreationForm): class Meta(UserCreationForm.Meta): model = User fields = ('username', 'email', 'phone', 'style', 'profile') # check if email is valid def clean_email(self): email = self.cleaned_data['email'] users = User.objects.filter(email=email) if users: raise forms.ValidationError("该邮箱已注册过，尝试登录？") return emailclass ChangeInfoForm(UserChangeForm): class Meta(UserChangeForm.Meta): model = User fields = ('username', 'email', 'phone', 'style', 'profile') 一、注册法一：暴力解决 在 views.py中添加相关类或函数 12345678910111213141516#users/views.pyfrom django.shortcuts import renderfrom django.http import JsonResponse, HttpResponsefrom rest_framework import statusfrom .models import User# Create your views here.def sign_up(request): username = request.data['username'] password = request.data['password'] users = User.objects.filter(username=username) if users: return HttpResponse('该用户已存在', status=status.HTTP_400_BAD_REQUEST) user = User.objects.create_user(username=username, password=password) return HttpResponse('创建成功，登录？', status=status.HTTP_200_OK) 在 urls.py 中添加相关路径 12345678#users/urls.pyfrom django.urls import pathfrom rest_framework.urlpatterns import format_suffix_patternsfrom users import viewsurlpatterns = format_suffix_patterns([ path('users/add1/', views.sign_up),]) 使用 httpie 模拟post请求 123#pattern: http post &lt;urlAddress&gt; @&lt;jsonFileAddress&gt;xxxdeMacBook-Pro:closetUsers xxx$ http --json post http://127.0.0.1:8000/users/add1/ @/Users/xxx/Desktop/closet/jsonTest/login.jsonHTTP/1.1 403 Forbidden Error: HTTP/1.1 403 Forbidden, CSRF verification failed. Request aborted. Solve: 为了防止跨站伪造请求，django引入了csrf机制，引入csrf_exempt 123456#users/views.pyfrom django.views.decorators.csrf import csrf_exempt@csrf_exemptdef sign_up(request): pass Error: HTTP/1.1 500 Internal Server Error,继续看报错信息，发现进行sign_up函数解析后出现错误，发现是request以json格式发送请求时，无法以request.data[&#39;username&#39;] 的方式获取数据 Solve： 1234567#users/views.py inside sign_up function import jsonpost_body = request.body #django2.x use body, while django1.x use raw_post_datadata = json.loads(post_body)username = data['username']password = data['password'] 再次尝试使用httpie发送请求，成功！开心！ 1234567891011xxxdeMacBook-Pro:closetUsers xxx$ http --json post http://127.0.0.1:8000/users/add1/ @/Users/xxx/Desktop/closet/jsonTest/login.jsonHTTP/1.1 200 OKContent-Length: 24Content-Type: text/html; charset=utf-8Date: Sat, 22 Dec 2018 05:17:42 GMTServer: WSGIServer/0.2 CPython/3.7.0X-Frame-Options: SAMEORIGIN创建成功，登录？xxxdeMacBook-Pro:closetUsers xxx$ 以上只是简单的注册，下面我们来拓展一下，加上对于信息的验证，加上了对于手机号码和邮箱的格式验证 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#users/views.pyfrom django.http import JsonResponse, HttpResponsefrom rest_framework import statusfrom .models import Userfrom django.views.decorators.csrf import csrf_exemptimport jsonfrom django.contrib.auth import login, authenticate, logoutimport re# Create your views here.@csrf_exemptdef sign_up(request): if request.method == 'POST': post_body = request.body data = json.loads(post_body) if 'username' in data: username = data['username'] else: username = 'may' password = data['password'] if 'email' in data: email = data['email'] # check if email is valid email_pat = re.compile(r'^[0-9a-zA-Z_]&#123;0,19&#125;@[0-9a-zA-Z]&#123;1,13&#125;\.[com,cn,net]&#123;1,3&#125;$') if not re.match(email_pat, email): return JsonResponse(data=&#123;"msg": "请输入正确的邮箱名"&#125;, status=status.HTTP_400_BAD_REQUEST) else: email = 'error' if 'phone' in data: phone = data['phone'] # check if phone is valid phone_pat = re.compile(r'^(13\d|14[5|7]|15\d|166|17[3|6|7]|18\d)\d&#123;8&#125;$') if not re.match(phone_pat, phone): return JsonResponse(data=&#123;"msg": "请输入正确的手机号"&#125;, status=status.HTTP_400_BAD_REQUEST) else: phone = 'error' if 'profile' in data: profile = data['profile'] else: profile = 'http://120.76.62.132:8080/photos/default.jpg' if 'style' in data: style = data['style'] else: style = 'casual' # users = User.objects.filter(username=username) email_users = User.objects.filter(email=email) phone_users = User.objects.filter(phone=phone) name_users = User.objects.filter(username=username) if email_users: return JsonResponse(data=&#123;"msg": "该邮箱已注册过"&#125;, status=status.HTTP_400_BAD_REQUEST) if phone_users: return JsonResponse(data=&#123;"msg": "该手机号已注册过"&#125;, status=status.HTTP_400_BAD_REQUEST) if name_users: return JsonResponse(data=&#123;"msg": "该用户已存在"&#125;, status=status.HTTP_400_BAD_REQUEST) if email == 'error': email = '' if phone == 'error': phone = '' user = User.objects.create_user(username=username, password=password, email=email, phone=phone, style=style, profile=profile) return JsonResponse(data=&#123;"msg": "创建成功，登录？"&#125;, status=status.HTTP_200_OK) 法二：django-rest-framework尝试用django-rest-framework提供的方法实现 二、登录法一：沿袭我们的暴力方案2.1 使用auth模块提供的login使用username和password登录 1234567891011121314151617181920#users/views.py@csrf_exemptdef sign_in(request): if request.method == 'POST': post_body = request.body data = json.loads(post_body) username = data['username'] password = data['password'] print(username) user = authenticate(username=username, password=password) if user: if user.is_active: login(request, user) print(request.user) return JsonResponse(data=&#123;"msg": "OK"&#125;, status=status.HTTP_200_OK) else: return JsonResponse(data=&#123;"msg": "用户不存在"&#125;, status=status.HTTP_400_BAD_REQUEST) else: return JsonResponse(data=&#123;"msg": "用户或密码错误"&#125;, status=status.HTTP_400_BAD_REQUEST) 2.2 拓展，自定义后端，使用邮箱登录参考自定义认证后台 添加 backends.py文件 1234567891011121314151617181920212223from .models import Userclass EmailBackend(object): def authenticate(self, request, **credentials): # 要注意登录表单中用户输入的用户名或者邮箱的 field 名均为 username email = credentials.get('email', credentials.get('username')) try: user = User.objects.get(email=email) except User.DoesNotExist: pass else: if user.check_password(credentials["password"]): return user def get_user(self, user_id): """ 该方法是必须的 """ try: return User.objects.get(pk=user_id) except User.DoesNotExist: return None 在 setttings.py 中加入后端文件告诉Django 你使用了自定义后端 12345AUTHENTICATION_BACKENDS = ( 'django.contrib.auth.backends.ModelBackend', 'users.backends.EmailBackend', 'users.backends.PhoneBackend',) 2.3 同理拓展，自定义后端，使用手机登录代码大同小异，不赘述了 三、登出法一：继续，暴力解决一切事物1234567#users/views.py@csrf_exemptdef sign_out(request): if request.method == 'GET': logout(request) return JsonResponse(data=&#123;"msg": "登出成功"&#125;, status=status.HTTP_200_OK) 四、注销法一：继续，暴力解决一切事物12345678910111213141516171819202122#users/views.py@csrf_exemptdef sign_off(request): if request.method == 'POST': post_body = request.body data = json.loads(post_body) username = data['username'] password = data['password'] user = authenticate(username=username, password=password) if user: email_pat = re.compile(r'^[0-9a-zA-Z_]&#123;0,19&#125;@[0-9a-zA-Z]&#123;1,13&#125;\.[com,cn,net]&#123;1,3&#125;$') phone_pat = re.compile(r'^(13\d|14[5|7]|15\d|166|17[3|6|7]|18\d)\d&#123;8&#125;$') if re.match(email_pat, username): delete_result = User.objects.filter(email=username).delete() elif re.match(phone_pat, username): delete_result = User.objects.filter(phone=username).delete() else: delete_result = User.objects.filter(username=username).delete() if delete_result: return JsonResponse(data=&#123;"msg": "注销成功"&#125;, status=status.HTTP_200_OK) return JsonResponse(data=&#123;"msg": "用户不存在"&#125;, status=status.HTTP_400_BAD_REQUEST)]]></content>
  </entry>
  <entry>
    <title><![CDATA[DjangoOnMac_0]]></title>
    <url>%2F2018%2F12%2F16%2FGuideBook%2FDjango%2FDjangoOnMac_0%2F</url>
    <content type="text"><![CDATA[Django on Mac part01. Django连接MySQL1.1 未安装驱动Error: django.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module. Did you install mysqlclient? Solve:修改 __init__.py文件： 12import pymysqlpymysql.install_as_MySQLdb() 1.2 连接超时Error: django.db.utils.OperationalError: (2003, “Can’t connect to MySQL server on ‘120.76.62.132’ (timed out)”) Solve: 先试一下能不能ping通服务器，如果能ping通但连接不上可能是因为服务器的防火墙没有开放3306端口 1.3 mysql未监听ERROR 2003 (HY000): Can’t connect to MySQL server on ‘120.76.62.132’ (61) Solve： 查看mysql监听IP和端口是否正常。 使用：netstat -anpt 监听得地址如果是:::3306或者是0.0.0.0:3306，表示监听所有IP地址，这监听状态是正常。若出现127.0.0.0:3306，说明监听的本地地址，需要在mysql配置文件中将bind-address选项设置为 12[mysqld]bind_address=0.0.0.0 重启mysql。 1.4 密码错误ERROR 1045 (28000): Access denied for user ‘root’@’58.41.202.207’ (using password: YES)]]></content>
  </entry>
  <entry>
    <title><![CDATA[DjangoInUbuntu_2]]></title>
    <url>%2F2018%2F12%2F16%2FGuideBook%2FDjango%2FDjangoInUbuntu_2%2F</url>
    <content type="text"><![CDATA[Django in Ubuntu part2Django和服务器的配置 Django+Nginx + Tomcat? Nginx 1root@iZwz969jm0y04abuhgx4byZ:~# apt-get install nginx]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F15%2FGuideBook%2FDjango%2FDjangoInUbuntu_1%2F</url>
    <content type="text"><![CDATA[Django In Ubuntu part11. 数据库配置我们在项目的 settings.py 文件中找到 DATABASES 配置项，将其信息修改为： HelloWorld/HelloWorld/settings.py: 文件代码：1234567891011DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', # 或者使用 mysql.connector.django 'NAME': 'test', 'USER': 'test', 'PASSWORD': 'test123', 'HOST':'localhost', 'PORT':'3306', &#125; &#125; 这里添加了中文注释，所以你需要在 HelloWorld/settings.py 文件头部添加 # -*- coding: UTF-8 -*-。 上面包含数据库名称和用户的信息，它们与 MySQL 中对应数据库和用户的设置相同。Django 根据这一设置，与 MySQL 中相应的数据库和用户连接起来 Error: django.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module: No module named MySQLdb. Solve: python2.7 + Django1.11 , 解决方案： pip install mysql-server 123456789101112root@iZwz969jm0y04abuhgx4byZ:~# pip install mysql-python#随后验证一下是否安装成功root@iZwz969jm0y04abuhgx4byZ:~# pythonPython 2.7.12 (default, Nov 12 2018, 14:36:49) [GCC 5.4.0 20160609] on linux2Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import MYSQLdbTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ImportError: No module named MYSQLdb&gt;&gt;&gt; import MySQLdb&gt;&gt;&gt; exit() 2. Django表单HTML表单是网站交互性的经典方式。 本章将介绍如何用Django对用户提交的表单数据进行处理。 HTTP 请求HTTP协议以”请求－回复”的方式工作。客户发送请求时，可以在请求中附加数据。服务器通过解析请求，就可以获得客户传来的数据，并根据URL来提供特定的服务。 GET 方法我们在之前的项目中创建一个 search.py 文件，用于接收用户的请求： /HelloWorld/HelloWorld/search.py 文件代码： 1234567891011121314151617# -*- coding: utf-8 -*- from django.http import HttpResponsefrom django.shortcuts import render_to_response # 表单def search_form(request): return render_to_response('search_form.html') # 接收请求数据def search(request): request.encoding='utf-8' if 'q' in request.GET: message = '你搜索的内容为: ' + request.GET['q'] else: message = '你提交了空表单' return HttpResponse(message) 在模板目录 templates 中添加 search_form.html 表单： /HelloWorld/templates/search_form.html 文件代码： &lt;!DOCTYPE html&gt; 菜鸟教程(runoob.com) urls.py 规则修改为如下形式： /HelloWorld/HelloWorld/urls.py 文件代码： 123456789from django.conf.urls import urlfrom . import view,testdb,search urlpatterns = [ url(r'^hello$', view.hello), url(r'^testdb$', testdb.testdb), url(r'^search-form$', search.search_form), url(r'^search$', search.search),] 访问地址 http://120.76.62.132:8000/search-form 并搜索 Error: 在Django视图函数中经常出现类似于’ascii’ codec can’t decode byte 0xef in position 0:ordinal not in range(128)的错误。 Solve: 使用同一套编码，将字符串全都转成byte string或unicode string ​ 1.将字符串全都转成byte string。​ self.response.out.write(“你好”+self.request.get(“argu”).encode(“utf-8”))​ 2.将字符串全都转成unicode string。​ self.response.out.write(u”你好”+self.request.get(“argu”))​ byte string转换成unicode string可以这样转unicode(unicodestring, “utf-8”) python编码错误 Error: django.db.utils.ProgrammingError: (1146, u”Table’’ doesn’t exist”)解决办法 Slove: 原因：访问了数据库里不存在的表，可能是因为在model改变之后表结构没有更新 1234567root@iZwz969jm0y04abuhgx4byZ:~/HelloWorld# python manage.py migrateroot@iZwz969jm0y04abuhgx4byZ:~/HelloWorld# python manage.py makemigrations TestModelMigrations for 'TestModel': TestModel/migrations/0002_contact_tag.py - Create model Contact - Create model Tagroot@iZwz969jm0y04abuhgx4byZ:~/HelloWorld# python manage.py migrate TestModel]]></content>
  </entry>
  <entry>
    <title><![CDATA[DjangoInUbutun_0]]></title>
    <url>%2F2018%2F12%2F14%2FGuideBook%2FDjango%2FDjangoInUbuntu_0%2F</url>
    <content type="text"><![CDATA[Django in Ubuntu part01. 安装12345678910root@iZwz969jm0y04abuhgx4byZ:~# apt-get install python-setuptoolsroot@iZwz969jm0y04abuhgx4byZ:~# python -m pip install "django&lt;2"root@iZwz969jm0y04abuhgx4byZ:~# pythonPython 2.7.12 (default, Nov 12 2018, 14:36:49) [GCC 5.4.0 20160609] on linux2Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import django&gt;&gt;&gt; django.VERSION(1, 11, 17, u'final', 0)&gt;&gt;&gt; 如果python版本为3.5以上，可以使用 easy_install django安装。 2. 创建新项目 使用pip 安装的话，用 1234567891011121314root@iZwz969jm0y04abuhgx4byZ:~# django-admin.pyNote that only Django core commands are listed as settings are not properly configured (error: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.).root@iZwz969jm0y04abuhgx4byZ:~# django-admin startproject HelloWorldroot@iZwz969jm0y04abuhgx4byZ:~# cd HelloWorld/root@iZwz969jm0y04abuhgx4byZ:~/HelloWorld# tree.├── HelloWorld│ ├── __init__.py│ ├── settings.py│ ├── urls.py│ └── wsgi.py└── manage.py1 directory, 5 files Error：Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings Solve: django-admin 不要py Error: DisallowedHost at / Invalid HTTP_HOST header Solve: 将项目名称下的 settings.py 中的 ALLOWED_HOSTS = [] 改成 ALLOWED_HOSTS = [&#39;*&#39;] 3. 视图和URL配置3.1 视图在先前创建的 HelloWorld 目录下的 HelloWorld 目录新建一个 view.py 文件，并输入代码： 1234from django.http import HttpResponse def hello(request): return HttpResponse("Hello world ! ") 3.2 URL配置接着，绑定 URL 与视图函数。打开 urls.py 文件，删除原来代码，将以下代码复制粘贴到 urls.py 文件中： 1234567from django.conf.urls import url from . import view urlpatterns = [ url(r'^$', view.hello),] #3.3 编译不需要，服务器会自动在更改后编译 随后编译 view.py 和 urls.py文件 1root@iZwz969jm0y04abuhgx4byZ:~/HelloWorld/HelloWorld# python -m py_compile urls.py 3.4 打开服务器注：如果是 Django &gt;= 2.0 的版本，urls.py 的 django.conf.urls 已经被 django.urls 取代。 django.urls 的用法参考如下： 1234567from django.urls import pathfrom . import viewurlpatterns = [ path('', view.hello), path('world/', view.world)] 其中最大的几个改变如下： import url 变成了 import path 如果是路径，则须在路径后加个/ 旧版 django 的用法： 123456from django.conf.urls import urlfrom . import view urlpatterns = [ url(r'^hello$', view.hello),] 新版的参考写法： 123456from django.urls import pathfrom . import viewurlpatterns = [ path('hello/', view.hello),]]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL搭建_Ubuntu]]></title>
    <url>%2F2018%2F12%2F14%2FGuideBook%2FUbuntu%E4%B8%8A%E7%9A%84MySQL%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Ubuntu上的MySQL搭建1234567891011121314151617181920212223242526272829303132333435root@iZwz969jm0y04abuhgx4byZ:~# apt-get updateroot@iZwz969jm0y04abuhgx4byZ:~# apt-get upgraderoot@iZwz969jm0y04abuhgx4byZ:~# apt-get install mysql-serverroot@iZwz969jm0y04abuhgx4byZ:~# apt-get install mysql-clientroot@iZwz969jm0y04abuhgx4byZ:~# apt-get install libmysqlclient-devroot@iZwz969jm0y04abuhgx4byZ:~# netstat -tap | grep mysqltcp 0 0 localhost:mysql *:* LISTEN 2109/mysqld root@iZwz969jm0y04abuhgx4byZ:~# mysql -u root -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.24-0ubuntu0.16.04.1 (Ubuntu)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.exit' at line 1mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.00 sec)mysql&gt; exitByeroot@iZwz969jm0y04abuhgx4byZ:~#]]></content>
  </entry>
  <entry>
    <title><![CDATA[SSH连接失败]]></title>
    <url>%2F2018%2F12%2F12%2FGuideBook%2F%E6%9C%8D%E5%8A%A1%E5%99%A8SSH%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[SSH连接失败SSH 登录失败：Host key verification failed由于公钥不一样了，所以无法登录，提示信息是 KEY 验证失败。解决方法是：在 /root/.ssh/known_hosts 文件里面将原来的公钥信息删除即可。 SSH 报 “Host key verification failed.”。一般来说，出现该错误有这么几种可能: ssh/known_hosts 裡面记录的目标主机 key 值不正确。这是最普遍的情况，只要删除对应的主机记录就能恢复正常。 运行命令： sudo rm /home/yourname/.ssh/known_hosts ssh 目录或者 .ssh/known_hosts 对当前用户的权限设置不正确。这种情况比较少，一般正确设置读写权限以后也能恢复正常。 /dev/tty 对 other 用户没有放开读写权限。这种情况极为罕见。出现的现象是，只有 root 用户能够使用 ssh client，而所有其他的普通用户都会出现错误。我今天遇到的就是第三种情况，修改 /dev/tty 的权限后，一切正常。为了避免以后忘记解决方法，记录在这里。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac_root]]></title>
    <url>%2F2018%2F12%2F09%2FGuideBook%2FMac%E7%BB%88%E7%AB%AF_root%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[Mac终端_root权限1234567891011121314151617181920xxxdeMacBook-Pro:~ xxx$ su root Password:su: Sorry//在平常打开的命令行下无法打开，我输入的是我的开机密码xxxdeMacBook-Pro:~ xxx$ sudo -iPassword:xxxdeMacBook-Pro:~ root# su rootsh-3.2# su xxxshell-init: error retrieving current directory: getcwd: cannot access parent directories: Permission deniedbash-3.2$ exitexitsh-3.2# logoutsh: logout: not login shell: use `exit'sh-3.2# exitexitxxxdeMacBook-Pro:~ root# exitlogoutxxxdeMacBook-Pro:~ xxx$ sudo -ixxxdeMacBook-Pro:~ root# logoutxxxdeMacBook-Pro:~ xxx$ Method 1:login：1234xxxdeMacBook-Pro:~ xxx$ su root Password:su: Sorry//在平常打开的命令行下无法打开，我输入的是我的开机密码 logout： 输入su 用户名，回车。 输入此用户密码，回车即可切换回此用户 直接输入 exit也可以 Method 2:login：123xxxdeMacBook-Pro:~ xxx$ sudo -iPassword:xxxdeMacBook-Pro:~ root# 输入密码时，不会显示任何字符，只管输入就好了 logout：123456//method 0xxxdeMacBook-Pro:~ root# logoutxxxdeMacBook-Pro:~ xxx$ //method 1xxxdeMacBook-Pro:~ root# exitxxxdeMacBook-Pro:~ xxx$]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tomcat配置]]></title>
    <url>%2F2018%2F12%2F09%2FGuideBook%2FTomcat%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[服务器：阿里云 远程连接到服务器远程连接到linux服务器 通过ssh连接1xxxdeMacBook-Pro:Guide book xxx$ ssh root@120.76.62.132 -i /Users/xxx/Desktop/i\ document/笔记/Guide\ book/xxx.pem Tomcat配置1. 给Mac安装jdk环境。 直接百度”jdk for Mac“，找到其中一个版本进行安装就可以了，安装完成后，打开终端，输入“java”或“javac”，如果出现java命令的使用说明，那么说明你的Mac上的jdk环境已经配置好，这个比起windows系统来说，简单方便很多。 2. 下载安装 Tomcat​ 下载 Tomcat 地址（官方地址）：https://tomcat.apache.org/download-80.cgi ​ 下载文件：mac下载 zip 和 tar.gz 都行，我下载的是 tar.gz 3. 安装： 压缩之后直接拷贝到资源库中，压缩后的文件夹名称为Tomcat8，记录此位置:/Library/Tomcat8（方便后续环境配置） 打开终端，输入以下命令/Library/Tomcat8/bin/startup.sh，浏览器中输入localhost:8080，就可以看到以下效果: 12luomeideMacBook-Pro:~ luomei$ Library/Tomcat8/bin/starup.sh-bash: Library/Tomcat8/bin/starup.sh: No such file or directory 如果遇到提示No such file or directory错误提示，需要执行sudo chmod 755 Library/Tomcat/bin/*.sh，然后重新执行startup.sh，若出现permission denied 的情况，则在sudo模式下执行startup.sh，如果想停止Tomcat，直接执行shutdown.sh即可。在执行sudo时，必须使用带密码的用户。 12345678910111213141516171819// or sudo chmod 755 /Library/Tomcat8/bin/*.shxxxdeMacBook-Pro:~ xxx$ sudo chmod +x /Library/Tomcat8/bin/*.shPassword:xxxdeMacBook-Pro:~ xxx$ startup.shUsing CATALINA_BASE: /Library/Tomcat8Using CATALINA_HOME: /Library/Tomcat8Using CATALINA_TMPDIR: /Library/Tomcat8/tempUsing JRE_HOME: /Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/HomeUsing CLASSPATH: /Library/Tomcat8/bin/bootstrap.jar:/Library/Tomcat8/bin/tomcat-juli.jartouch: /Library/Tomcat8/logs/catalina.out: Permission denied/Library/Tomcat8/bin/catalina.sh: line 464: /Library/Tomcat8/logs/catalina.out: Permission deniedxxxdeMacBook-Pro:~ xxx$ sudo startup.shUsing CATALINA_BASE: /Library/Tomcat8Using CATALINA_HOME: /Library/Tomcat8Using CATALINA_TMPDIR: /Library/Tomcat8/tempUsing JRE_HOME: /Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/HomeUsing CLASSPATH: /Library/Tomcat8/bin/bootstrap.jar:/Library/Tomcat8/bin/tomcat-juli.jarTomcat started.xxxdeMacBook-Pro:~ xxx$ ​ 如果每次写路径比较麻烦，这个时候需要设置环境变量。 4. 设置 Tomcat 的环境变量:ps：不要在root权限下设置 ①使用vim编辑bash_profile，输入命令打开：vi .bash_profile(pico .bash_profile亦可) ②按 i进入编辑模式 ​ ③输入Tomcat存储路径 export PATH=&quot;/Users/keso/Library/Tomcat8/bin:$PATH&quot;（注意：此处路径是自己保存的 tomcat 存储路径） ④esc退出编辑模式，输入 :wq 保存并退出vim ​ ⑤更新配置的环境变量，输入命令：source .bash_profile ⑥终端中输入startup.sh， startup.sh后出现类似 “Permission denied” ，这个时候需要对目录进行权限设置：输入 sudo chmod 755 Library/Tomcat8/bin/*.sh 回车，设置文件的读写执行权限，参考第3步中的解决方案。 123456789101112131415161718xxxdeMacBook-Pro:~ xxx$ vi .bash_profilexxxdeMacBook-Pro:~ xxx$ source .bash_profilexxxdeMacBook-Pro:~ xxx$ sudo startup.shPassword:Using CATALINA_BASE: /Library/Tomcat8Using CATALINA_HOME: /Library/Tomcat8Using CATALINA_TMPDIR: /Library/Tomcat8/tempUsing JRE_HOME: /Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/HomeUsing CLASSPATH: /Library/Tomcat8/bin/bootstrap.jar:/Library/Tomcat8/bin/tomcat-juli.jarTomcat started.xxxdeMacBook-Pro:~ xxx$ shutdown.shUsing CATALINA_BASE: /Library/Tomcat8Using CATALINA_HOME: /Library/Tomcat8Using CATALINA_TMPDIR: /Library/Tomcat8/tempUsing JRE_HOME: /Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/HomeUsing CLASSPATH: /Library/Tomcat8/bin/bootstrap.jar:/Library/Tomcat8/bin/tomcat-juli.jarNOTE: Picked up JDK_JAVA_OPTIONS: --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.io=ALL-UNNAMED --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMEDxxxdeMacBook-Pro:~ xxx$ 5. 设置完成之后，输入 sudo startup.sh会显示启动, 打开 localhost:8080 可测试，出现上述页面。 关闭使用 shutdown.sh 即可; 到此，Tomcat 配置完成。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ns3网络仿真基本流程]]></title>
    <url>%2F2018%2F12%2F06%2FGuideBook%2FNs3%E4%BB%BF%E7%9C%9F%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Ns3网络仿真基本流程：1） 选择和开发相应模块；根据实际仿真对象和仿真场景选择相应的仿真模块；如果搭建的网络比较新，读者就需要开发自己设计的协议。 2） 编写网络仿真脚本；生成节点node； 安装信道Channel和相应的网络设备NetDevice， 安装协议栈 安装应用层协议 其他配置等 启动仿真 3） 仿真结果分析；4） 根据结果调试网络配置参数和修改源代码；]]></content>
  </entry>
  <entry>
    <title><![CDATA[AndroidAPP后台搭建]]></title>
    <url>%2F2018%2F12%2F05%2FGuideBook%2FAndroid%2FAndroid_APP%E5%90%8E%E5%8F%B0%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[AndroidAPP后台搭建选取 jdk、tomcat、MySQL、FileZilla 参考教程 内网穿透，使用ngrok]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL_errors]]></title>
    <url>%2F2018%2F12%2F05%2FGuideBook%2FMySQL%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[MySQL版本：MySQL8.0.11 系统：MacOS 10.14.1 Q1：Unable to load authentication plugin ‘caching_sha2_password’.​ datagrip连接的时候连接不到，原因是mysql8.0之前的版本用的是mysql_native_password, 但mysql8.0之后的版本连接使用的密码是caching_sha2_password。 ————————————————————2018.12.5————————————————————————— 解决： 1234567891011mysql&gt; ALTER USER 'test'@'localhost' IDENTIFIED BY '1234' PASSWORD EXPIRE NEVER; Query OK, 0 rows affected (0.08 sec)mysql&gt; ALTER USER 'test'@'localhost' IDENTIFIED WITH mysql_native_password BY '1234';Query OK, 0 rows affected (0.03 sec)mysql&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.00 sec)mysql&gt; alter user 'root'@'localhost' identified by '1234';Query OK, 0 rows affected (0.01 sec)]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL_使用]]></title>
    <url>%2F2018%2F12%2F05%2FGuideBook%2FMySQL%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[MySQL使用安装环境：mac MySQL安装 下载安装，我已经不太记得了，有点久远的事情 从 官网下载dmg，直接安装就好，有一步需要注意的就是弹出初始密码的时候记得记下来！！！ 配置环境变量 进入 bash_profile 文件 1xxxdeMacBook-Pro:~ xxx$ vim ~/.bash_profile 按 i 进入编辑模式，在文件末尾加上mysql的文件路径： 1export PATH=$&#123;PATH&#125;:/usr/local/mysql/bin 输入 :wq 退出vim编辑，冒号不要忘记了！不然会进入 recording@ 状态。 使得该文件生效 1xxxdeMacBook-Pro:~ xxx$ vim ~/.bash_profile 进入mysql 1xxxdeMacBook-Pro:~ xxx$ mysql -u root -p 随后输入密码 123456789101112131415xxxdeMacBook-Pro:~ xxx$ mysql -u root -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 8Server version: 8.0.11 MySQL Community Server - GPLCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; 忘记密码了咋整，发现了一个很神奇的东西 输入新的密码，再在终端上尝试一下你的新密码，你就会惊喜的发现it works！ MySQL使用ubuntu 123service mysql startservice mysql restartservice mysql stop]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ns3ForUbuntu]]></title>
    <url>%2F2018%2F12%2F05%2FGuideBook%2FNs3forUbuntu%2F</url>
    <content type="text"><![CDATA[Q&amp;AQ1: g++: internal compiler error: Killed (program cc1plus)安装教程 ===================================================================================== 环境：ubuntu 16.04 安装： ns-3.28 ======================================================================================= Please submit a full bug report, 查了很多资料，最后发现主要原因是内存不足, 临时使用交换分区来解决吧 123456sudo dd if=/dev/zero of=/swapfile bs=64M count=16#count的大小就是增加的swap空间的大小，64M是块大小，所以空间大小是bs*count=1024MBsudo mkswap /swapfile#把刚才空间格式化成swap格式sudo swapon /swapfile#使用刚才创建的swap空间 After compiling, you may wish to Code: 12sudo swapoff /swapfilesudo rm /swapfile 开了个临时交换分区以后快了好多【引起舒适】 Q2: install netanimStep1：安装必要的插件先简单介绍下synaptic： 新立得（Synaptic）是 debian 及其衍生版本如Ubuntu Linux操作系统的包管理工具apt的图形化前端。它结合了图形界面的简单操作和 apt-get 命令行工具的强大功能。您可以使用新立得安装、删除、配置、升级软件包，对软件包列表进行浏览、排序、搜索以及管理软件仓库或者升级整个系统。简单来说就是apt-get的图形化界面，也可以用apt-get代替，看个人爱好安装很简单 1$ sudo apt-get install synaptic 启动也很简单 1$ sudo synaptic 如果已经安装好了，请忽略上面讲述 启动也很简单sudo synaptic 如果已经安装好了，请忽略上面讲述 先用synaptic安装三个插件： qt4-qmake：安装工具libqt4-dev：绘图所需libxml2-dev：netanim需要读取程序生成的xml文件，离线展示动画搜索到对应的插件之后如果没有安装，就右键-&gt;mark for installation -&gt;Apply Step2：安装进入ns3的文件夹，执行命令 12345$ cd ns-allinone-3.xx$ cd netanim-3.xxx$ make clean$ qmake NetAnim.pro$ make 安装完毕 Step3：启动在当前文件夹下运行下面命令，启动软件 1$ ./NetAnim 出现界面 Step4：运行在NS3提供的示例first.py中，并没有生成NetAnim所需要的xml文件，我们尝试用NetAnim来展示first.cc的仿真结果。 首先在first.cc里面，加上头文件 include &quot;ns3/netanim-module.h&quot; run前面加上三句代码 1234567AnimationInterface anim("first.xml");anim.SetConstantPosition(nodes.Get(0), 1.0, 2.0);anim.SetConstantPosition(nodes.Get(1), 2.0, 3.0);Simulator::Run();Simulator::Destroy();return 0 保存后退出 第二三行是描绘两个节点的坐标，也可以不要这两行 在ns3文件夹下重新编译程序./waf --run scracth/first在netanim文件夹下重新启动./NetAnim Open-&gt;first.xml-&gt;Play 在2秒附近就可以看到动画演示。//生成的xml文件再ns3.xx文件夹下 Q3: 在NS3下如何用Python脚本，以及PyViz可视化Method 1:12./waf shellpython examples/tutorial/first.py Method 2:1./waf --pyrun examples/tutorial/first.py 接下来是下载 PyViz 使用以下命令来安装： 12sudo apt-get install python-dev python-pygraphviz python-kiwi python-pygoocanvas \ python-gnome2 python-gnomedesktop python-rsvg 安装完后运行一个简单的例子： 1./waf --pyrun src/contrib/flow-monitor/examples/wifi-olsr-flowmon.py --vis 然后你就会看到一个由9个节点组成的网络拓扑：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac_vim]]></title>
    <url>%2F2018%2F12%2F05%2FGuideBook%2FMac%E7%BB%88%E7%AB%AF_vim%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Mac终端 vim的简单使用mac终端vim使用]]></content>
  </entry>
  <entry>
    <title><![CDATA[StarUML破解]]></title>
    <url>%2F2018%2F12%2F05%2FGuideBook%2FStarUML%203.0.2%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Staruml 3.0.2破解方法（for Mac 安装homebrew，请移步另一教程 安装npm 1xxxdeMacBook-Pro:~ xxx$ brew install node 安装asar 1luomeideMacBook-Pro:~ luomei$ npm install -g asar 进入staruml的包目录 1luomeideMacBook-Pro:~ luomei$ cd /Applications/StarUML.app/Contents/Resources/ 解压app.asar 1luomeideMacBook-Pro:~ luomei$ asar extract app.asar app 进入验证license的文件 1xxxdeMacBook-Pro:~ xxx$ vim app/src/engine/license-manager.js 修改源代码 写到这里的时候使用到了vim，先简单介绍一下 进入时先按 i 键 随后找到 checkLicenseValidity() 更改 123456789101112xcheckLicenseValidity () &#123; this.validate().then(() =&gt; &#123; setStatus(this, true) &#125;, () =&gt; &#123; // 原来的代码，如果失败就会将状态设置成false // setStatus(this, false) // UnregisteredDialog.showDialog() //修改后的代码 setStatus(this, true) &#125;) &#125; 输入 :wq 退回到原先的终端界面 重新打包替换原来的app.asar 1xxxdeMacBook-Pro:~ xxx$ asar pack app app.asar]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenGL配置]]></title>
    <url>%2F2018%2F10%2F12%2FGuideBook%2Fopencv%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[openGL配置OpenGL的长路谁陪我走 opencv配置 在XCode中使用OpenCV 创建一个空的command line工程。 在main.cpp中写代码： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;using namespace cv;int main(int argc, const char * argv[]) &#123; // insert code here... Mat image; image = imread("/Users/luomei/Desktop/peggy.jpeg");// 测试图片路径 if ( !image.data ) &#123; printf("No image data \n"); return -1; &#125; namedWindow("Display Image", WINDOW_AUTOSIZE ); waitKey(100); cvDestroyWindow("Display Image"); return 0;&#125; 添加lib文件：右键点击工程名，选择“Add files to..”，在文件选择对话框弹出来时输入“/”，在弹出的路径框中输入：/usr/local/lib，全选该文件夹下的全部dylib文件，添加至工程。 添加lib文件查找支持: 点击工程名文件，进入“Build Settings”选项卡，在“Library Search Paths”栏中输入“/usr/local/lib” 添加头文件：点击工程名文件，进入“Build Settings”选项卡，在“Header Search Paths”栏中输入：“/usr/local/include /usr/local/include/opencv” 编译运行整个工程，运行成功~~]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android_errosr]]></title>
    <url>%2F2018%2F10%2F07%2FGuideBook%2FAndroid%2FAndroid_ErrorSummary%2F</url>
    <content type="text"><![CDATA[android ======================================================================================= 版本信息： Android Studio 3.1.4Build #AI-173.4907809, built on July 24, 2018JRE: 1.8.0_152-release-1024-b01 x86_64JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.oMac OS X 10.13.6 ======================================================================================= 推荐使用官方文档 https://developer.android.com/guide/topics/resources/providing-resources?hl=zh-cn 请链接vpn后进入 error：Failed to download samples index, please check your connection and try again solve：https://blog.csdn.net/qq_36556893/article/details/79278063 error:在android studio中新建android gradle project的时候connect refused：connect solve:https://blog.csdn.net/clarketang/article/details/38420417 ps:本地端口设置可查看：shadow socks-&gt;http代理设置 Error: read timed out]]></content>
  </entry>
</search>
